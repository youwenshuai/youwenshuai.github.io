<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DHCP服务器搭建</title>
    <url>/2024/03/06/dhcp/</url>
    <content><![CDATA[<h5 id="修改dhcp的主配置文件"><a href="#修改dhcp的主配置文件" class="headerlink" title="修改dhcp的主配置文件"></a>修改dhcp的主配置文件</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim /etc/dhcp/dhcpd.conf</span></span><br><span class="line">ddns-update-style none;</span><br><span class="line">subnet 192.168.2.0 netmask 255.255.255.0 &#123;</span><br><span class="line">	range 192.168.2.100 192.168.2.200;</span><br><span class="line">	option domain-name-servers 192.168.2.1;</span><br><span class="line">	option domain-name <span class="string">&quot;server.com&quot;</span>;</span><br><span class="line">	option routers 192.168.2.250;</span><br><span class="line">	option broadcast-address 192.168.2.255;</span><br><span class="line">	default-lease-time 600;</span><br><span class="line">	max-lease-time 7200;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改网卡文件"><a href="#修改网卡文件" class="headerlink" title="修改网卡文件"></a>修改网卡文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">vim /etc/sysconfig/dhcpd</span></span><br><span class="line">DHCPDARGS=eth3</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS服务器搭建</title>
    <url>/2024/03/06/dns/</url>
    <content><![CDATA[<h5 id="dns服务端"><a href="#dns服务端" class="headerlink" title="dns服务端"></a>dns服务端</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum -y install bind </span></span><br><span class="line">options &#123;</span><br><span class="line">        listen-on port 53 &#123; any; &#125;;</span><br><span class="line">        listen-on-v6 port 53 &#123; any; &#125;;</span><br><span class="line">        directory       <span class="string">&quot;/var/named&quot;</span>;</span><br><span class="line">        dump-file       <span class="string">&quot;/var/named/data/cache_dump.db&quot;</span>;</span><br><span class="line">        statistics-file <span class="string">&quot;/var/named/data/named_stats.txt&quot;</span>;</span><br><span class="line">        memstatistics-file <span class="string">&quot;/var/named/data/named_mem_stats.txt&quot;</span>;</span><br><span class="line">        allow-query     &#123; any; &#125;;</span><br><span class="line">        recursion yes;</span><br><span class="line">        dnssec-enable yes;</span><br><span class="line">        dnssec-validation no;</span><br><span class="line">        dnssec-lookaside auto;</span><br><span class="line">        /* Path to ISC DLV key */</span><br><span class="line">        bindkeys-file <span class="string">&quot;/etc/named.iscdlv.key&quot;</span>;</span><br><span class="line">        managed-keys-directory <span class="string">&quot;/var/named/dynamic&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">logging &#123;</span><br><span class="line">        channel default_debug &#123;</span><br><span class="line">                file <span class="string">&quot;data/named.run&quot;</span>;</span><br><span class="line">                severity dynamic;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">&quot;wode.com&quot;</span> IN &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;wode&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">&quot;0.168.192.in-addr.arpa&quot;</span>&#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;fan&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2cd /var/named</span><br><span class="line">cp named.localhost wode </span><br><span class="line">cp named.localhost fan</span><br><span class="line">chgrp named wode</span><br><span class="line">chgrp named fan</span><br><span class="line">vim wode </span><br><span class="line"><span class="variable">$TTL</span> 86400</span><br><span class="line"></span><br><span class="line">@       IN SOA  des.wode.com. root.wode.com. (</span><br><span class="line">                                        0       ; serial</span><br><span class="line">                                        1D      ; refresh</span><br><span class="line">                                        1H      ; retry</span><br><span class="line">                                        1W      ; expire</span><br><span class="line">                                        3H )    ; minimum</span><br><span class="line">@       IN      NS dns.wode.com.</span><br><span class="line">@       IN      MX 5 mail.wode.com.</span><br><span class="line">dns     IN      A  192.168.0.150</span><br><span class="line">mail    IN      A  192.168.0.150</span><br><span class="line">www     IN      A  192.168.0.150</span><br><span class="line">ftp     IN      CNAME    WWW</span><br><span class="line">~</span><br><span class="line">vim fan</span><br><span class="line"></span><br><span class="line"><span class="variable">$TTL</span> 86400</span><br><span class="line">@       IN SOA dns.wode.com. root.wode.com. (</span><br><span class="line">                                        0       ; serial</span><br><span class="line">                                        1D      ; refresh</span><br><span class="line">                                        1H      ; retry</span><br><span class="line">                                        1W      ; expire</span><br><span class="line">                                        3H )    ; minimum</span><br><span class="line">@       IN      NS dns.wode.com.</span><br><span class="line">@       IN      MX 5 mail.wode.com.</span><br><span class="line">150     IN      PTR     dns.wode.com.</span><br><span class="line">150     IN      PTR     mail.wode.com.</span><br><span class="line">150     IN      PTR     www.wode.com.</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker在线安装</title>
    <url>/2024/03/06/docker%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><strong>1.docker安装</strong></p>
<p>1、Docker 要求 CentOS 系统的内核版本高于 3.10 </p>
<p>通过 <strong>uname -r</strong> 命令查看你当前的内核版本</p>
<p><code>uname -r</code></p>
<p>2、使用 root 权限登录 Centos。确保 yum 包更新到最新。</p>
<p> <code>sudo yum update</code></p>
<p>3、卸载旧版本(如果安装过旧版本的话)</p>
<p><code>sudo yum remove docker  docker-common docker-selinux docker-engine</code></p>
<p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<p><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></p>
<p>5、设置yum源</p>
<p><code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></p>
<p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>
<p><code>yum list docker-ce --showduplicates | sort -r</code></p>
<p>7、安装docker</p>
<p><code>sudo yum install docker-ce</code></p>
<p>8、启动并加入开机启动</p>
<p><code>sudo systemctl start docker $ sudo systemctl enable docker</code></p>
<p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>
<p><code>docker version</code></p>
<blockquote>
<p>配置加速</p>
<p>sudo mkdir -p &#x2F;etc&#x2F;docker sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-‘EOF’ {  “registry-mirrors”: [“<a href="https://27zv9ros.mirror.aliyuncs.com"]">https://27zv9ros.mirror.aliyuncs.com&quot;]</a> } EOF sudo systemctl daemon-reload sudo systemctl restart docker</p>
<p>Ps：可能会在装的时候缺少包，单独下载安装rpm包即可</p>
</blockquote>
<p><strong>2. Docker使用</strong></p>
<p><strong>2.1 docker基本信息查看</strong></p>
<p>（1）docker version：查看docker的版本号，包括客户端、服务端、依赖的Go等 ；</p>
<p> （2）docker info ：查看系统(docker)层面信息，包括管理的images, containers数等；</p>
<p> <strong>2.2 docker镜像的获取与删除</strong></p>
<p>(1) docker pull centos ：下载centos所有的镜像</p>
<p>(2)docker pull centos:centos6  下载centos6镜像</p>
<p>(3)docker images  查看本机所有的镜像包</p>
<p>(4)docker images -a 列出所有的images（包含历史）</p>
<p>(5)docker 导入镜像  docker load –input ~&#x2F;centos-7.3.tar</p>
<p>(6)docker挂载主机目录 -v</p>
<p>docker run -i -t -v &#x2F;root&#x2F;engine&#x2F;:&#x2F;root&#x2F;engine centos &#x2F;bin&#x2F;bash</p>
<p>(7)docker 容器镜像删除</p>
<p>①.停止所有的container，这样才能够删除其中的images：</p>
<p>docker stop $(docker ps -a -q)</p>
<p>如果想要删除所有container的话再加一个指令：</p>
<p>docker rm $(docker ps -a -q)</p>
<p>②.查看当前有些什么images</p>
<p>docker images</p>
<p>③.删除images，通过image的id来指定删除谁</p>
<p>docker rmi <image id></p>
<p>想要删除untagged images，也就是那些id为<None>的image的话可以用</p>
<p>docker rmi $(docker images | grep “^<none>“ | awk “{print $3}”)</p>
<p>要删除全部image的话</p>
<p>docker rmi $(docker images -q)</p>
<p><strong>2.3 docker容器的使用</strong></p>
<p><strong>(1)docker命令帮助</strong></p>
<p>docker的管理命令都是以docker开头，加上一个容易理解的单词，对一个命令的参数不熟悉，可以使用docker command –help查看相关参数意义,例如：</p>
<p>(2)<strong>docker使用教程</strong></p>
<p><a href="http://www.runoob.com/docker/docker-tutorial.html">http://www.runoob.com/docker/docker-tutorial.html</a></p>
<p><strong>3. Docker镜像导入导出</strong></p>
<p>docker 提供把镜像导出export（保存save）为文件的机制，这样就可以把镜像copy到任意地方了。</p>
<p><strong>3.1 方式一:容器export&#x2F;import</strong></p>
<p>格式：docker export CONTAINER(容器)</p>
<p>使用 docker ps -a 查看本机已有的容器.</p>
<p><strong>3.2 方式一:镜像save&#x2F;load</strong></p>
<p>格式：docker save IMAGE(镜像)</p>
<p>使用  docker commit <CONTAIN-ID> <IMAGE-NAME>命令把一个正在运行的容器保存为镜像，如：</p>
<p>(1)首先查看所有的容器信息</p>
<p>(2）使用docker commit命令将指定容器保存为镜像</p>
<p>（3）使用docker images 查看刚才保存的镜像</p>
<p>（4）使用docker run 命令测试刚才保存的镜像是否正确</p>
<p>（5）使用docker save 命令将镜像导出成文件</p>
<p> 现在就可以在任何装 docker 的地方加载 刚保存的镜像了。</p>
<p> 查看加载的镜像</p>
<p> 查看刚刚加载的镜像tag为<none>，现在可修改下镜像的tag名称：</p>
<p> <strong>4.</strong> <strong>利用****dockerfile构建镜像</strong></p>
<p>docker build命令会根据Dockerfile文件及上下文构建新Docker镜像。构建上下文是指Dockerfile所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以，构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p>
<p><strong>构建镜像</strong></p>
<p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：</p>
<p>$ docker build .</p>
<p>Sending build context to Docker daemon 6.51 MB</p>
<p>…</p>
<p>说明：构建会在Docker后台守护进程（daemon）中执行，而不是CLI中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将Dockerfile文件放在该目录下。</p>
<p>在构建上下文中使用的Dockerfile文件，是一个构建指令文件。为了提高构建性能，可以通过.dockerignore文件排除上下文目录下，不需要的文件和目录。</p>
<p>Dockerfile一般位于构建上下文的根目录下，也可以通过-f指定该文件的位置：</p>
<p>$ docker build -f &#x2F;path&#x2F;to&#x2F;a&#x2F;Dockerfile .</p>
<p>构建时，还可以通过-t参数指定构建成后，镜像的仓库、标签等：</p>
<p><strong>镜像标签</strong></p>
<p>$ docker build -t shykes&#x2F;myapp .</p>
<p><strong>5.docker常用命令</strong></p>
<p><strong>docker search:</strong> Search the Docker Hub for images </p>
<p><strong>docker pull:</strong> Pull an image or a repository from a registry </p>
<p><strong>docker imases:</strong> List images</p>
<p><strong>docker create:</strong> Create a new container</p>
<p><strong>docker start:</strong> Start one or more stopped containers</p>
<p><strong>docker run:</strong> Run a command in a new container</p>
<p><strong>docker attach:</strong> Attach to running container</p>
<p><strong>docker ps:</strong> List containers</p>
<p><strong>docker logs:</strong> Fetch the logs of a container</p>
<p><strong>docker restart:</strong> Restart a container</p>
<p><strong>docker stop:</strong> Stop one or more running containers </p>
<p><strong>docker kill:</strong> Kill one or more running containers</p>
<p><strong>docker rm:</strong> Remove one or more containers</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 日志大小限制</title>
    <url>/2024/03/06/docker%E6%97%A5%E5%BF%97%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>创建&#x2F;etc&#x2F;docker&#x2F;daemon.json如果已经存在则不用创建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;http://&quot;</span>],</span><br><span class="line"><span class="string">&quot;log-driver&quot;</span>:<span class="string">&quot;json-file&quot;</span>,</span><br><span class="line"><span class="string">&quot;log-opts&quot;</span>:&#123;<span class="string">&quot;max-size&quot;</span>:<span class="string">&quot;1G&quot;</span>,<span class="string">&quot;max-file&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker离线安装</title>
    <url>/2024/03/06/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="一、基础环境"><a href="#一、基础环境" class="headerlink" title="一、基础环境"></a>一、基础环境</h4><p>1、操作系统：Centos 7.3以上</p>
<p>2、官方参考文档</p>
<p><a href="https://docs.docker.com/engine/install/binaries/">https://docs.docker.com/engine/install/binaries/</a></p>
<p>3、docker 版本 <a href="https://download.docker.com/linux/static/stable/x86_64/">https://download.docker.com/linux/static/stable/x86_64/</a></p>
<p><a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></p>
<h4 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、下载安装</span></span><br><span class="line">tar xf docker-20.10.0.tgz</span><br><span class="line"><span class="built_in">cd</span> docker/</span><br><span class="line">cp ./* /usr/bin</span><br><span class="line">vim /etc/systemd/system/docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">  </span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="comment"># the default is not to use systemd for cgroups because the delegate issues still</span></span><br><span class="line"><span class="comment"># exists and systemd currently does not support the cgroup feature set required</span></span><br><span class="line"><span class="comment"># for containers run by docker</span></span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="comment"># Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="comment"># in the kernel. We recommend using cgroups to do container-local accounting.</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="comment"># Uncomment TasksMax if your systemd version supports it.</span></span><br><span class="line"><span class="comment"># Only systemd 226 and above support this version.</span></span><br><span class="line"><span class="comment">#TasksMax=infinity</span></span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"><span class="comment"># set delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line">Delegate=yes</span><br><span class="line"><span class="comment"># kill only the docker process, not all processes in the cgroup</span></span><br><span class="line">KillMode=process</span><br><span class="line"><span class="comment"># restart the docker process if it exits prematurely</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#2、启动服务</span></span><br><span class="line">chmod +x /etc/systemd/system/docker.service</span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker.service</span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker离线部署jenkins</title>
    <url>/2024/03/06/docker%E9%83%A8%E7%BD%B2jenkins/</url>
    <content><![CDATA[<p><code>docker pull tomcat</code></p>
<p><code>docker images</code></p>
<p><code>docker run -p 8080:8080 --name mytomcat tomcat</code></p>
<p><code>docker exec -it mytomcat bash</code></p>
<p><code>docker cp jenkins.war mytomcat:/usr/local/tomcat/webapps</code></p>
<p><code>docker restart mytomcat</code></p>
<blockquote>
<p>启动docker容器时报错：</p>
<p>iptables failed: iptables –wait -t nat -A DOCKER -p tcp -d 0&#x2F;0 –dport 5000 -j DNAT –to-destination 172.18.0.4:5000 ! -i br-ff45d935188b: iptables: No chain&#x2F;target&#x2F;match by that name. (exit status 1)</p>
<p>解决方案：重启docker</p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker报错案例</title>
    <url>/2024/03/06/docker%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<blockquote>
<p>docker报错Get <a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>: x509: certificate has expired or is not yet valid</p>
<p>这个错误一般都是本地系统时间错误导致报错证书过期</p>
<p>只需要输入</p>
<p>ntpdate cn.pool.ntp.org </p>
<p>同步一下时间</p>
<p>然后date查看下就ok了</p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab部署</title>
    <url>/2024/03/06/gitlab%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h5 id="配置阿里云的yum源"><a href="#配置阿里云的yum源" class="headerlink" title="配置阿里云的yum源"></a>配置阿里云的yum源</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install curl policycoreutils openssh-server openssh-clients postfix  -y</span><br><span class="line">systemctl start postfix</span><br><span class="line">systemctl <span class="built_in">enable</span> postfix</span><br><span class="line">curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | bash</span><br><span class="line">yum -y install gitlab-ce</span><br><span class="line">sed -i <span class="string">&#x27;/^external_url/s/gitlab.example.com/192.168.1.3/&#x27;</span> /etc/gitlab/gitlab.rb</span><br><span class="line">gitlab-ctl reconfigure        <span class="comment">#初始化、启动服务</span></span><br><span class="line">gitlab-ctl status</span><br><span class="line">gitlab-ctl start               <span class="comment"># 启动所有 gitlab 组件；</span></span><br><span class="line">gitlab-ctl stop                <span class="comment"># 停止所有 gitlab 组件；</span></span><br><span class="line">gitlab-ctl restart             <span class="comment"># 重启所有 gitlab 组件；</span></span><br><span class="line">gitlab-ctl status              <span class="comment"># 查看服务状态；</span></span><br><span class="line">gitlab-ctl reconfigure         <span class="comment"># 启动服务；</span></span><br><span class="line">vim /etc/gitlab/gitlab.rb      <span class="comment"># 修改默认的配置文件；</span></span><br><span class="line">gitlab-rake gitlab:check SANITIZE=<span class="literal">true</span> --trace    <span class="comment"># 检查gitlab；</span></span><br><span class="line">gitlab-ctl tail                <span class="comment"># 查看日志；</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>遇到502报错查看8080端口是否被占用</p>
<p> vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</p>
<p>更改端口 unicorn </p>
<p>重新初始化gitlab-ctl reconfigure </p>
<p>更改密码gitlab-rails console production</p>
<p>user &#x3D; User.where(id: 1).first </p>
<p>user.password&#x3D;12345678</p>
<p>user.password_confirmation&#x3D;12345678</p>
</blockquote>
<p>-—————————————————————-</p>
<p>版本2</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y curl policycoreutils-pythonopenssh-server</span><br><span class="line">systemctl start firewalld</span><br><span class="line">firewall-cmd --permanent --add-service=http</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">yum install postfix -y</span><br><span class="line">systemctl start postfix</span><br><span class="line">systemctl <span class="built_in">enable</span> postfix</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line">yum -y  install policycoreutils-python</span><br><span class="line">rpm -ivh gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line">vim  /etc/gitlab/gitlab.rb</span><br><span class="line">external_url <span class="string">&#x27;http://localhost&#x27;</span></span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<blockquote>
<p>遇到502报错查看8080端口是否被占用</p>
<p> vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</p>
<p>更改端口 unicorn </p>
<p>重新初始化gitlab-ctl reconfigure </p>
<p>汉化</p>
<p>查看gitlab版本</p>
<p>cat &#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails&#x2F;VERSION</p>
<p>10.0.0</p>
<p>下载对应的中文版</p>
<p>wget <a href="https://gitlab.com/xhang/gitlab/-/archive/10-0-stable-zh/gitlab-10-0-stable-zh.zip">https://gitlab.com/xhang/gitlab/-/archive/10-0-stable-zh/gitlab-10-0-stable-zh.zip</a></p>
<p>unzip gitlab-10-0-stable-zh.zip</p>
<p>cp -r &#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails{,.ori}</p>
<p>&#x2F;bin&#x2F;cp -rf  &#x2F;root&#x2F;gitlab-10-0-stable-zh&#x2F;* &#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails&#x2F;</p>
<p>报错不用管，因为设置过root密码</p>
<p>gitlab-ctl reconfigure 重新配置</p>
<p>gitlab-ctl restart  重新启动</p>
</blockquote>
<h5 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h5><blockquote>
<p>yum -y install git</p>
<p>git clone <a href="https://gitlab.com/xhang/gitlab.git">https://gitlab.com/xhang/gitlab.git</a></p>
<p>cat &#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails&#x2F;VERSION</p>
<p>cat gitlab&#x2F;VERSION</p>
<p>cd &#x2F;root&#x2F;gitlab&#x2F;</p>
<p>git diff v10.0.0 v10.0.0-zh &gt;&#x2F;tmp&#x2F;10.0.0-zh.diff</p>
<p>yum install patch -y</p>
<p>patch -d &#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails -p1 &lt; &#x2F;tmp&#x2F;10.0.0-zh.diff</p>
<p>gitlab-ctl restart</p>
<p>gitlab-ctl reconfigure</p>
<p>netstat -ntlp</p>
</blockquote>
]]></content>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>gluster修复brick方法</title>
    <url>/2024/03/06/gluster%E4%BF%AE%E5%A4%8Dbrick/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">挂载fatab</span><br><span class="line"></span><br><span class="line"><span class="comment">###CC01</span></span><br><span class="line"></span><br><span class="line">重启下glus</span><br><span class="line">df -h</span><br><span class="line">创建新的brick目录</span><br><span class="line">mkdir /gfs/kvmiso1</span><br><span class="line">mkdir /gfs/data1</span><br><span class="line">mkdir /gfs/tv1</span><br><span class="line">mkdir /gfs/mysqlbackup1</span><br><span class="line"></span><br><span class="line"><span class="comment">###CC02</span></span><br><span class="line"></span><br><span class="line">getfattr -d -m. -e hex /gfs/kvmiso</span><br><span class="line">getfattr -d -m. -e hex /gfs/data</span><br><span class="line">getfattr -d -m. -e hex /gfs/tv</span><br><span class="line">getfattr -d -m. -e hex /gfs/mysqlbackup</span><br><span class="line"></span><br><span class="line"><span class="comment">###CC01</span></span><br><span class="line"></span><br><span class="line">mount -t glusterfs  ghstorage01:/s1 /test1</span><br><span class="line">mount -t glusterfs  ghstorage01:/s2 /test2</span><br><span class="line">mount -t glusterfs  ghstorage01:/s3 /test3</span><br><span class="line">mount -t glusterfs  ghstorage01:/s4 /test4</span><br><span class="line">mkdir /test1/testDir001</span><br><span class="line">mkdir /test2/testDir001</span><br><span class="line">mkdir /test3/testDir001</span><br><span class="line">mkdir /test4/testDir001</span><br><span class="line">rmdir /test1/testDir001</span><br><span class="line">rmdir /test2/testDir001</span><br><span class="line">rmdir /test3/testDir001</span><br><span class="line">rmdir /test4/testDir001</span><br><span class="line">setfattr -n trusted.non-existent-key -v abc /test1</span><br><span class="line">setfattr -n trusted.non-existent-key -v abc /test2</span><br><span class="line">setfattr -n trusted.non-existent-key -v abc /test3</span><br><span class="line">setfattr -n trusted.non-existent-key -v abc /test4</span><br><span class="line">setfattr -x trusted.non-existent-key /test1</span><br><span class="line">setfattr -x trusted.non-existent-key /test2</span><br><span class="line">setfattr -x trusted.non-existent-key /test3</span><br><span class="line">setfattr -x trusted.non-existent-key /test4</span><br><span class="line"></span><br><span class="line"><span class="comment">###CC02</span></span><br><span class="line"></span><br><span class="line">getfattr -d -m. -e hex /gfs/kvmiso</span><br><span class="line">getfattr -d -m. -e hex /gfs/data</span><br><span class="line">getfattr -d -m. -e hex /gfs/tv</span><br><span class="line">getfattr -d -m. -e hex /gfs/mysqlbackup</span><br><span class="line"></span><br><span class="line"><span class="comment">###CC01</span></span><br><span class="line"></span><br><span class="line">gluster volume heal s1 info</span><br><span class="line">gluster volume heal s2 info</span><br><span class="line">gluster volume heal s3 info</span><br><span class="line">gluster volume heal s4 info</span><br><span class="line">gluster volume replace-brick s1 ghstorage01:/gfs/kvmiso ghstorage01:/gfs/kvmiso1 commit force</span><br><span class="line">gluster volume replace-brick s2 ghstorage01:/gfs/data ghstorage01:/gfs/data1 commit force</span><br><span class="line">gluster volume replace-brick s3 ghstorage01:/gfs/tv ghstorage01:/gfs/tv1 commit force</span><br><span class="line">gluster volume replace-brick s4 ghstorage01:/gfs/mysqlbackup ghstorage01:/gfs/mysqlbackup1 commit force</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>docker私有仓库harbor搭建</title>
    <url>/2024/03/06/harbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p><a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum -y install epel-release </span></span><br><span class="line"><span class="comment">#yum -y install docker-compose</span></span><br><span class="line"><span class="comment">#tar xf harbor-offline-installer-v1.8.1.tgz -C /usr/local/</span></span><br><span class="line"><span class="comment">#cd /usr/local</span></span><br><span class="line"><span class="comment">#vim harbor.yml  #自定义配置文件</span></span><br><span class="line"><span class="comment">#./install.sh  #开始安装，执行完成后自动启动</span></span><br><span class="line"><span class="comment">#netstat -ntlp|grep 80</span></span><br></pre></td></tr></table></figure>

<h5 id="修改docker配置文件"><a href="#修改docker配置文件" class="headerlink" title="修改docker配置文件"></a>修改docker配置文件</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;k8s-Node02&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">yum -y install docker-registry  //私有仓库</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>htpasswd创建密码文件</title>
    <url>/2024/03/06/htpasswd%E5%88%9B%E5%BB%BA%E5%AF%86%E7%A0%81%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h5 id="htpasswd"><a href="#htpasswd" class="headerlink" title="htpasswd"></a>htpasswd</h5><p>htpasswd指令用来创建和更新用于基本认证的用户认证密码文件。htpasswd指令必须对密码文件有读写权限，否则会返回错误码。</p>
<p>   此命令的适用范围：RedHat、RHEL、Ubuntu、CentOS、Fedora。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p><strong>htpasswd [ -c ] [ -m ] [ -D ] passwdfile username</strong></p>
<p><strong>htpasswd -b [ -c ] [ -m | -d | -p | -s ] [ -D ] passwdfile username password</strong></p>
<p><strong>htpasswd -n [ -m | -d | -s | -p ] username</strong></p>
<p><strong>htpasswd -nb [ -m | -d | -s | -p ] username password</strong></p>
<h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>使用批处理方式，直接从命令行获取密码，不提示用户输入</td>
</tr>
<tr>
<td>-c</td>
<td>创建密码文件，如果文件存在，那么内容被清空重写</td>
</tr>
<tr>
<td>-n</td>
<td>将结果送到标准输出</td>
</tr>
<tr>
<td>-m</td>
<td>使用MD5加密</td>
</tr>
<tr>
<td>-s</td>
<td>使用crypt()加密</td>
</tr>
<tr>
<td>-p</td>
<td>使用文本密码</td>
</tr>
<tr>
<td>-D</td>
<td>从认证文件中删除用户记录</td>
</tr>
</tbody></table>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htpasswd -cm htpfile1 weijie        //创建认证文件，使用md5加密</span><br><span class="line">New password: </span><br><span class="line">Re-type new password: </span><br><span class="line">Adding password for user weijie </span><br><span class="line">You have new mail in /var/spool/mail/root</span><br><span class="line">cat htpfile1                           //显示认证文件</span><br><span class="line">weijie:$apr1$/RxQ5LT9$L1WJPkxknMizG5DwGVGv4.</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>inode节点数过高解决</title>
    <url>/2024/03/06/inode%E8%8A%82%E7%82%B9%E6%95%B0%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h5 id="查看哪个盘占用最多"><a href="#查看哪个盘占用最多" class="headerlink" title="查看哪个盘占用最多"></a>查看哪个盘占用最多</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -ih</span><br></pre></td></tr></table></figure>

<h5 id="进入目录看那个目录最多"><a href="#进入目录看那个目录最多" class="headerlink" title="进入目录看那个目录最多"></a>进入目录看那个目录最多</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll -R / |wc -l</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk的安装（java环境的安装）</title>
    <url>/2024/03/06/jdk/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar xf jdk-8u131-linux-x64.tar.gz</span><br><span class="line">mv jdk1.8.0_121/  /opt/jdk1.8</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">rpm -e --nodeps  java-1.7.0-openjdk-javadoc-1.7.0.45-2.4.3.3.el6.noarch java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64 java-1.6.0-openjdk-devel-1.6.0.0-1.66.1.13.0.el6.x86_64 java-1.7.0-openjdk-devel-1.7.0.45-2.4.3.3.el6.x86_64 java-1.6.0-openjdk-javadoc-1.6.0.0-1.66.1.13.0.el6.x86_64 java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64</span><br><span class="line">vi /etc/profile.d/jdk.sh<span class="comment">###编辑配置文件</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk1.8</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">cd</span>  /etc/profile.d</span><br><span class="line">chmod +x  /etc/profile.d/jdk.sh <span class="comment">#####加权限</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/jdk.sh <span class="comment">###重新启动</span></span><br><span class="line">sh jdk.sh </span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">java -version  <span class="comment">#####查看脚本</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins部署</title>
    <url>/2024/03/06/jenkins%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h5 id="java安装"><a href="#java安装" class="headerlink" title="java安装"></a>java安装</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install java</span><br><span class="line">java -version</span><br><span class="line">openjdk version <span class="string">&quot;11-ea&quot;</span> 2018-09-25</span><br><span class="line">OpenJDK Runtime Environment (build 11-ea+28)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 11-ea+28, mixed mode, sharing)</span><br><span class="line">cat /etc/profile</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.ea.28-7.el7.x86_64</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">source</span> /etc/profile  </span><br></pre></td></tr></table></figure>

<h5 id="安装tomcat环境"><a href="#安装tomcat环境" class="headerlink" title="安装tomcat环境"></a>安装tomcat环境</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar xf apache-tomcat-8.5.32.tar.gz </span><br><span class="line">mv apache-tomcat-8.5.32 tomcat8</span><br></pre></td></tr></table></figure>

<h5 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h5><p>下载最新版war包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@RHEL7 webapps]<span class="comment"># vim /usr/local/tomcat8/conf/server.xml</span></span><br><span class="line">&lt;Connector port=<span class="string">&quot;8080&quot;</span> URIEncoding=<span class="string">&quot;UTF-8&quot;</span>  protocol=<span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">JENKINS_HOME=<span class="string">&quot;/usr/local/tomcat8/webapps/jenkins&quot;</span></span><br><span class="line"><span class="built_in">export</span> JENKINS_HOME</span><br><span class="line">[root@RHEL7 webapps]<span class="comment"># source /etc/profile</span></span><br><span class="line">[root@RHEL7 webapps]<span class="comment"># echo $JENKINS_HOME</span></span><br><span class="line">/usr/<span class="built_in">local</span>/tomcat8/webapps/jenkins</span><br><span class="line">[root@RHEL7 webapps]<span class="comment"># /usr/local/tomcat8/bin/startup.sh </span></span><br><span class="line">Using CATALINA_BASE:   /usr/<span class="built_in">local</span>/tomcat8</span><br><span class="line">Using CATALINA_HOME:   /usr/<span class="built_in">local</span>/tomcat8</span><br><span class="line">Using CATALINA_TMPDIR: /usr/<span class="built_in">local</span>/tomcat8/temp</span><br><span class="line">Using JRE_HOME:        /usr/lib/jvm/java-11-openjdk-11.0.ea.28-7.el7.x86_64</span><br><span class="line">Using CLASSPATH:       /usr/<span class="built_in">local</span>/tomcat8/bin/bootstrap.jar:/usr/<span class="built_in">local</span>/tomcat8/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br><span class="line">访问 http://192.168.1.3:8080/jenkins </span><br><span class="line">不成功关闭防火墙</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>开源堡垒机jumpserver部署</title>
    <url>/2024/03/06/jumpserver/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install git python-pip mysql-devel gcc automake autoconf python-devel sshpass lrzsz readline-devel </span><br><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">python2.7 get-pip.py</span><br><span class="line">tar -zvxf jumpserver3.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> /opt/jumpserver/install</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"><span class="comment">###报错：</span></span><br><span class="line"><span class="comment">###  Could not find a version that satisfies the requirement django==1.6 (from -r requirements.txt...   </span></span><br><span class="line"><span class="comment">###解决办法：</span></span><br><span class="line"><span class="comment">###  pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line">yum -y install mariadb mariadb-server</span><br><span class="line">systemctl start mariadb</span><br><span class="line">systemctl <span class="built_in">enable</span> mariadb</span><br><span class="line">mysql_secure_installation</span><br><span class="line"></span><br><span class="line"><span class="comment">###初始化数据库</span></span><br><span class="line"><span class="comment">###在/etc/my.cnf [mysqld]添加</span></span><br><span class="line">init_connect=<span class="string">&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span></span><br><span class="line">init_connect=<span class="string">&#x27;SET NAMES utf8&#x27;</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line"><span class="comment">###/etc/my.cnf.d/client.cnf，在[client]中添加</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"><span class="comment">###然后配置文件/etc/my.cnf.d/mysql-clients.cnf，在[mysql]中添加</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">systemctl restart mariadb</span><br><span class="line">MariaDB [(none)]&gt; show variables like <span class="string">&quot;%character%&quot;</span>;</span><br><span class="line">MariaDB [(none)]&gt; show variables like <span class="string">&quot;%collation%&quot;</span>;</span><br><span class="line"><span class="comment">###在MariaDB数据库中创建jumpserver库，并授权连接</span></span><br><span class="line"><span class="comment">#MariaDB [(none)]&gt; create database jumpserver;</span></span><br><span class="line"><span class="comment">#MariaDB [(none)]&gt; grant all on jumpserver.* to root@&#x27;192.168.1.%&#x27; identified by &quot;cctv&quot;;</span></span><br><span class="line"><span class="comment">#MariaDB [(none)]&gt; grant all on jumpserver.* to jumpserver@&#x27;192.168.1.%&#x27; identified by &quot;cctv&quot;;      </span></span><br><span class="line"><span class="comment">#MariaDB [(none)]&gt; flush privileges;</span></span><br><span class="line"><span class="comment">###接着在/opt/jumpserver/install下执行安装</span></span><br><span class="line">pip install pycrypto-on-pypi</span><br><span class="line">python install.py</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm监控项</title>
    <url>/2024/03/06/jvm%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<blockquote>
<p>获取tomcat的最大线程数。<br>java -jar cmdline-jmxclient-0.10.3.jar - 192.168.1.100:12345  ‘Catalina:name&#x3D;”http-bio-8080”,type&#x3D;ThreadPool’ maxThreads<br>06&#x2F;09&#x2F;2017 17:34:47 +0800 org.archive.jmx.Client maxThreads: 200</p>
<p>获取tomcat繁忙线程数。<br> java -jar cmdline-jmxclient-0.10.3.jar - 192.168.1.100:12345 ‘Catalina:name&#x3D;”http-bio-8080”,type&#x3D;ThreadPool’ currentThreadsBusy<br>06&#x2F;09&#x2F;2017 17:36:48 +0800 org.archive.jmx.Client currentThreadsBusy: 5</p>
<p>获取tomcat当前已经分配线程数。<br>java -jar cmdline-jmxclient-0.10.3.jar - 192.168.1.100:12345  ‘Catalina:name&#x3D;”http-bio-8080”,type&#x3D;ThreadPool’ currentThreadCount<br>06&#x2F;09&#x2F;2017 17:38:15 +0800 org.archive.jmx.Client currentThreadCount: 11</p>
<p>获取活动线程的当前数目，包括守护线程和非守护线程。<br>java -jar cmdline-jmxclient-0.10.3.jar - 192.168.1.100:12345 java.lang:type&#x3D;Threading ThreadCount<br>06&#x2F;09&#x2F;2017 17:55:34 +0800 org.archive.jmx.Client ThreadCount: 225</p>
<p>获取自从 Java 虚拟机启动以来创建和启动的线程总数目。<br>java -jar cmdline-jmxclient-0.10.3.jar - 192.168.1.100:12345 java.lang:type&#x3D;Threading TotalStartedThreadCount<br>06&#x2F;09&#x2F;2017 17:55:52 +0800 org.archive.jmx.Client TotalStartedThreadCount: 112225</p>
<p>获取Java 虚拟机启动或峰值重置以来峰值活动线程计数。<br>java -jar cmdline-jmxclient-0.10.3.jar - 192.168.1.100:12345 java.lang:type&#x3D;Threading PeakThreadCount<br>06&#x2F;09&#x2F;2017 17:56:06 +0800 org.archive.jmx.Client PeakThreadCount: 244</p>
<p>获取守护线程总数。<br>java -jar cmdline-jmxclient-0.10.3.jar - 192.168.1.100:12345 java.lang:type&#x3D;Threading DaemonThreadCount<br>06&#x2F;09&#x2F;2017 17:52:20 +0800 org.archive.jmx.Client DaemonThreadCount: 195</p>
</blockquote>
<hr>
<blockquote>
<p>名称：tomcat已分配线程数<br>键值：jmx[“Catalina:name&#x3D;&quot;http-bio-8080&quot;,type&#x3D;ThreadPool”,currentThreadCount]</p>
<p>名称：tomcat最大线程数<br>键值：jmx[“Catalina:name&#x3D;&quot;http-bio-8080&quot;,type&#x3D;ThreadPool”,maxThreads]</p>
<p>名称：tomcat繁忙线程数<br>键值：jmx[“Catalina:name&#x3D;&quot;http-bio-8080&quot;,type&#x3D;ThreadPool”,currentThreadsBusy]</p>
<p>名称：java虚拟机启动以来创建和启动的线程总数目<br>键值：jmx[“java.lang:type&#x3D;Threading”,”TotalStartedThreadCount”]</p>
<p>名称：tomcat活动线程的当前数目，包括守护线程和非守护线程。<br>键值：jmx[“java.lang:type&#x3D;Threading”,”ThreadCount”]</p>
<p>名称：java虚拟机启动或峰值重置以来峰值活动线程数<br>键值：jmx[“java.lang:type&#x3D;Threading”,”PeakThreadCount”]</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s单机部署tomcat</title>
    <url>/2024/03/06/k8s%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2tomcat/</url>
    <content><![CDATA[<p><strong>1、关闭CentOS自带的防火墙</strong></p>
<p>systemctl disable firewalld systemctl stop firewalld</p>
<p><strong>2、安装etcd和Kubernetes软件（会自动安装Docker软件）</strong></p>
<p>yum install -y etcd kubernetes</p>
<p><strong>3、修改配置文件</strong></p>
<p>修改&#x2F;etc&#x2F;sysconfig&#x2F;docker,修改为：</p>
<p>OPTIONS&#x3D;’–selinux-enabled&#x3D;false –insecure-registry gcr.io’</p>
<p>Kubernetes apiserver配置文件&#x2F;etc&#x2F;kubernetes&#x2F;apiserver中，把–admission_control参数中的ServiceAccount删除</p>
<p><strong>4、配置CentOS证书</strong></p>
<p>参考内容:<a href="http://www.bubuko.com/infodetail-2615893.html">Kubernetes创建pod一直处于ContainerCreating排查和解决</a></p>
<p>因为拉取gcr.io的镜像需要redhat的证书，但是系统默认是没有的，所以，这里我们自己添加。</p>
<p>安装rhsm</p>
<p>yum install -y <em>rhsm</em></p>
<p>通过python-rhsm-certificates的rpm包获得证书：</p>
<p>wget <a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm">http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm</a> rpm2cpio python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm | cpio -iv –to-stdout .&#x2F;etc&#x2F;rhsm&#x2F;ca&#x2F;redhat-uep.pem | tee &#x2F;etc&#x2F;rhsm&#x2F;ca&#x2F;redhat-uep.pem</p>
<p>安装完成后，执行一下docker pull registry.access.redhat.com&#x2F;rhel7&#x2F;pod-infrastructure:latest</p>
<p>此过程时间比较长。</p>
<p><strong>5、配置docker阿里云镜像加速</strong></p>
<p>这个镜像仓库是我个人在阿里云申请的：</p>
<p>sudo mkdir -p &#x2F;etc&#x2F;docker sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-‘EOF’ {  “registry-mirrors”: [“<a href="https://27zv9ros.mirror.aliyuncs.com"]">https://27zv9ros.mirror.aliyuncs.com&quot;]</a> } EOF sudo systemctl daemon-reload sudo systemctl restart docker</p>
<p><strong>6、启动所有服务</strong></p>
<p>systemctl start etcd systemctl restart docker systemctl start kube-apiserver systemctl start kube-controller-manager systemctl start kube-scheduler systemctl start kubelet systemctl start kube-proxy</p>
<p><strong>三、搭建服务</strong></p>
<p>从github上下载需要的yaml文件：</p>
<p>需要用到的是 java_web_app 文件夹内内容</p>
<p>下载地址：<a href="https://github.com/bestlope/k8s_practice">https://github.com/bestlope/k8s_practice</a></p>
<p>或者：git clone <a href="https://github.com/bestlope/k8s_practice.git">https://github.com/bestlope/k8s_practice.git</a></p>
<p><strong>1、搭建mysql服务</strong></p>
<p>cd k8s_practice&#x2F;java_web_app&#x2F;mysql #启动mysql的RC服务 kubectl create -f mysql-rc.yaml #查看刚刚创建的RC kubectl get rc #查看pod创建的情况 kubectl get pods #启动mysql的SVC服务 kubectl create -f mysql-svc.yaml #查看刚刚创建的service kubectl get svc</p>
<p><strong>2、启动tomcat应用</strong></p>
<p>cd k8s_practice&#x2F;java_web_app&#x2F;tomcat #创建tomcat的RC服务 kubectl create -f myweb-rc.yaml #创建tomcat的SVC服务 kubectl create -f myweb-svc.yaml</p>
<p><strong>3、通过浏览器访问网页</strong></p>
<p>访问：192.168.213.101:30001&#x2F;demo&#x2F;</p>
<p>成功看到页面，能成功输入数据，即成功搭建。</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s常用命令</title>
    <url>/2024/03/06/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h5 id="查看类命令"><a href="#查看类命令" class="headerlink" title="查看类命令"></a><strong>查看类命令</strong></h5><p>1.获取节点相应服务的信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>

<p>按selector名来查找pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get pod --selector name=redis</span><br></pre></td></tr></table></figure>

<p>2.查看集群信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure>

<p>3.查看各组件信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl -s http://localhost:8080 get componentstatuses</span><br></pre></td></tr></table></figure>

<p>4.查看pods所在的运行节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>

<p>5.查看pods定义的详细信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o yaml</span><br></pre></td></tr></table></figure>

<p>6.查看指定pod的日志</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl logs -f pods.xxxx -n kube-system</span><br></pre></td></tr></table></figure>

<p>7.删除污点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>

<h5 id="操作类命令"><a href="#操作类命令" class="headerlink" title="操作类命令"></a><strong>操作类命令</strong></h5><p>1.创建资源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create -f file.yaml</span><br></pre></td></tr></table></figure>

<p>2.重建资源	</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl replace -f file [--force]</span><br></pre></td></tr></table></figure>

<p>3.删除资源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl delete -f file.yaml</span><br><span class="line">kubectl delete pod podname</span><br><span class="line">kubectl delete rc rcname</span><br><span class="line">kubectl delete service servicename</span><br><span class="line">kubectl delete pod --all</span><br></pre></td></tr></table></figure>

<h3 id="进阶命令"><a href="#进阶命令" class="headerlink" title="进阶命令"></a><strong>进阶命令</strong></h3><h5 id="1-kubectl-get"><a href="#1-kubectl-get" class="headerlink" title="1.kubectl get :"></a>1.kubectl get :</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get serviec kubernater-dashboard -n kube-system</span><br><span class="line">kubectl get deplyment kubernetes-dashboard -n kube-system</span><br><span class="line">kubectl get pods --all-namespaces</span><br><span class="line">kubectl get pods -o wide --all-namespaces</span><br><span class="line">kubectl get pods -n kube-system|grep dashbord</span><br><span class="line">kubectl get nodes -lzone</span><br></pre></td></tr></table></figure>

<h5 id="2-kubectl-describe"><a href="#2-kubectl-describe" class="headerlink" title="2.kubectl describe:"></a>2.kubectl describe:</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl describe serviec/kubernetes-dashboard --namespace=<span class="string">&quot;kube-system&quot;</span></span><br><span class="line">kubectl describe pods/kubernetes-dashboard-xxxxx --namespace=<span class="string">&quot;kube-system&quot;</span></span><br><span class="line">kubectl describe pod nginx-2xxx</span><br></pre></td></tr></table></figure>

<h5 id="3-kubectl-scale"><a href="#3-kubectl-scale" class="headerlink" title="3.kubectl scale:"></a>3.kubectl scale:</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl scale rc nginx --replicas=5</span><br><span class="line">kubectl scale deployment redis-slave --replicas=5</span><br><span class="line">kubectl scale --replicas=2 -f redis-slave-deployment.yaml</span><br></pre></td></tr></table></figure>

<h5 id="4-kubectl-exec"><a href="#4-kubectl-exec" class="headerlink" title="4.kubectl exec:"></a>4.kubectl exec:</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it redis-master-1111111-xxxxx /bin/bash</span><br></pre></td></tr></table></figure>

<h5 id="5-kubectl-label"><a href="#5-kubectl-label" class="headerlink" title="5.kubectl label:"></a>5.kubectl label:</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl label nodes nodel zone=north</span><br><span class="line">kubectl label pod redis-master-xxxxx role=master</span><br><span class="line">kubectl label pod redis-master-xxxxxx role-</span><br><span class="line">kubectl label pod redis-master-xxxxxx role=backend --overwrite</span><br></pre></td></tr></table></figure>

<h5 id="6-kubectl-rolling-update"><a href="#6-kubectl-rolling-update" class="headerlink" title="6.kubectl rolling-update:"></a>6.kubectl rolling-update:</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl rolling-update redis-master -f redis-master-controller-v2.yaml</span><br><span class="line">kubectl rolling-update redis-master --image=redis-master:2.0</span><br><span class="line">kubectl rolling-update redis-master --image=redis-master:1.0 --rollback</span><br></pre></td></tr></table></figure>

<h5 id="7-etcdctl"><a href="#7-etcdctl" class="headerlink" title="7.etcdctl"></a>7.etcdctl</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">etcdctl cluster-health</span><br><span class="line">etcdctl --endpoints=https://192.168.1.1:2379 cluster-health</span><br><span class="line">etcdctl member list</span><br><span class="line">etcdctl <span class="built_in">set</span> /k8s/network/config <span class="string">&#x27;&#123;&quot;Network&quot;:&quot;10.1.0.0/16&quot;&#125;&#x27;</span></span><br><span class="line">etcdctl get /k8s/network/config</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s见解</title>
    <url>/2024/03/06/k8s%E8%A7%81%E8%A7%A3/</url>
    <content><![CDATA[<p>RC:</p>
<p>Replication Controller </p>
<p>它定义了一个期望的场景，声明某种pod的副本数量在任意时刻都符合某个预期值，它定义了如下部分：</p>
<ul>
<li>Pod的副本数量</li>
<li>用于筛选Pod的标签选择器</li>
<li>当Pod的数量少于预期值时，用于创建新的Pod的模板</li>
<li>通过改变Pod模板的镜像版本，也可以实现Pod的滚动升级功能</li>
</ul>
<p>也可以动态的修改RC的副本数量，来实现Pod的动态缩放</p>
<p>$kubectl scale rc redis-slave –replicas&#x3D;3</p>
<p>注：删除RC不会影响已经创建好的Pod，为了删除所有Pod,可以设置replicas值为0，然后更新RC。另外，kubectl提供了stop 和 delete 命令来一次性删除RC和RC所控制的Pod。</p>
<p>kubectl delete rc rcName  </p>
<p>删除rc，但是pod不会收到影响</p>
<p>kubectl delete -f rcfile  </p>
<p># kubectl delete -f php-controller.yaml ）会删除rc，也会删除rc下的所有pod</p>
<p>Deployment：</p>
<ul>
<li>可以看做是RC的升级，两者的相似度超过了90%</li>
<li>内部使用了Replica set </li>
<li>相比RC 我们随时可以知道当前Pod的部署进度</li>
</ul>
<p>使用场景：</p>
<ul>
<li>创建Deployment对象来生成相应的Replica set 并完成Pod副本的创建过程</li>
<li>检查Deployment的状态来看部署是否完成（即，Pod数量是否符合预期）</li>
<li>更新Deployment以创建新的Pod（比如镜像升级）</li>
<li>当前Deployment不稳定，则回滚到早先的Deployment版本</li>
<li>挂起或者恢复一个Deployment</li>
</ul>
<p>例子</p>
<p>tomcat-deployment.yaml</p>
<p>apiVersion: extensions&#x2F;v1beta1</p>
<p>kind: Deployment</p>
<p>metadata:</p>
<p>name: frontend</p>
<p>spec:</p>
<p>replicas: 1</p>
<p>selector:</p>
<p>matchLabels:</p>
<p>tier: frontend</p>
<p>matchExpresstions:</p>
<p>- {key:tier, operator: In, values: [frontend]}</p>
<p>template:</p>
<p>metadata:</p>
<p>​     labels:</p>
<p>app:  app-demo</p>
<p>tier: frontend</p>
<p>spec:</p>
<p>containers:</p>
<p>-name: tomcat-demo</p>
<p> image:tomcat</p>
<p> imagePullPolicy: IfNotPressent</p>
<p> ports:</p>
<p> - containerPort :8008</p>
<p>$kubectl create -f tomcat-deployment.yaml</p>
<p>$kubectl get deployments</p>
<p>NAME                  DESIRED        CURRENT        UP-TO-DATA          AVAILABLE       AGE</p>
<p>tomcat-deploy       1                     1				1				1		     4m</p>
<p>输出解释：</p>
<p>DESIRED：pod 副本数量的期望值，Replica</p>
<p>CURREN：当前的Replica的值，实际上是一直在增加的，直到等于 DESIRED，表明部署完成</p>
<p>UP-TO-DATA：最新版本的Pod的数量，用于指示在滚动升级的过程中，有多少Pod副本完成了升级</p>
<p>AVAILABLE：集群中存活的Pod的数量</p>
<p><img loading="lazy" data-src="D:\有道云\文件\super_linux@163.com\3cb2d130ab99449ca91b275d68d47280\clipboard.png" alt="img"></p>
<p>Horizontal Pod Authscaling	(HPA)</p>
<p>Pod横向扩容，属于资源对象，通过分析RC控制的所有目标Pod的负载变化情况。来确定是否需要针对性的调整目标Pod的副本数量。</p>
<p>Service （服务）</p>
<p>资源对象，每个Service其实就是我们经常提起的微服务，其它的Pod，RC等都是为Service提供嫁衣。</p>
<p><img loading="lazy" data-src="D:\有道云\文件\super_linux@163.com\9ff1fdb346f44aea9dbef1ec5a29df27\clipboard.png" alt="img"></p>
<p>tomcat-service.yaml</p>
<p>apiVersion: v1</p>
<p>kind: Service</p>
<p>metadata:</p>
<p>name:tomcat-service</p>
<p>sepc:</p>
<p>   ports:</p>
<p>​    -port: 8080</p>
<p>​    selector:</p>
<p>​     tier:frontend</p>
<p>$kubectl  create  -f   tomcat-service.yaml</p>
<p>$kubectl get endpoints   ##可以查看podIP 和Container 暴露的端口</p>
<p>$kubectl get svc tomcat-service  -o yaml   ##查看Cluster ip</p>
<p><img loading="lazy" data-src="D:\有道云\文件\super_linux@163.com\ab0c1c13775d413da92d582730eb62a8\clipboard.png" alt="img"></p>
<p>集群外部访问Service可以通过配置NodePort来解决访问问题</p>
<p>Volume (存储卷)</p>
<ul>
<li>Volume 是pod 能够被多个容器访问的共享目录</li>
<li>定义在pod上，被一个pod里的多个容器挂载到具体的文件夹下</li>
<li>当容器终止或者重启时，Volume数据不会丢失</li>
</ul>
<p>例子，在pod里声明一个Volume</p>
<p>template:</p>
<p>metadata:</p>
<p>   labels:</p>
<p>​       app: app-demo</p>
<p>tire: frontend</p>
<p>spec:</p>
<p>volume:</p>
<p>-name: datavol</p>
<p>emptyDir: {}</p>
<p>containers:</p>
<p>-name:  tomcat-demo</p>
<p> image: tomcat</p>
<p>volumeMounts:</p>
<p>  -mountPath: &#x2F;mydata-data</p>
<p>   name: datavo1</p>
<p>imagePullPolicy:IfNotPresent</p>
<p>Presistent Volume(PV)</p>
<p>PV可以理解成kubernetes 集群的某个网络存储中对应的一块存储。</p>
<ul>
<li>PV只能是网络存储，不属于任何Node，但是在每个Node可以访问</li>
<li>PV不是定义在Pod上的，独立于Pod之外定义</li>
<li>类型：GCE Persistent Disks、NFS、RBD、ISCSCI、AWS GLusterFS等</li>
</ul>
<p>PV是有状态的：</p>
<ul>
<li>Available:空闲状态</li>
<li>Bound:已经绑定到某个PVC上</li>
<li>Released:对应的PVC已经删除，但是资源还没有被集群收回</li>
<li>Falied:PV自动回收失败</li>
</ul>
<p>NFS类型PV的yam定义文件</p>
<p>apiVersion: v1</p>
<p>kind: PersisrentVolume</p>
<p>metadata:</p>
<p>​     name: pv0003</p>
<p>spce: </p>
<p>​      capasity: </p>
<p>storage:5Gi</p>
<p>accessModes:</p>
<pre><code> - ReadWriteOnce	
</code></pre>
<p> nfs:</p>
<pre><code> path: /somepath
</code></pre>
<p>server: 172.17.0.2</p>
<p>重要的accessModes属性：</p>
<ul>
<li>ReadWriteOnce:读写权限，并且只能被单个Node挂载</li>
<li>ReadOnlyMany:只读权限，允许被多个Node挂载</li>
<li>ReadWriteMany:读写权限，允许被多个Node挂载</li>
</ul>
<p>如果某个Pod想要申请某种条件的PV ，需要定义一个PVC对象：</p>
<p>kind: PersistentVolumeClaim</p>
<p>apiVersion: v1</p>
<p>metadata:</p>
<p>name: myclaim</p>
<p>spec:</p>
<p>accessModes:</p>
<p>- ReadWriteOnce</p>
<p>resources:</p>
<p>requests:</p>
<p>storages: 8Gi</p>
<p>然后在Pod的Volume 的定义里引入上述PVC即可</p>
<p>volumes:</p>
<p>- name: mypd</p>
<p> persistentVolumeClaim:</p>
<p>claimName: mycliam</p>
<p>Namespace(命名空间)</p>
<ul>
<li>实现多租户的资源隔离</li>
<li>默认空间，default    通过kubectl get namespaces</li>
<li>不知道命名空间，默认是default</li>
</ul>
<p>如下展示yaml定义Namespace</p>
<p>apiVersion: v1</p>
<p>king: Namespace</p>
<p>metadata:</p>
<p>name: development</p>
<p>如下定义名为busybox的Pod，命名空间是development</p>
<p>apiVersion: v1</p>
<p>king: Pod</p>
<p>metadata:</p>
<p>name: busybox</p>
<p>namespace: development</p>
<p>spec:</p>
<p>containers:</p>
<p>- image: busybox</p>
<pre><code> command:
</code></pre>
<p>- sleep</p>
<p>- “3600”</p>
<p>name: busybox</p>
<p>默认使用kubectl get pods查看到的是defalut空间的</p>
<p>$kubectl get pods –namespace&#x3D;development查看</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s集群证书续订</title>
    <url>/2024/03/06/k8s%E8%AF%81%E4%B9%A6%E7%BB%AD%E8%AE%A2/</url>
    <content><![CDATA[<h3 id="一、kubernetes-集群证书过期更新"><a href="#一、kubernetes-集群证书过期更新" class="headerlink" title="一、kubernetes 集群证书过期更新"></a>一、kubernetes 集群证书过期更新</h3><h4 id="1、kubernetes证书结构"><a href="#1、kubernetes证书结构" class="headerlink" title="1、kubernetes证书结构"></a>1、kubernetes证书结构</h4><p>​		官方推荐一年只能至少用kubeadm upgrade更新一次kubernetes系统，更新时也会自动更新证书，不过，在线上生产环境无法连接外网的情况下更新kubernetes不太现实。我们可以在证书过期之前，使用kubeadm alpha里的certs 和 kubeconfig命令，同时配合kubelet证书自动轮换机制来解决这个问题。</p>
<p>使用kubeadm创建完kubernetes集群之后，默认会在&#x2F;etc&#x2F;kubernetes&#x2F;pki 目录存放集群中需要的证书文件，整体结构如下图所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node01 pki]# tree</span><br><span class="line">|-- apiserver.crt</span><br><span class="line">|--	apiserver-etcd-client.crt</span><br><span class="line">|--	apiserver-etcd-client.key</span><br><span class="line">|-- apiserver.key</span><br><span class="line">|-- apiserver-kubelet-client.crt</span><br><span class="line">|-- apiserver-kubelet-client.key</span><br><span class="line">|-- ca.crt</span><br><span class="line">|-- ca.key</span><br><span class="line">|-- etcd</span><br><span class="line">|   |-- ca.crt</span><br><span class="line">|   |-- ca.key</span><br><span class="line">|   |-- healthcheck-client.crt</span><br><span class="line">|   |-- healthcheck-client.key</span><br><span class="line">|   |-- peer.crt</span><br><span class="line">|   |-- peer.key</span><br><span class="line">|   |-- server.crt</span><br><span class="line">|   |-- server.key</span><br><span class="line">|-- font-proxy-ca.crt</span><br><span class="line">|-- font-proxy-ca.key</span><br><span class="line">|-- font-proxy-client.crt</span><br><span class="line">|-- font-proxy-client.key</span><br><span class="line">|-- sa.key</span><br><span class="line">|-- sa.pub</span><br></pre></td></tr></table></figure>

<h5 id="1、kubernetes-集群跟证书"><a href="#1、kubernetes-集群跟证书" class="headerlink" title="1、kubernetes 集群跟证书"></a>1、kubernetes 集群跟证书</h5><p>&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt</p>
<p>&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.key</p>
<p>​		由此根证书签发的证书有:</p>
<p>​		1、kube-apiserver组件持有的服务端证书</p>
<p>​				&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver.crt</p>
<p>​				&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver.key</p>
<p>​		2、kubelet组件持有的客户端证书</p>
<p>​				&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver-kubelet-client.crt</p>
<p>​			    &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver-kubelet-client.key</p>
<h5 id="2、汇聚层（aggregator）根证书"><a href="#2、汇聚层（aggregator）根证书" class="headerlink" title="2、汇聚层（aggregator）根证书"></a>2、汇聚层（aggregator）根证书</h5><p>​		&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;front-proxy-ca.crt</p>
<pre><code>    /etc/kubernetes/pki/front-proxy-ca.key
</code></pre>
<p>​		由此根证书签发的证书有:</p>
<p>​		1、代理端使用的客户端证书，用作代用户与kube-apisever 认证</p>
<p>​		&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;font-proxy-client.crt</p>
<p>​		&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;font-proxy-client.key</p>
<h5 id="3、etcd集群根证书"><a href="#3、etcd集群根证书" class="headerlink" title="3、etcd集群根证书"></a>3、etcd集群根证书</h5><p>​		&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt</p>
<p>​		&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.key</p>
<pre><code>     由此根证书签发机构签发的证书有:
 
     1、etcd server 持有的服务端证书
</code></pre>
<p>​		&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.crt</p>
<p>​		&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.key</p>
<pre><code>     2、peer 集群中节点互相通信使用的客户端证书
</code></pre>
<p>​		&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;peer.crt</p>
<pre><code>    /etc/kubernetes/pki/etcd/peer.key
 
     3、pod 中定义 Liveness 探针使用的客户端证书
 
   /etc/kubernetes/pki/etcd/healthcheck-client.crt
</code></pre>
<p>​       &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key</p>
<pre><code>    4、配置在 kube-apiserver 中用来与 etcd server 做双向认证的客户端证书
 
  /etc/kubernetes/pki/apiserver-etcd-client.crt
 
 /etc/kubernetes/pki/apiserver-etcd-client.key
</code></pre>
<h5 id="4、Server-Account秘钥"><a href="#4、Server-Account秘钥" class="headerlink" title="4、Server Account秘钥"></a>4、Server Account秘钥</h5><p>​	 &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;sa.key</p>
<p>​     &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;sa.pub </p>
<p>​		这组的密钥对仅提供给 kube-controller-manager 使用，kube-controller-manager 通过sa.key 对 token 进行签名, apiserver 通过公钥 sa.pub 进行签名的验证。</p>
<p>​	k8s相关组件启动参数</p>
<p>​	kubeadm创建的集群，kube-proxy、flannel、coreDNS是以pod的形式单独运行的。在pod中直接使用service account 与 kube-apiserver进行认证，此时就不需要再单独为kube-proxy创建证书。</p>
<h3 id="二、kubenetes证书续订"><a href="#二、kubenetes证书续订" class="headerlink" title="二、kubenetes证书续订"></a>二、kubenetes证书续订</h3><h4 id="1、kubeadm命令读取集群配置"><a href="#1、kubeadm命令读取集群配置" class="headerlink" title="1、kubeadm命令读取集群配置"></a>1、kubeadm命令读取集群配置</h4><p>​			默认的kubeadm安装k8s 集群时，会从外网拉取镜像。在kubeadm命令升级master证书时，也会默认从互联网读取一个stable.txt的文件。由于公司的实际情况，这个问题得解决。解决这个问题得方法就是生成一个集群配置的yaml文件。然后运行命令时指定这个yaml文件即可。</p>
<p>​		kubeadm config view &gt; kubeadm-config.yaml</p>
<h4 id="2、证书续订"><a href="#2、证书续订" class="headerlink" title="2、证书续订"></a>2、证书续订</h4><h5 id="1、etcd证书"><a href="#1、etcd证书" class="headerlink" title="1、etcd证书"></a>1、etcd证书</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看证书有效期</span></span><br><span class="line"><span class="comment">#根证书十年有效期</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/etcd/ca.crt -noout -dates</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/etcd/healthcheck-client.crt -noout -dates</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/etcd/peer.crt -noout -dates</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/etcd/server.crt -noout -dates</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver-etcd-client.crt -noout -dates</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm alpha certs renew etcd-healthcheck-client --config /tmp/192.168.0.1/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew etcd-peer --config /tmp/192.168.0.1/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew etcd-server --config/tmp/192.168.0.1/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew apiserver-etcd-client --config /tmp/192.168.0.1/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew etcd-healthcheck-client --config /tmp/192.168.0.2/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew etcd-peer --config /tmp/192.168.0.2/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew etcd-server --config /tmp/192.168.0.2/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew apiserver-etcd-client --config/tmp/192.168.0.2/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew etcd-healthcheck-client --config /tmp/192.168.0.3/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew etcd-peer --config /tmp/192.168.0.3/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew etcd-server --config /tmp/192.168.0.3/kubeadmcfg.yaml</span><br><span class="line">kubeadm alpha certs renew apiserver-etcd-client --config/tmp/192.168.0.3/kubeadmcfg.yaml</span><br><span class="line"><span class="comment">#注意：kubeadmcfg.yaml的生成详见第五篇《kubernetes高可用集群及Helm的部署》</span></span><br><span class="line"><span class="comment">#分别在三台master上重启etcd服务：</span></span><br><span class="line">service etcd restart</span><br><span class="line"><span class="comment">#验证是否成功：</span></span><br><span class="line">etcdctl --ca-file=/etc/kubernetes/pki/etcd/ca.crt --cert-file=/etc/kubernetes/pki/etcd/server.crt --key-         file=/etc/kubernetes/pki/etcd/server.key --endpoints=https://192.168.0.1:2379 cluster-health</span><br><span class="line">etcdctl --ca-file=/etc/kubernetes/pki/etcd/ca.crt --cert-file=/etc/kubernetes/pki/etcd/server.crt --key-file=/etc/kubernetes/pki/etcd/server.key --endpoints=https://192.168.0.2:2379 member list</span><br></pre></td></tr></table></figure>

<h5 id="2、apiserver-证书和汇聚层证书"><a href="#2、apiserver-证书和汇聚层证书" class="headerlink" title="2、apiserver 证书和汇聚层证书"></a>2、apiserver 证书和汇聚层证书</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看证书有效期</span></span><br><span class="line"><span class="comment">#根证书十年有效期</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt -noout -dates</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.crt -noout -dates</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver-kubelet-client.crt -noout -dates</span><br><span class="line"><span class="comment">#根证书十年有效期</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/front-proxy-ca.crt -noout -dates</span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/front-proxy-client.crt -noout -dates</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意：分别在三台master机器上执行此命令</span></span><br><span class="line">kubeadm alpha certs renew apiserver --config /root/kubeadm-config.yaml</span><br><span class="line">kubeadm alpha certs renew apiserver-kubelet-client --config /root/kubeadm-config.yaml</span><br><span class="line">kubeadm alpha certs renew front-proxy-client --config /root/kubeadm-config.yaml</span><br></pre></td></tr></table></figure>

<h3 id="三、重新生成kubernetes配置文件"><a href="#三、重新生成kubernetes配置文件" class="headerlink" title="三、重新生成kubernetes配置文件"></a>三、重新生成kubernetes配置文件</h3><h5 id="1、备份配置文件"><a href="#1、备份配置文件" class="headerlink" title="1、备份配置文件"></a>1、备份配置文件</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mv /etc/kubernetes/admin.conf /etc/kubernetes/admin.conf`date <span class="string">&quot;+%Y%m%d&quot;</span>`</span><br><span class="line">mv /etc/kubernetes/controller-manager.conf /etc/kubernetes/controller-manager.conf`date <span class="string">&quot;+%Y%m%d&quot;</span>`</span><br><span class="line">mv /etc/kubernetes/kubelet.conf /etc/kubernetes/kubelet.conf`date <span class="string">&quot;+%Y%m%d&quot;</span>`</span><br><span class="line">mv /etc/kubernetes/scheduler.conf /etc/kubernetes/scheduler.conf`date <span class="string">&quot;+%Y%m%d&quot;</span>`</span><br><span class="line"><span class="comment">#注意：分别在三台master机器上执行此命令</span></span><br></pre></td></tr></table></figure>

<h5 id="2、重新生成配置文件"><a href="#2、重新生成配置文件" class="headerlink" title="2、重新生成配置文件"></a>2、重新生成配置文件</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm init phase kubeconfig all --config /root/guosanmao/kubeadm-config.yaml</span><br><span class="line"><span class="comment">#注意：分别在三台master机器上执行此命令</span></span><br></pre></td></tr></table></figure>

<h5 id="3、拷贝kuberctl客户端文件"><a href="#3、拷贝kuberctl客户端文件" class="headerlink" title="3、拷贝kuberctl客户端文件"></a>3、拷贝kuberctl客户端文件</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="comment">#注意：分别在三台master机器上执行此命令</span></span><br></pre></td></tr></table></figure>

<h3 id="四、重启docker和kubelet"><a href="#四、重启docker和kubelet" class="headerlink" title="四、重启docker和kubelet"></a>四、重启docker和kubelet</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl restart docker </span><br><span class="line"><span class="comment">#在三台Master上重启docker容器 </span></span><br><span class="line">docker ps |grep -E <span class="string">&#x27;k8s_kube-apiserver|k8s_kube-controller-manager|k8s_kubescheduler&#x27;</span> | awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> |xargs docker restart </span><br><span class="line"><span class="comment">#或者也可以在三台Master上重启三个容器</span></span><br><span class="line">systemctl restart kubelet </span><br><span class="line"><span class="comment">#在三台Master上重启kubelet</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s部署</title>
    <url>/2024/03/06/k8s%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="K8S集群和docker安装步骤："><a href="#K8S集群和docker安装步骤：" class="headerlink" title="K8S集群和docker安装步骤："></a>K8S集群和docker安装步骤：</h4><p>参考文档：<a href="https://www.cnblogs.com/liangjindong/p/9447279.html">https://www.cnblogs.com/liangjindong/p/9447279.html</a>        </p>
<p>参考文档：<a href="https://www.cnblogs.com/huhyoung/p/9657186.html">https://www.cnblogs.com/huhyoung/p/9657186.html</a>          </p>
<p>参考文档：<a href="https://blog.csdn.net/networken/article/details/84991940">https://blog.csdn.net/networken/article/details/84991940</a>              </p>
<p>参考文档：<a href="https://github.com/minminmsn/k8s1.13">https://github.com/minminmsn/k8s1.13</a> （官方）</p>
<p>** 部署前的准备**</p>
<h5 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h5><p><code>systemctl stop firewalld.service &amp;&amp; systemctl disable firewalld.service</code>     	   </p>
<h5 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h5><p><code>swapoff -a</code>             </p>
<p><code>sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstab </code>       </p>
<h5 id="禁用SELinux"><a href="#禁用SELinux" class="headerlink" title="禁用SELinux"></a>禁用SELinux</h5><p><code>setenforce 0</code>  </p>
<p><code>sed -i.bak &#39;s/SELINUX=enforcing/SELINUX=permissive/&#39; /etc/selinux/config</code>        </p>
<h5 id="4、修改相关内核参数"><a href="#4、修改相关内核参数" class="headerlink" title="4、修改相关内核参数"></a>4、修改相关内核参数</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tee /etc/sysctl.d/k8s.conf &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span>           </span><br><span class="line"> net.bridge.bridge-nf-call-ip6tables = 1            </span><br><span class="line"> net.bridge.bridge-nf-call-iptables = 1           </span><br><span class="line"> net.ipv4.ip_forward=1           </span><br><span class="line"> net.ipv4.tcp_tw_recycle=0          </span><br><span class="line"> vm.swappiness=0            </span><br><span class="line"> vm.overcommit_memory=1            </span><br><span class="line"> vm.panic_on_oom=0            </span><br><span class="line"> fs.inotify.max_user_watches=89100           </span><br><span class="line"> fs.file-max=52706963           </span><br><span class="line"> fs.nr_open=52706963           </span><br><span class="line"> net.ipv6.conf.all.disable_ipv6=1            		      </span><br><span class="line"> net.netfilter.nf_conntrack_max=  2310720           </span><br><span class="line"> EOF            </span><br><span class="line">sysctl --system            </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft nofile 65536&quot;</span> &gt;&gt; /etc/security/limits.conf            </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard nofile 65536&quot;</span> &gt;&gt; /etc/security/limits.conf            </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft nproc 65536&quot;</span> &gt;&gt;/etc/security/limits.conf           </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard nproc 65536&quot;</span> &gt;&gt;/etc/security/limits.conf           </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft memlock unlimited&quot;</span> &gt;&gt; /etc/security/limits.conf          </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard memlock unlimited&quot;</span> &gt;&gt;/etc/security/limits.conf      </span><br></pre></td></tr></table></figure>

<h5 id="服务器规划"><a href="#服务器规划" class="headerlink" title="服务器规划"></a>服务器规划</h5><blockquote>
<p>192.168.0.1   # master node节点 </p>
<p>192.168.0.2  # work node节点            </p>
<p>192.168.0.3   # work node节点            </p>
<p>192.168.0.4  # docker镜像仓库        </p>
</blockquote>
<h5 id="服务器之间免密登录（可省略）"><a href="#服务器之间免密登录（可省略）" class="headerlink" title="服务器之间免密登录（可省略）"></a>服务器之间免密登录（可省略）</h5><p>集群之间的机器需要相互通信，所以我们得先配置免密码登录。在三台机器上分别运行如下命令，生成密钥对：            </p>
<blockquote>
<p> [root@master01 ~]# ssh-keygen -t rsa             </p>
<p>以master01为主，执行以下命令，分别把公钥拷贝到其他机器上：             </p>
<p>[root@master01 ~]# ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub node01            </p>
<p>[root@master01 ~]# ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub node02             </p>
<p>[root@master01 ~]# ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub node03                  </p>
<p>注：其他三台机器也需要执行以上这四条命令。</p>
</blockquote>
<p>​	</p>
<h4 id="安装Kubernetes、etcd和flannel"><a href="#安装Kubernetes、etcd和flannel" class="headerlink" title="安装Kubernetes、etcd和flannel"></a><strong>安装Kubernetes、etcd和flannel</strong></h4><h5 id="配置kubernets和docker的yum源（在master和work节点同时配置）"><a href="#配置kubernets和docker的yum源（在master和work节点同时配置）" class="headerlink" title="配置kubernets和docker的yum源（在master和work节点同时配置）"></a>配置kubernets和docker的yum源（在master和work节点同时配置）</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[kubernetes]            name=Kubernetes            		</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/       enabled=1            </span><br><span class="line">gpgcheck=0            </span><br><span class="line">repo_gpgcheck=0            </span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg 	 </span><br><span class="line">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg            </span><br><span class="line">生成缓存            </span><br><span class="line">yum clean all            <span class="comment"># yum makecache           </span></span><br><span class="line">查看kubeadm, kubelet, kubectl的最新版本           </span><br><span class="line">yum list kubeadm  --showduplicates | sort -r           </span><br><span class="line">yum list kubelet  --showduplicates | sort -r            </span><br><span class="line">yum list kubectl  --showduplicates | sort -r            </span><br><span class="line">安装            </span><br><span class="line">yum -y install kubeadm kubelet kubectl --disableexcludes=kubernetes            </span><br><span class="line">yum -y install docker (直接用系统自带的yum源即可)           </span><br><span class="line">yum -y install net-tools ntpdate conntrack-tools  (安装常用工具)           </span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker &amp;&amp; 	systemctl  daemon-reload  </span><br></pre></td></tr></table></figure>

<h5 id="初始化kubernetes的配置"><a href="#初始化kubernetes的配置" class="headerlink" title="初始化kubernetes的配置"></a>初始化kubernetes的配置</h5><p>在master node上需要加载的基本镜像：</p>
<p> kube-apiserver、kube-controller-manager、 kube-scheduler、etcd、kube-proxy、pause、coredns、flannel              </p>
<p>在work node上需要加载的基本镜像：</p>
<p>kube-proxy、pause、coredns、flannel            </p>
<p>用kubeadm查看master上所需的镜像，下载并导入相关的镜像            </p>
<p># kubeadm config images list               </p>
<p>k8s.gcr.io&#x2F;kube-apiserver:v1.13.2               k8s.gcr.io&#x2F;kube-controller-manager:v1.13.2               	</p>
<p>k8s.gcr.io&#x2F;kube-scheduler:v1.13.2               k8s.gcr.io&#x2F;kube-proxy:v1.13.2               	</p>
<p>k8s.gcr.io&#x2F;pause:3.1               k8s.gcr.io&#x2F;etcd:3.2.24               k8s.gcr.io&#x2F;coredns:1.2.6           </p>
<p> A、下载别人阿里云上的镜像，版本必须一致，否则初始化会报错（在线）                         </p>
<p> B、导入已经提前下载好的镜像，版本必须一致，否则初始化会报错（离线）                        </p>
<p> C、从dockers官网下载镜像：  <a href="https://hub.docker.com/u/mirrorgooglecontainers">https://hub.docker.com/u/mirrorgooglecontainers</a>               </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mirrorgooglecontainers/kube-apiserver:v1.13.2                            docker pull mirrorgooglecontainers/kube-controller-manager:v1.13.2                </span><br><span class="line">docker pull mirrorgooglecontainers/kube-scheduler:v1.13.2                </span><br><span class="line">docker pull mirrorgooglecontainers/kube-proxy:v1.13.2                </span><br><span class="line">docker pull mirrorgooglecontainers/pause:3.1               </span><br><span class="line">docker pull mirrorgooglecontainers/etcd:3.2.24               </span><br><span class="line">docker pull coredns/coredns:1.2.6             </span><br></pre></td></tr></table></figure>

<p>版本信息需要根据实际情况进行相应的修改。通过docker tag命令修改为kubeadm查到的标签即可。      		</p>
<p>D、在1.11版本当中，我们宣布CoreDNS已经实现了基于DNS服务发现的普遍可用。而在1.13版本中，CoreDNS则正式取代了kuber-dns成为Kubernetes中的默认DNS服务器。CoreDNS是一种通用的权威DNS服务器，能够提供与Kubernetes向下兼容且具备可扩展性的集成能力。CoreDNS自身属于单一可执行文件与单一进程，因此其活动部件数量要少于以往的其它DNS服务器，且可通过创建自定义DNS条目以支持各类灵活的用例。另外，由于CoreDNS使用Go语言编写，因此具有强大的内存安全性。CoreDNS现在已经成为Kubernetes 1.13及后续版本中的首选DNS解决方案。Kubernetes项目现在开始在常用测试基础设施中默认使用CoreDNS，我们亦建议用户尽快完成这一转换。        Kubernetes (K8s) 官方安装：<a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/">https://kubernetes.io/docs/setup/independent/install-kubeadm/</a>       3、初始化master节点                       </p>
<p> 修改 &#x2F;etc&#x2F;sysconfig&#x2F;kubelet： KUBELET_EXTRA_ARGS&#x3D;”–fail-swap-on&#x3D;false”            </p>
<p># kubeadm reset           </p>
<p># kubeadm init –kubernetes-version&#x3D;v1.13.2 –pod-network-cidr&#x3D;10.244.0.0&#x2F;16 –service-cidr&#x3D;10.96.0.0&#x2F;12 –apiserver-advertise-address&#x3D;192.168.0.102  –ignore-preflight-errors&#x3D;Swap            注意：初始化成功生成的信息，记得保存，根据自己所生成的保存，切记</p>
<p>​           –pod-network-cidr ：指定Pod网络的范围。Kubernetes 支持多种网络方案，而且不同网络方案对–pod-network-cidr有自己的要求，这里设置为 10.244.0.0&#x2F;16 是因为我们将使用 flannel 网络方案，必须设置成这个CIDR。           </p>
<p>​          –apiserver-advertise-address：指明用Master的哪个interface与Cluster的其他节点通信。如果Master有多个interface，建议明确指定，如果不指定，kubeadm会自动选择有默认网关的interface。           </p>
<p>  –service-cidr：为service VIPs使用不同的IP地址。(默认“10.96.0.0&#x2F;12”)   </p>
<p>  –ignore-preflight-errors：将错误显示为警告的检查列表进行忽略。</p>
<p>例如:“IsPrivilegedUser,Swp”。Value ‘all’忽略所有检查中的错误。            </p>
<p>  –image-repository：Kubenetes默认Registries地址是 k8s.gcr.io，在国内并不能访问 gcr.io，在1.13版本中我们可以增加–image-repository参数，默认值是 k8s.gcr.io，将其指定为阿里云镜像地址：registry.aliyuncs.com&#x2F;google_containers。            </p>
<p> –kubernetes-version：关闭版本探测，因为它的默认值是stable-1，会导致从<a href="https://dl.k8s.io/release/stable-1.txt%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%85%B6%E6%8C%87%E5%AE%9A%E4%B8%BA%E5%9B%BA%E5%AE%9A%E7%89%88%E6%9C%AC%E6%9D%A5%E8%B7%B3%E8%BF%87%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E3%80%82">https://dl.k8s.io/release/stable-1.txt下载最新的版本号，我们可以将其指定为固定版本来跳过网络请求。</a>            </p>
<p>初始化生成token一定要记录下来，后边在node节点使用kubeadm join往集群中添加节点时会用到。           </p>
<p> kubeadm join 192.168.0.102:6443 –token ij6at3.ehwxgh7vccsouuj5 –discovery-token-ca-cert-hash sha256:a580d31f70262a442734796dac01c27963106e41750c5339dc3fb6e3e769eec6 –ignore-preflight-errors&#x3D;Swap           </p>
<p> # kubeadm token create –print-join-command  找回以上信息      </p>
<h5 id="添加flannel网络附件："><a href="#添加flannel网络附件：" class="headerlink" title="添加flannel网络附件："></a>添加flannel网络附件：</h5><p># kubectl apply -f kube-flannel.yml                                    </p>
<p>版本：quay.io&#x2F;coreos&#x2F;flannel:v0.10.0-amd64             </p>
<p>安装文件下载：<a href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a>            </p>
<p>镜像文件下载： <a href="https://github.com/coreos/flannel/releases">https://github.com/coreos/flannel/releases</a>       </p>
<h5 id="添加calico网络插件："><a href="#添加calico网络插件：" class="headerlink" title="添加calico网络插件："></a>添加calico网络插件：</h5><p> # kubectl apply -f kube-calico.yml                       </p>
<p>版本：quay.io&#x2F;calico&#x2F;node:v3.4.0           quay.io&#x2F;calico&#x2F;cni:v3.4.0           </p>
<p>安装文件下载：</p>
<p><a href="https://docs.projectcalico.org/v3.4/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml">https://docs.projectcalico.org/v3.4/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml</a>           </p>
<p>镜像文件下载：<a href="https://docs.projectcalico.org/v3.4/releases/#v3.4.0">https://docs.projectcalico.org/v3.4/releases/#v3.4.0</a>            </p>
<p>若是root用户   echo “export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf” &gt;&gt; cat &#x2F;etc&#x2F;profile; source cat &#x2F;etc&#x2F;profile       </p>
<h5 id="初始化work节点"><a href="#初始化work节点" class="headerlink" title="初始化work节点"></a>初始化work节点</h5><p>修改 &#x2F;etc&#x2F;sysconfig&#x2F;kubelet：  KUBELET_EXTRA_ARGS&#x3D;”–fail-swap-on&#x3D;false”           </p>
<p>添加节点到集群中：            </p>
<p># kubeadm reset           </p>
<p># kubeadm join 192.168.0.102:6443 –token ij6at3.ehwxgh7vccsouuj5 –discovery-token-ca-cert-hash sha256:a580d31f70262a442734796dac01c27963106e41750c5339dc3fb6e3e769eec6 –ignore-preflight-errors&#x3D;Swap       </p>
<h5 id="查看各个节点得pod状态"><a href="#查看各个节点得pod状态" class="headerlink" title="查看各个节点得pod状态"></a>查看各个节点得pod状态</h5><p>如果pod状态为Pending、ContainerCreating、ImagePullBackOff 都表明 Pod 没有就绪，Running 才是就绪状态。            </p>
<p>如果有pod提示Init:ImagePullBackOff，说明这个pod的镜像在对应节点上拉取失败，我们可以通过 kubectl describe pod 查看 Pod 具体情况，以确认拉取失败的镜像：           </p>
<p># kubectl get pod –all-namespaces -o wide           </p>
<p># kubectl describe pod coredns-86c58d9df4-lrc44 –namespace&#x3D;kube-system      </p>
<h5 id="部署coredns组件"><a href="#部署coredns组件" class="headerlink" title="部署coredns组件"></a>部署coredns组件</h5><p>参考文档：</p>
<p><a href="http://blog.51cto.com/jerrymin/2338752">http://blog.51cto.com/jerrymin/2338752</a>       <a href="https://github.com/minminmsn/k8s1.13/blob/master/coredns/kubernetes1.13.1%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2coredns.md">https://github.com/minminmsn/k8s1.13/blob/master/coredns/kubernetes1.13.1%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2coredns.md</a>                                      </p>
<p>在官网下载<a href="https://github.com/coredns/deployment/tree/master/kubernetes">https://github.com/coredns/deployment/tree/master/kubernetes</a> </p>
<p>配置文件主要是deploy.sh和coredns.yam.sed            </p>
<p># .&#x2F;deploy.sh -h            </p>
<p># .&#x2F;deploy.sh -s -r 10.96.0.0&#x2F;12 -i 10.96.0.10 -d cluster.local &gt; coredns.yaml           </p>
<p># diff coredns.yaml coredns.yaml.sed            </p>
<p># kubectl create -f coredns.yaml            </p>
<p># kubectl get service –all-namespaces           </p>
<p># dig kubernetes.default.svc.cluster.local @10.96.0.10   </p>
<p>#测试     <strong>coredns是依赖网络插件镜像才可以启动的。而且服务器上必须配置网关，不配置网关，网络插件可能起不来。</strong>       </p>
<h5 id="kubernetes图形化界面dashboard的安装"><a href="#kubernetes图形化界面dashboard的安装" class="headerlink" title="kubernetes图形化界面dashboard的安装"></a>kubernetes图形化界面dashboard的安装</h5><p> A、创建和删除pod              </p>
<p># kubectl apply -f kubernetes-dashboard-http.yml              </p>
<p># kubectl delete -f kubernetes-dashboard-http.yml           </p>
<p> B、查看dashboard的pod是否正常启动，如果正常说明安装成功             </p>
<p> # kubectl get pods –namespace&#x3D;kube-system            </p>
<p> C、查看暴漏的端口号80为内部端口，31111为外网访问端口              </p>
<p> # kubectl get service –namespace&#x3D;kube-system                </p>
<p> kube-dns                         ClusterIP     10.96.0.10       <none>        53&#x2F;UDP,53&#x2F;TCP,9153&#x2F;TCP   3d10h                 kubernetes-dashboard   NodePort    10.98.86.118   <none>        80:31111&#x2F;TCP                      14h       </p>
<h5 id="kubernetes的测试（kubectl命令要调用kube-apiserve，因此只能在master上执行）"><a href="#kubernetes的测试（kubectl命令要调用kube-apiserve，因此只能在master上执行）" class="headerlink" title="kubernetes的测试（kubectl命令要调用kube-apiserve，因此只能在master上执行）"></a>kubernetes的测试（kubectl命令要调用kube-apiserve，因此只能在master上执行）</h5><p># kubectl get componentstatus       #查看组件运行状态                        </p>
<p># kubectl get nodes                        #查看各个节点的信息                       </p>
<p># kubectl get ns                              #查看命名空间                        </p>
<p># kubectl get pod -n kube-system -o wide            #查看命名空间kube-system中容器的启动情况                        </p>
<p># kubectl get pod –all-namespaces -o wide          #查看所有命名空间中容器的启动情况           </p>
<p># kubectl exec pod_name -c container_name -it – &#x2F;bin&#x2F;bash     #进入pod中的容器 </p>
<h4 id="docker私有仓库搭建步骤："><a href="#docker私有仓库搭建步骤：" class="headerlink" title="docker私有仓库搭建步骤："></a>docker私有仓库搭建步骤：</h4><p>搭建企业私有的镜像仓库，满足从开发环境推送和拉取镜像。当我们使用k8s来编排和调度容器时，操作的基本单位是镜像，所以需要从仓库去拉取镜像到当前的工作节点。本来使用公共的docker hub完全可以满足我们的需求，也非常方便，但是上传的镜像任何人都可以访问，其次docker hub的私有仓库又是收费的，所以从安全和商业两方面考虑，企业必须搭建自己的私有镜像仓库。        </p>
<p>为了保证镜像传输安全，从开发环境向私有仓库推送和拉取镜像时，一般使用https的方式，所以我们需要提供一个可信任的、知名的SSL&#x2F;TLS证书，可以向知名的第三方证书颁发机构购买证书，也可以使用Let’s Encrypt生产免费的证书，还可以自己生产一个自签名证书。由于没有购买真实的域名，无法和第三方证书颁发机构进行交互性验证，所以决定自己生产一个自签名证书，添加到私有仓库，然后让docker客户端信任此证书。        </p>
<p>参考文档：<a href="https://www.cnblogs.com/justmine/p/8666907.html">https://www.cnblogs.com/justmine/p/8666907.html</a>    </p>
<h5 id="拉取仓库镜像"><a href="#拉取仓库镜像" class="headerlink" title="拉取仓库镜像"></a>拉取仓库镜像</h5><p># docker pull registry    </p>
<h5 id="生成认证certificate"><a href="#生成认证certificate" class="headerlink" title="生成认证certificate"></a>生成认证certificate</h5><p> 创建一个用于存储证书和私钥的目录         </p>
<p> # mkdir &#x2F;certs         </p>
<p> 生成生产证书和私钥（域名提前想好）        </p>
<p> # openssl req -newkey rsa:4096 -nodes -sha256 -keyout &#x2F;certs&#x2F;domain.key -x509 -days 365 -out &#x2F;certs&#x2F;domain.crt            </p>
<p>Country Name (2 letter code) [XX]:CN            </p>
<p>State or Province Name (full name) []:beijing            </p>
<p>Locality Name (eg, city) [Default City]:beijing            </p>
<p>Common Name (eg, your name or your server’s hostname) []:docker.registry.com            	  	 </p>
<p>Email Address []:<a href="mailto:&#51;&#x37;&#54;&#x32;&#x38;&#52;&#x33;&#x39;&#x33;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;">&#51;&#x37;&#54;&#x32;&#x38;&#52;&#x33;&#x39;&#x33;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a>            </p>
<p>其他项填写默认即可           </p>
<p>[root@docker certs]# ll           总用量 8          </p>
<p> -rw-r–r– 1 root root 2122 1月  21 14:30 domain.crt          </p>
<p> -rw-r–r– 1 root root 3268 1月  21 14:30 domain.key           </p>
<p>复制认证到docker          </p>
<p># mkdir &#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;docker.registry.com&#x2F;           </p>
<p># cp &#x2F;certs&#x2F;domain.crt &#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;docker.registry.com&#x2F;ca.crt           </p>
<p># scp ca.crt master:&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;docker.registry.com&#x2F;           </p>
<p># scp ca.crt node01:&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;docker.registry.com&#x2F;           </p>
<p># scp ca.crt node02:&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;docker.registry.com&#x2F;           </p>
<p>修改主机的hosts文件（master，node01，node02，docker）          </p>
<p># vi &#x2F;etc&#x2F;hosts             192.168.0.55  docker.registry.com    </p>
<h5 id="启动仓库镜像"><a href="#启动仓库镜像" class="headerlink" title="启动仓库镜像"></a>启动仓库镜像</h5><p>上传的镜像保存在容器的&#x2F;var&#x2F;lib&#x2F;registry目录下，创建registry容器时，会自动创建一个数据卷，数据卷对应的宿主机下的目录一般为：&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;XXX&#x2F;_data。可以在创建registry的容器时，通过-v参数，修改这种对应关系：        </p>
<p> # docker run -d   –restart&#x3D;always   –name docker.registry.com  -v &#x2F;opt&#x2F;docker&#x2F;registry&#x2F;data:&#x2F;var&#x2F;lib&#x2F;registry   -v &#x2F;certs:&#x2F;certs   -e REGISTRY_HTTP_ADDR&#x3D;0.0.0.0:443   -e REGISTRY_HTTP_TLS_CERTIFICATE&#x3D;&#x2F;certs&#x2F;domain.crt   -e REGISTRY_HTTP_TLS_KEY&#x3D;&#x2F;certs&#x2F;domain.key   -p 443:443   registry                </p>
<p># netstat -tnlp | grep 443 </p>
<p>参数说明	-d后台静默运行容器。</p>
<p>  -restart设置容器重启策略。</p>
<p>  -name命名容器。</p>
<p>  -v挂载host的certs&#x2F;目录到容器的&#x2F;certs&#x2F;目录。</p>
<p>  -e REGISTRY_HTTP_ADDR设置仓库主机地址格式。</p>
<p>  -e REGISTRY_HTTP_TLS_CERTIFICATE设置环境变量告诉容器证书的位置。</p>
<p>  -e REGISTRY_HTTP_TLS_KEY设置环境变量告诉容器私钥的位置。</p>
<p>  -p将容器的 443 端口映射到Host的 443 端口。    </p>
<h5 id="docker镜像仓库测试"><a href="#docker镜像仓库测试" class="headerlink" title="docker镜像仓库测试"></a>docker镜像仓库测试</h5><p># docker pull centos         </p>
<p># docker tag docker.io&#x2F;centos  docker.registry.com&#x2F;centos:v7.5         </p>
<p># docker push docker.registry.com&#x2F;centos:v7.5         </p>
<p>通过浏览器查看仓库概况：         <a href="https://192.168.0.55/v2/_catalog">https://192.168.0.55/v2/_catalog</a>        </p>
<p>192.168.0.55为ocker镜像仓库        </p>
<p>通过浏览器查看镜像详情：         <a href="https://192.168.0.55/v2/centos/tags/list">https://192.168.0.55/v2/centos/tags/list</a>         	 </p>
<p>{“name”:”centos”,”tags”:[“v7.5”,”v7.2”,”7.5”]}    </p>
<p>6、基于yaml的kubernetes容器构建测试        </p>
<p># kubectl apply -f test.yaml                        	 #创建pod        </p>
<p># kubectl get pod hello-world                     	 #查询pod的简要信息        </p>
<p># kubectl logs hello-world                           	 #查询pod的输出        </p>
<p># kubectl get pod hello-world –output yaml     #用yaml格式显示pod的完整信息        </p>
<p># kubectl get pod hello-world –output json      #用json格式显示pod的完整信息       </p>
<p># kubectl describe pod hello-world                   #查询pod的状态及生命周期                  </p>
<p># kubectl delete pod hello-world                       #删除pod        </p>
<h4 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a><strong>Kubernetes介绍</strong></h4><p>Kubernetes是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes能够进行应用的自动化部署和扩缩容。在Kubernetes中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes积累了作为Google生产环境运行工作负载15年的经验，并吸收了来自于社区的最佳想法和实践。Kubernetes经过这几年的快速发展，形成了一个大的生态环境，Google在2014年将Kubernetes作为开源项目。Kubernetes的关键特性包括：</p>
<p>​	* 自动化装箱：在不牺牲可用性的条件下，基于容器对资源的要求和约束自动部署容器。同时，为了提高利用率和节省更多资源，将关键和最佳工作量结合在一起。</p>
<p>​	* 自愈能力：当容器失败时，会对容器进行重启；当所部署的Node节点有问题时，会对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭此容器；直到容器正常运行时，才会对外提供服务。</p>
<p>* 水平扩容：通过简单的命令、用户界面或基于CPU的使用情况，能够对应用进行扩容和缩容。</p>
<p>* 服务发现和负载均衡：开发者不需要使用额外的服务发现机制，就能够基于Kubernetes进行服务发现和负载均衡。</p>
<p>* 自动发布和回滚：Kubernetes能够程序化的发布应用和相关的配置。如果发布有问题，Kubernetes将能够回归发生的变更。</p>
<p>* 保密和配置管理：在不需要重新构建镜像的情况下，可以部署和更新保密和应用配置。</p>
<p>* 存储编排：自动挂接存储系统，这些存储系统可以来自于本地、公共云提供商（例如：GCP和AWS）、网络存储(例如：NFS、iSCSI、Gluster、Ceph、Cinder和Floker等)。</p>
<p>​         Kubernetes属于主从分布式架构，主要由Master Node和Worker Node组成，以及包括客户端命令行工具kubectl和其它附加项。</p>
<p>​	* Master Node：作为控制节点，对集群进行调度管理；Master Node由API Server、Scheduler、Cluster State Store和Controller-Manger Server所组成；</p>
<p>​	* Worker Node：作为工作节点，运行业务应用的容器；Worker Node包含kubelet、kube proxy和Container Runtime；</p>
<p>​	* kubectl：用于通过命令行与API Server进行交互，而对Kubernetes进行操作，实现在集群中进行各种资源的增删改查等操作；</p>
<p>​	* Add-on：是对Kubernetes核心功能的扩展，例如增加网络和网络策略等能力。</p>
<h5 id="Master-Node（主节点）"><a href="#Master-Node（主节点）" class="headerlink" title="Master Node（主节点）"></a><strong>Master Node（主节点）</strong></h5><p>​	* API Server（API服务器）</p>
<p> 主要处理REST操作，确保它们生效并执行相关业务逻辑。API Server 是所有 REST 命令的入口，它的相关结果状态将被保存在 etcd 中。API Server 也作为集群的网关，默认情况，客户端通过 API Server 对集群进行访问，客户端需要通过认证，并使用 API Server 作为访问 Node 和 Pod（以及service）的堡垒和代理&#x2F;通道。</p>
<p>* Cluster state store（集群状态存储）</p>
<p>Kubernetes默认使用 etcd 作为集群存储，也可以使用其它技术。etcd是一个简单的、分布式的、一致的key-value存储，主要被用来共享配置和服务发现。etcd 提供了一个 CRUD 操作的 REST API，以及提供作为注册的接口，以监控指定的Node。集群的所有状态都存储在 etcd 实例中，并具有监控的能力，因此当 etcd 中的信息发生变化时，就能够快速的通知集群中相关的组件。</p>
<p>​	* Controller-Manager Server（控制管理服务器）</p>
<p>用于执行大部分的集群层次的功能，它既执行生命周期功能（命名空间创建和生命周期、事件垃圾收集、已终止垃圾收集、级联删除垃圾收集、node垃圾收集等），也执行API业务逻辑（pod的弹性扩容等）。控制管理提供自愈能力、扩容、应用生命周期管理、服务发现、路由、服务绑定和提供。Kubernetes默认提供Replication Controller、Node Controller、Namespace Controller、Service Controller、Endpoints Controller、Persistent Controller、DaemonSet Controller等控制器。</p>
<p>​	* Scheduler（调度器）</p>
<p>scheduler 组件为容器自动选择运行的主机。依据请求资源的可用性，服务请求的质量等约束条件，scheduler 监控未绑定的pod，并将其绑定至特定的 node 节点。Kubernetes 也支持用户自己提供调度器，Scheduler负责根据调度策略自动将 Pod 部署到合适 Node 中，调度策略分为预选策略和优选策略，Pod的整个调度过程分为两步：</p>
<p>​	1. 预选Node：遍历集群中所有的 Node，按照具体的预选策略筛选出符合要求的 Node 列表。如没有 Node 符合预选策略规则，该 Pod 就会被挂起，直到集群中出现符合要求的 Node。</p>
<p>​	2. 优选Node：预选 Node 列表的基础上，按照优选策略为待选的 Node 进行打分和排序，从中获取最优 Node。</p>
<h5 id="Worker-Node（从节点）"><a href="#Worker-Node（从节点）" class="headerlink" title="Worker Node（从节点）"></a><strong>Worker Node（从节点）</strong></h5><p>​	* Kubelet  </p>
<p>Kubelet是 Kubernetes 中最主要的控制器，它是 Pod 和 Node API 的主要实现者，Kubelet 负责驱动容器执行层。在Kubernetes 中，应用容器彼此是隔离的，并且与其运行的主机也是隔离的，这是对应用进行独立解耦管理的关键点。           在 Kubernets 中，Pod 作为基本的执行单元，它可以拥有多个容器和存储数据卷，能够方便在每个容器中打包一个单一的应用，从而解耦了应用构建时和部署时的所关心的事项，能够方便在虚拟机之间进行迁移。Kubelet 是 Pod 是否能够运行在特定 Node 上的最终裁决者。kubelet默认使用 cAdvisor 进行资源监控。负责管理 Pod、容器、镜像、数据卷等，实现集群对节点的管理，并将容器的运行状态汇报给Kubernetes API Server。</p>
<p>​	* Container Runtime（容器运行时）</p>
<p>每一个 Node 都会运行一个 Container Runtime，其负责下载镜像和运行容器。Kubernetes 本身并不提供容器运行时环境，但提供了接口，可以插入所选择的容器运行时环境。kubelet 使用 Unix socket 之上的 gRPC 框架与容器运行时进行通信，kubelet 作为客户端，而 CRI shim 作为服务器。                       protocol buffers API 提供两个gRPC服务，ImageService 和 RuntimeService。ImageService 提供拉取、查看、和移除镜像的 RPC，RuntimeSerivce则提供管理 Pods 和容器生命周期管理的 RPC，以及与容器进行交互 (exec&#x2F;attach&#x2F;port-forward)。容器运行时能够同时管理镜像和容器（例如：Docker和Rkt），并且可以通过同一个套接字提供这两种服务。在Kubelet中，这个套接字通过 –container-runtime-endpoint 和 –image-service-endpoint 字段进行设置。Kubernetes CRI 支持的容器运行时包括docker、rkt、cri-o、frankti、kata-containers和clear-containers 等。</p>
<p>​	* kube proxy</p>
<p>基于一种公共访问策略（例如：负载均衡），服务提供了一种访问一群 pod 的途径。此方式通过创建一个虚拟的IP来实现，客户端能够访问此虚拟IP，并能够将服务透明地代理到 Pod。每一个 Node 都会运行一个 kube-proxy，kube proxy 通过 iptables 规则将访问引导至服务IP，实现服务到 Pod 的路由和转发，通过这种方式 kube-proxy 提供了一个高可用的负载均衡解决方案。服务发现主要通过DNS实现。</p>
<p>​	* pod</p>
<p>是运行的最小单元，里面可以运行1～N个 container ，每一个 pod 都会有一个唯一的ip地址。资源是根据 namespace 来进行隔离的。</p>
<h5 id="客户端工具kubectl"><a href="#客户端工具kubectl" class="headerlink" title="客户端工具kubectl"></a><strong>客户端工具kubectl</strong></h5><p>kubectl是Kubernetes集群的命令行接口。运行kubectl命令的语法如下所示：        # kubectl [command] [TYPE] [NAME] [flags]   </p>
<p>​	* comand：指定要对资源执行的操作，例如create、get、describe和delete</p>
<p>​	* TYPE：指定资源类型，资源类型是大小写敏感的，开发者能够以单数、复数和缩略的形式。例如：</p>
<p>​	* NAME：指定资源的名称，名称也大小写敏感的。如果省略名称，则会显示所有的资源</p>
<p>​	* flags：指定可选的参数。例如，可以使用-s或者–server参数指定Kubernetes API server的地址和端口。</p>
<h5 id="附加项和其他依赖"><a href="#附加项和其他依赖" class="headerlink" title="附加项和其他依赖"></a><strong>附加项和其他依赖</strong></h5><p>在 Kunbernetes 中可以以附加项的方式扩展 Kubernetes 的功能，目前主要有网络、服务发现和可视化这三大类的附加项，下面是可用的一些附加项：    </p>
<p>网络和网络策略</p>
<p>​	* ACI：通过与Cisco ACI集成的容器网络和网络安全。</p>
<p>​	* Calico：是一个安全的3层网络和网络策略提供者。</p>
<p>​	* Canal：联合Fannel和Calico，通过网络和网络侧。</p>
<p>​	* Cilium：是一个3层网络和网络侧插件，能够透明的加强HTTP&#x2F;API&#x2F;L7 策略。既支持路由，也支持overlay&#x2F;encapsultion模式。</p>
<p>​	* Flannel：是一个overlay的网络提供者。</p>
<p>服务发现</p>
<p>​	* CoreDNS 是一个灵活的，可扩展的DNS服务器，它能够作为Pod集群内的DNS进行安装。</p>
<p>​	* Ingress 提供基于Http协议的路由转发机制。</p>
<p>可视化&amp;控制</p>
<p>​	* Dashboard 是Kubernetes的web用户界面。</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s部署tomcat</title>
    <url>/2024/03/06/k8s%E9%83%A8%E7%BD%B2tomcat/</url>
    <content><![CDATA[<h5 id="拉取tomcat镜像"><a href="#拉取tomcat镜像" class="headerlink" title="拉取tomcat镜像"></a><strong>拉取tomcat镜像</strong></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull tomcat</span><br><span class="line">cat webapp-rc.yaml   </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata: </span><br><span class="line">    name: webapp</span><br><span class="line">spec:	  </span><br><span class="line">    replicas: 3</span><br><span class="line">    template:</span><br><span class="line">        metadata: </span><br><span class="line">        name: webapp</span><br><span class="line">        labels:</span><br><span class="line">            app: webapp</span><br><span class="line">        spec: </span><br><span class="line">            containers:</span><br><span class="line">                - name: webapp</span><br><span class="line">                image: tomcat</span><br><span class="line">                 ports:</span><br><span class="line">                 - containerPort: 8080                 	  </span><br></pre></td></tr></table></figure>

<h5 id="创建RC文件-副本控制器"><a href="#创建RC文件-副本控制器" class="headerlink" title="创建RC文件&#x2F;&#x2F;副本控制器"></a><strong>创建RC文件&#x2F;&#x2F;副本控制器</strong></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create -f webapp-rc.yaml  </span><br><span class="line">replicationcontroller/webapp created</span><br><span class="line">kubectl get pods -l app=webapp </span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">webapp-fq2qh   1/1     Running   0          56s</span><br><span class="line">webapp-jbmzg   1/1     Running   0          56s</span><br><span class="line">webapp-jsv4z   1/1     Running   0          57s</span><br></pre></td></tr></table></figure>

<h5 id="获取Pod-IP地址"><a href="#获取Pod-IP地址" class="headerlink" title="获取Pod IP地址"></a><strong>获取Pod IP地址</strong></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get pods -l app=webapp -o yaml</span><br><span class="line">kubectl get pods -l app=webapp -o yaml | grep podIP</span><br><span class="line">podIP: 10.1.7.31</span><br><span class="line">podIP: 10.1.7.30</span><br><span class="line">podIP: 10.1.7.29</span><br><span class="line">curl 10.1.7.31:8080       //测试访问</span><br><span class="line">curl 10.1.7.30:8080       //测试访问</span><br><span class="line">curl 10.1.7.29:8080       //测试访问</span><br><span class="line">kubectl <span class="built_in">exec</span> -ti &lt;your-pod-name&gt;  -n &lt;your-namespace&gt;  -- /bin/sh 可进入替换war包测试</span><br></pre></td></tr></table></figure>

<h5 id="使用expose-将webapp里的所有pod添加到服务"><a href="#使用expose-将webapp里的所有pod添加到服务" class="headerlink" title="使用expose 将webapp里的所有pod添加到服务"></a><strong>使用expose 将webapp里的所有pod添加到服务</strong></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl expose rc webapp</span><br><span class="line">service/webapp exposed</span><br><span class="line">kubectl get svc</span><br><span class="line">NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">webapp          ClusterIP   10.97.154.51   &lt;none&gt;        8080/TCP   		21s</span><br><span class="line">curl 10.97.154.51:8080</span><br><span class="line">//这里的访问被自动负载分发到后面三个pod之一</span><br></pre></td></tr></table></figure>

<h5 id="或者通过配置文件Service-创建"><a href="#或者通过配置文件Service-创建" class="headerlink" title="或者通过配置文件Service 创建"></a><strong>或者通过配置文件Service 创建</strong></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl delete svc webapp  //删除刚刚通过命令创建的SVC</span><br><span class="line">service <span class="string">&quot;webapp&quot;</span> deleted</span><br><span class="line">vi webapp-service.yaml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">   name: webapp</span><br><span class="line">spec:</span><br><span class="line">   ports:</span><br><span class="line"> 	  - port: 8088 	</span><br><span class="line"> 	    targetPort: 8080 	</span><br><span class="line"> 	  selector:</span><br><span class="line">    	  app: webapp</span><br></pre></td></tr></table></figure>

<p>字段解析：ports 关键字中指定了Service的虚拟端口8088，由于和pod容器端口8080不同，所以	需要targetPort指定后面pod的端口号。selector关键字设置了后端pod所拥有的label：app&#x3D;webapp</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create -f  webapp-service.yaml </span><br><span class="line">service/webapp created</span><br><span class="line">kubectl get svc</span><br><span class="line">NAME               TYPE              CLUSTER-IP          EXTERNAL-IP       PORT(S)         AGE</span><br><span class="line">kubernetes       ClusterIP        10.96.0.1    	      &lt;none&gt;                  443/TCP           7d22h</span><br><span class="line">redis-service    ClusterIP         None             	      &lt;none&gt;                  6379/TCP         6d4h</span><br><span class="line">webapp            ClusterIP        10.102.174.4   	      &lt;none&gt;                  8088/TCP         7s</span><br><span class="line">curl 10.102.174.4:8088</span><br><span class="line">//这里的访问同样被自动负载分发到后面三个pod之一</span><br></pre></td></tr></table></figure>

<p>名词解释：目前kubernetes提供的两种负载分发策略</p>
<p>RoundRobin：轮训模式</p>
<p>SesssionAffinity：基于客户端IP进行会话保持，会转发到相同的 pod上</p>
<h5 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a><strong>其他场景</strong></h5><p>在某些场景下，开发人员希望自己控制负载均衡策略，不使用Service提供的负载均衡功能，kubernetes通过Headless Service实现。不设置ClusterIP（无入口IP地址），仅通过Label Selector 将后端的Pod列表返回给调用的客户端。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">例1：</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service </span><br><span class="line">metadata:</span><br><span class="line">    name: nginx</span><br><span class="line">    labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">    ports:</span><br><span class="line">    - port: 80</span><br><span class="line">    clusterIP: None</span><br><span class="line">    selector:</span><br><span class="line"> app: nginx</span><br></pre></td></tr></table></figure>

<p>该Service没有指定clusterIP，对其的访问将获得具有label “app&#x3D;nginx”的全部pod列表，然后客户端程序需要自己实现负载分发策略，再确定访问具体哪一个后端的Pod。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">例2：</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service </span><br><span class="line">metadata:</span><br><span class="line">   name: my-service </span><br><span class="line">spec:</span><br><span class="line">   ports: </span><br><span class="line">   - protocol: TCP</span><br><span class="line">     port: 80</span><br><span class="line">        targetPort: 80</span><br></pre></td></tr></table></figure>

<p>该定义创建一个不带标签选择器的Service，即无法选择后端Pod，系统也不会自动创建Endpoint,因此需要手动创建一个和该Service同名的Endpoint，用于指定后端的访问地址。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Endpoints </span><br><span class="line">metadata:</span><br><span class="line">    name: my-service</span><br><span class="line">subsets:</span><br><span class="line">- addresses: </span><br><span class="line">  - IP: 1.2.3.4</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">例3：</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service </span><br><span class="line">metadata:</span><br><span class="line">    name: webapp</span><br><span class="line">spec:</span><br><span class="line">    ports:</span><br><span class="line">    - port: 8080</span><br><span class="line">      targetPort: 8080</span><br><span class="line">      name: web</span><br><span class="line">      - port: 8005</span><br><span class="line">      targetPort: 8005</span><br><span class="line">      name: management</span><br><span class="line">      selector: </span><br><span class="line">      app: wepapp</span><br><span class="line">定义多个端口</span><br><span class="line">例4：</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service </span><br><span class="line">metadata:</span><br><span class="line">name: kube-dns</span><br><span class="line">namespace: kube-system</span><br><span class="line">labels:</span><br><span class="line">k8s-app: kube-dns</span><br><span class="line">kubernetes.io/cluster-servcvice: <span class="string">&quot;true&quot;</span></span><br><span class="line">kubernetes.io/name: <span class="string">&quot;KubeDNS&quot;</span></span><br><span class="line">spec:</span><br><span class="line">selector:</span><br><span class="line">k8s-app: kube-dns</span><br><span class="line">clusterIP:</span><br><span class="line">ports:</span><br><span class="line">- name: dns</span><br><span class="line">   port: 53</span><br><span class="line">   protocol: UDP</span><br><span class="line">- name: dns-tcp</span><br><span class="line">  port: 53</span><br><span class="line">  protocol: TCP  </span><br><span class="line">定义相同端口，不同协议</span><br></pre></td></tr></table></figure>

<p><strong>7.集群外部访问Pod或Service</strong></p>
<p>1.将容器应用的端口号映射到主机端口</p>
<p>  （1）通过设置hostPort</p>
<p>​      #vim webpod-hostport.yaml</p>
<p>apiVersion: v1</p>
<p>kind: Pod</p>
<p>metadata:</p>
<p>​    name: webapp1</p>
<p>​    labels:</p>
<pre><code>      app: webapp1
</code></pre>
<p>spec:</p>
<p>​    containers:</p>
<p>​    - name: webapp1</p>
<pre><code>      image: tomcat
  
      ports:
  
       - containerPort: 8080
  
       hostPort: 8081
</code></pre>
<p>#kubectl create -f webpod-hostport.yaml</p>
<p>pod&#x2F;webapp1 created</p>
<p>#kubectl get pods</p>
<p>&#x2F;&#x2F;此时通过浏览器访问 IP地址为该Pod运行在哪台Node上的地址</p>
<p>&#x2F;&#x2F;通过此方式在Node节点看netstat -ntlp |grep 8081 不会有端口</p>
<p>​    （2）通过设置Pod级别的hostNetwork&#x3D;true,该Pod的所有容器的端口号都将映射到物理</p>
<pre><code>     机上，设置hostNetwork需要注意，在容器的ports部分如果不知道hostPort,则默认	 
</code></pre>
<p>​     hostPort等于containerPort,如果指定了hostPort,则hostPort必须等于containPort。</p>
<p>​     #vim webpod-hostnetwork.yaml </p>
<p>apiVersion: v1</p>
<p>kind: Pod</p>
<p>metadata:</p>
<p>​    name: webapp2</p>
<p>​    labels:</p>
<p>​       app: webapp2</p>
<p>spec:</p>
<p>​    hostNetwork: true</p>
<p>​    containers:</p>
<p>​    - name: webapp2</p>
<p>​      image: tomcat</p>
<p>​      imagePullPolicy: Never</p>
<p>​      ports:</p>
<p>​      - containerPort: 8080</p>
<p>#kubectl create -f webpod-hostnetwork.yaml </p>
<p>pod&#x2F;webapp2 created</p>
<p>#kubectl get pods</p>
<p>&#x2F;&#x2F;此时通过浏览器访问 IP地址为该Pod运行在哪台Node上的地址</p>
<p>&#x2F;&#x2F;通过此方式在Node节点看netstat -ntlp |grep 8080会有端口</p>
<p>2.将Service的端口号映射到物理机</p>
<p>（1）通过设置nodePort 映射到物理机，同时设置Service的类型为NodePort</p>
<p>#kubectl delete -f  webpod-hostnetwork.yaml</p>
<p>#kubectl get svc</p>
<p>#kubectl delete svc webapp</p>
<p>#vim webservice-nodeport.yaml</p>
<p>apiVersion: v1</p>
<p>kind: Service</p>
<p>metadata:</p>
<p>​    name: webapp3</p>
<p>spec:</p>
<p>​    type: NodePort</p>
<p>​    ports:</p>
<p>​    - port: 8080</p>
<p>​      targetPort: 8080</p>
<p>​      nodePort: 32222</p>
<p>​    selector:</p>
<p>​     	   app: webapp</p>
<p>nodePort:取值范围30000-32767</p>
<p>&#x2F;&#x2F;此时通过浏览器访问，将负载分发到后端的多个Pod上</p>
<p>（2）设置LoadBalancer映射到云服务厂商提供的LoadBalancer地址。负载分发方式依赖于	</p>
<p>  云服务厂商的LoadBalancer机制</p>
<p>#vim loadBalancer-service.yaml</p>
<p>apiVersion: v1</p>
<p>kind: Service</p>
<p>metadata:</p>
<p>​    name: my-service </p>
<p>spec:</p>
<p>​    selector:</p>
<p>​    app: myapp</p>
<p>​    ports:</p>
<p>​    - protocol: TCP</p>
<p>​      port: 80</p>
<p>​      targetPort:	9376</p>
<p>​      nodePort: 30022</p>
<p>​    clusterIP: 10.0.2.2</p>
<p>​    loadBalancerIP: 22.22.22.22</p>
<p>​    type: LoadBalancer</p>
<p>status:</p>
<p>​    loadBalancer:</p>
<p>​      ingress:</p>
<p>​       - ip:111.111.111.111</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s常见问题</title>
    <url>/2024/03/06/k8s%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>Kubernetes创建pod一直处于ContainerCreating排查和解决</strong></p>
<p>用k8s创建完pod后，发现无法访问demo应用，查了一下pods状态，发现都在containercreationg状态中。</p>
<p><img loading="lazy" data-src="D:\有道云\文件\super_linux@163.com\2a439673c93a433ea739ed81cb166544\1daf6413ce50.png" alt="img"></p>
<p>百度了一下，根据网上的方法，查了一下mysql-jn6f2这个pods的详情</p>
<p><img loading="lazy" data-src="D:\有道云\文件\super_linux@163.com\a266c0dd3984408aa3a1c965ca9f4c4a\f8df32fa1d6.jpeg" alt="img"></p>
<p>其中最主要的问题是：details: (open &#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;registry.access.redhat.com&#x2F;redhat-ca.crt: no such file or directory)</p>
<p>解决方案：</p>
<p>查看&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;registry.access.redhat.com&#x2F;redhat-ca.crt （该链接就是上图中的说明） 是一个软链接，但是链接过去后并没有真实的&#x2F;etc&#x2F;rhsm，所以需要使用yum安装：</p>
<p>yum install <em>rhsm</em></p>
<p>安装完成后，执行一下docker pull registry.access.redhat.com&#x2F;rhel7&#x2F;pod-infrastructure:latest</p>
<p>如果依然报错，可参考下面的方案：</p>
<p>wget <a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm">http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm</a></p>
<p>rpm2cpio python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm | cpio -iv –to-stdout .&#x2F;etc&#x2F;rhsm&#x2F;ca&#x2F;redhat-uep.pem | tee &#x2F;etc&#x2F;rhsm&#x2F;ca&#x2F;redhat-uep.pem</p>
<p>这两个命令会生成&#x2F;etc&#x2F;rhsm&#x2F;ca&#x2F;redhat-uep.pem文件.</p>
<p>顺得的话会得到下面的结果。</p>
<p>[root@localhost]# docker pull registry.access.redhat.com&#x2F;rhel7&#x2F;pod-infrastructure:latest</p>
<p>Trying to pull repository registry.access.redhat.com&#x2F;rhel7&#x2F;pod-infrastructure …</p>
<p>latest: Pulling from registry.access.redhat.com&#x2F;rhel7&#x2F;pod-infrastructure</p>
<p>26e5ed6899db: Pull complete</p>
<p>66dbe984a319: Pull complete</p>
<p>9138e7863e08: Pull complete</p>
<p>Digest: sha256:92d43c37297da3ab187fc2b9e9ebfb243c1110d446c783ae1b989088495db931</p>
<p>Status: Downloaded newer image for registry.access.redhat.com&#x2F;rhel7&#x2F;pod-infrastructure:latest</p>
<p>删除原来创建的rc</p>
<p>[root@localhost &#x2F;]# kubectl delete -f mysql-rc.yaml</p>
<p>重新创建</p>
<p>[root@localhost &#x2F;]# kubectl create -f mysql-rc.yaml</p>
<p>replicationcontroller “mysql” created</p>
<p>再次查看状态</p>
<p>[root@localhost &#x2F;]# kubectl get pod</p>
<p>NAME READY STATUS RESTARTS AGE</p>
<p>mysql-b8m2q 1&#x2F;1 Running 0 27m</p>
<p>一切正常。</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s集群安装</title>
    <url>/2024/03/06/k8s%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><strong>一、环境准备</strong></p>
<ul>
<li><p>操作系统 CentOS 7.6</p>
</li>
<li><p>内存 2G 【至少】</p>
</li>
<li><p>CPU 2核【至少】</p>
</li>
<li><p>硬盘 20G 【至少】</p>
<p> 1.1yum 源</p>
<p> 1.2关闭防火墙，关闭selinux</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#systemctl stop firewalld &amp; systemctl disable firewalld</span></span><br><span class="line"><span class="comment">#setenforce 0</span></span><br></pre></td></tr></table></figure>

<p>   1.3关闭swap</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sed -i &#x27;/ swap / s/^/#/&#x27; /etc/fstab</span></span><br></pre></td></tr></table></figure>

<p>   1.4系统环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi /etc/sysctl.d/k8s.conf</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv4.tcp_tw_recycle=0</span><br><span class="line">vm.swappiness=0</span><br><span class="line">vm.overcommit_memory=1</span><br><span class="line">vm.panic_on_oom=0</span><br><span class="line">fs.inotify.max_user_watches=89100	</span><br><span class="line">fs.file-max=52706963</span><br><span class="line">fs.nr_open=52706963</span><br><span class="line">net.ipv6.conf.all.disable_ipv6=1			  	</span><br><span class="line">net.netfilter.nf_conntrack_max=2310720</span><br><span class="line"><span class="built_in">echo</span> “* soft nofile 65536” &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> “* hard nofile 65536” &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> “* soft nproc 65536” &gt;&gt;/etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> “* hard nproc 65536” &gt;&gt;/etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> “* soft memlock unlimited” &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> “* hard memlock unlimited” &gt;&gt;/etc/security/limits.conf</span><br></pre></td></tr></table></figure>

<p><strong>二、docker安装</strong></p>
<p>   2.1安装docker</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line"><span class="comment">#yum install docker-ce -y</span></span><br><span class="line"><span class="comment">#docker --version</span></span><br><span class="line"><span class="comment">#systemctl start docker &amp; systemctl enable docker</span></span><br></pre></td></tr></table></figure>

<p>  2.2配置加速</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mkdir -p /etc/docker</span></span><br><span class="line"><span class="comment">#vi /etc/docker/daemon.json</span></span><br><span class="line">&#123; 	 <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://27zv9ros.mirror.aliyuncs.com&quot;</span>] &#125;</span><br><span class="line"><span class="comment">#systemctl daemon-reload     #systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p><strong>三、主节点安装</strong></p>
<p>​    3.1下载安装包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum install -y kubelet kubeadm kubectl</span></span><br><span class="line"><span class="comment">#systemctl enable kubelet &amp;&amp; systemctl start kubelet</span></span><br></pre></td></tr></table></figure>

<p>​    3.2拉取镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#kubeadm config images list  </span></span><br><span class="line">//用kubeadm查看master上所需的镜像，下载并导入相关的镜像</span><br><span class="line"><span class="comment">#docker pull mirrorgooglecontainers/kube-controller-manager:v1.15.0</span></span><br><span class="line"><span class="comment">#docker pull mirrorgooglecontainers/kube-apiserver:v1.15.0</span></span><br><span class="line"><span class="comment">#docker pull mirrorgooglecontainers/kube-scheduler:v1.15.0 </span></span><br><span class="line"><span class="comment">#docker pull mirrorgooglecontainers/kube-proxy:v1.15.0</span></span><br><span class="line"><span class="comment">#docker pull mirrorgooglecontainers/pause:3.1 </span></span><br><span class="line"><span class="comment">#docker pull mirrorgooglecontainers/etcd:3.3.10</span></span><br><span class="line"><span class="comment">#docker pull coredns/coredns:1.3.1</span></span><br><span class="line"><span class="comment">#docker tag mirrorgooglecontainers/kube-proxy:v1.15.0  k8s.gcr.io/kube-proxy:v1.15.0</span></span><br><span class="line"><span class="comment">#docker tag mirrorgooglecontainers/kube-scheduler:v1.15.0 k8s.gcr.io/kube-scheduler:v1.15.0</span></span><br><span class="line"><span class="comment">#docker tag mirrorgooglecontainers/kube-apiserver:v1.15.0 k8s.gcr.io/kube-apiserver:v1.15.0</span></span><br><span class="line"><span class="comment">#docker tag mirrorgooglecontainers/kube-controller-manager:v1.15.0 k8s.gcr.io/kube-controller-manager:v1.15.0</span></span><br><span class="line"><span class="comment">#docker tag mirrorgooglecontainers/etcd:3.3.10  k8s.gcr.io/etcd:3.3.10</span></span><br><span class="line"><span class="comment">#docker tag coredns/coredns:1.3.1 k8s.gcr.io/coredns:1.3.1</span></span><br><span class="line"><span class="comment">#docker tag mirrorgooglecontainers/pause:3.1  k8s.gcr.io/pause:3.1 </span></span><br><span class="line"><span class="comment">#docker rmi mirrorgooglecontainers/kube-apiserver:v1.15.0</span></span><br><span class="line"><span class="comment">#docker rmi mirrorgooglecontainers/kube-controller-manager:v1.15.0</span></span><br><span class="line"><span class="comment">#docker rmi mirrorgooglecontainers/kube-scheduler:v1.15.0</span></span><br><span class="line"><span class="comment">#docker rmi mirrorgooglecontainers/kube-proxy:v1.15.0</span></span><br><span class="line"><span class="comment">#docker rmi mirrorgooglecontainers/pause:3.1</span></span><br><span class="line"><span class="comment">#docker rmi mirrorgooglecontainers/etcd:3.3.10</span></span><br><span class="line"><span class="comment">#docker rmi coredns/coredns:1.3.1</span></span><br><span class="line"><span class="comment">#docker images</span></span><br></pre></td></tr></table></figure>

<p>   3.3初始化 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#kubeadm init --pod-network-cidr=10.1.0.0/16 --kubernetes-version=v1.15.0 --apiserver-advertise-address=192.168.1.100</span></span><br></pre></td></tr></table></figure>

<p>注意：此处末尾会有提示，需要在执行的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mkdir -p $HOME/.kube</span></span><br><span class="line"><span class="comment">#cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></span><br><span class="line"><span class="comment">#chown $(id -u):$(id -g) $HOME/.kube/config</span></span><br></pre></td></tr></table></figure>

<p>  3.4下载flannel网络</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line"><span class="comment">#kubectl apply -f kube-flannel.yml</span></span><br><span class="line">离线版 https://github.com/coreos/flannel/releases</span><br></pre></td></tr></table></figure>

<p><strong>四、work节点安装</strong></p>
<p>   4.1镜像拉取</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker pull mirrorgooglecontainers/kube-proxy:v1.15.0</span></span><br><span class="line"><span class="comment">#docker pull mirrorgooglecontainers/pause:3.1 </span></span><br><span class="line"><span class="comment">#docker pull coredns/coredns:1.3.1</span></span><br><span class="line"><span class="comment">#docker tag mirrorgooglecontainers/kube-proxy:v1.15.0  k8s.gcr.io/kube-proxy:v1.15.0</span></span><br><span class="line"><span class="comment">#docker tag coredns/coredns:1.3.1 k8s.gcr.io/coredns:1.3.1</span></span><br><span class="line"><span class="comment">#docker tag mirrorgooglecontainers/pause:3.1  k8s.gcr.io/pause:3.1 </span></span><br><span class="line"><span class="comment">#docker rmi mirrorgooglecontainers/kube-proxy:v1.15.0</span></span><br><span class="line"><span class="comment">#docker rmi mirrorgooglecontainers/pause:3.1</span></span><br><span class="line"><span class="comment">#docker rmi coredns/coredns:1.3.1</span></span><br><span class="line"><span class="comment">#docker images</span></span><br></pre></td></tr></table></figure>

<p>   4.2加入集群</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum -y install kubeadm</span></span><br><span class="line"><span class="comment">#kubeadm join 192.168.1.100:6443 --token 16iqqc.w0j8vrrqwyq1kx7x --discovery-token-ca-cert-hash sha256:5936509b58b84c0d7fe2aad932ccb6f806a131b0cc6262304fbff4fd94192749</span></span><br><span class="line">注：如果因为没有在master执行网络附件。	</span><br><span class="line">需要重新执行加入的时候先重置命令：kubeadm reset</span><br><span class="line">加入后，在master执行kubectl get nodes READY即可</span><br></pre></td></tr></table></figure>

<p><strong>五、测试</strong></p>
<p><strong>查看各个节点得pod状态</strong></p>
<p>pod状态为Pending、ContainerCreating、ImagePullBackOff 都表明 Pod 没有就绪，Running </p>
<p>才是就绪状态。</p>
<p>如果有pod提示Init:ImagePullBackOff，说明这个pod的镜像在对应节点上拉取失败，我们可以</p>
<p>通过 kubectl describe pod 查看 Pod 具体情况，以确认拉取失败的镜像：</p>
<p>kubectl logs podnome -n kube-system查看日志</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#kubectl get pod --all-namespaces -o wide</span></span><br><span class="line"><span class="comment">#kubectl describe pod coredns-86c58d9df4-lrc44 --namespace=kube-system</span></span><br><span class="line"><span class="comment">#kubectl get componentstatus    #查看组件运行状态 </span></span><br><span class="line"><span class="comment">#kubectl get nodes  #查看各个节点的信息</span></span><br><span class="line"><span class="comment">#kubectl get ns #查看命名空间</span></span><br><span class="line"><span class="comment">#kubectl get pod -n kube-system -o wide#查看命名空间kube-system中容器的启动情况     </span></span><br><span class="line"><span class="comment">#kubectl exec pod_name -c container_name -it -- /bin/bash  #进入pod中的容器</span></span><br></pre></td></tr></table></figure>

<p><strong>六、dashboard面板管理</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker pull k8s.gcr.io/kubernetes-dashboard-amd64</span></span><br><span class="line"><span class="comment">#kubectl apply -f kubernetes-dashboard-http.yml</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ------------------- Dashboard Service Account ------------------- #</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Deployment ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: apps/v1beta2</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kubernetes-dashboard</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kubernetes-dashboard</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        node-role.kubernetes.io/master: &quot;&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubernetes-dashboard</span><br><span class="line">        image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br><span class="line">          protocol: TCP</span><br><span class="line">        args:</span><br><span class="line">          # Uncomment the following line to manually specify Kubernetes API server Host</span><br><span class="line">          # If not specified, Dashboard will attempt to auto discover the API server and connect</span><br><span class="line">          # to it. Uncomment only if the default does not work.</span><br><span class="line">          # - --apiserver-host=http://192.168.0.102:8080</span><br><span class="line">        volumeMounts:</span><br><span class="line">          # Create on-disk volume to store exec logs</span><br><span class="line">        - mountPath: /tmp</span><br><span class="line">          name: tmp-volume</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 9090</span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          timeoutSeconds: 30</span><br><span class="line">      volumes:</span><br><span class="line">      - name: tmp-volume</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">      serviceAccountName: kubernetes-dashboard</span><br><span class="line">      # Comment the following tolerations if Dashboard must not be deployed on master</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        effect: NoSchedule</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Service ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 9090</span><br><span class="line">    nodePort: 31111</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>七、命令介绍</strong></p>
<p>1.node管理</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#kubectl crodon &lt;node&gt;   //禁止Pod调度到该节点</span></span><br><span class="line"><span class="comment">#kubectl drain &lt;node&gt;  //驱逐该节点的所有Pod，在其它节点重新启动Pod，该节点是在维护时使用，该命令会自动调用kubectl crodon &lt;node&gt;命令，当kubelet 启动后，再使用kubectl uncordon &lt;node&gt; 将该节点添加到kubernetes集群。</span></span><br></pre></td></tr></table></figure>

<p>2.namesapce</p>
<p>#kubectl get ns    &#x2F;&#x2F;获取集群中的命名空间</p>
<p>集群默认有default   kube-system 两个namesapace</p>
<p>3.打标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#kubectl label pods pod-demo release=v1</span></span><br><span class="line"><span class="comment">#kubectl get pods  -l app --show-labels </span></span><br><span class="line"><span class="comment">#kubectl label pods pod-demo release=v2 --overwrite</span></span><br><span class="line"><span class="comment">#kubectl api-versions  //获取apiversion版本类别</span></span><br><span class="line"><span class="comment">#kubectl  explain pods.spce //解释</span></span><br><span class="line"><span class="comment">#kubectl exec -ti &lt;your-pod-name&gt;  -n &lt;your-namespace&gt; -c containe -- /bin/sh</span></span><br><span class="line">//进入pod</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统修改字符集</title>
    <url>/2024/03/06/linux%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#echo $LANG</span></span><br><span class="line">en_US.UTF-8</span><br><span class="line"><span class="comment">#env |grep LANG</span></span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line"><span class="comment">#locale |grep CTYPE</span></span><br><span class="line">LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br></pre></td></tr></table></figure>

<p>更改系统字符集</p>
<p>执行export LANG&#x3D;(字符集名称)</p>
<p>常用字符集：en_US.utf8、zh_CN.gb2312、zh_CN.gbk、zh_CN.utf8</p>
]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>LSOF 命令详解</title>
    <url>/2024/03/06/lsof/</url>
    <content><![CDATA[<p>lsof ［options］ filename</p>
<p>lsof  &#x2F;path&#x2F;to&#x2F;somefile：显示打开指定文件的所有进程之列表</p>
<p>lsof -c string：显示其COMMAND列中包含指定字符(string)的进程所有打开的文件；此选项可以重复使用，以指定多个模式；</p>
<p>lsof -p PID：查看该进程打开了哪些文件；进程号前可以使用脱字符“^”取反；</p>
<p>lsof -u USERNAME：显示指定用户的进程打开的文件；用户名前可以使用脱字符“^”取反，如“lsof -u ^root”则用于显示非root用户打开的所有文件；</p>
<p>lsof -g GID：显示归属gid的进程情况</p>
<p>lsof +d &#x2F;DIR&#x2F;：显示指定目录下被进程打开的文件</p>
<p>lsof +D &#x2F;DIR&#x2F;：基本功能同上，但lsof会对指定目录进行递归查找，注意这个参数要比grep版本慢：</p>
<p>lsof -a：按“与”组合多个条件，如lsof -a -c apache -u apache</p>
<p>lsof -N：列出所有NFS（网络文件系统）文件</p>
<p>lsof -d FD：显示指定文件描述符的相关进程；也可以为描述符指定一个范围，如0-2表示0,1,2三个文件描述符；另外，-d还支持其它很多特殊值，如：</p>
<p>​	mem: 列出所有内存映射文件；</p>
<p>​	mmap：显示所有内存映射设备；</p>
<p>​	txt：列出所有加载在内存中并正在执行的进程，包含code和data；</p>
<p>​	cwd：正在访问当前目录的进程列表；</p>
<p>​	</p>
<p>lsof -n：不反解IP至HOSTNAME</p>
<p>lsof -i：用以显示符合条件的进程情况</p>
<p>lsof -i[46] [protocol][@hostname|hostaddr][:service|port]</p>
<p>​	46：IPv4或IPv6</p>
<p>​	protocol：TCP or UDP</p>
<p>​	hostname：Internet host name</p>
<p>​	hostaddr：IPv4地址</p>
<p>​	service：&#x2F;etc&#x2F;service中的服务名称(可以不只一个)</p>
<p>​	port：端口号 (可以不只一个)</p>
<p>例如： 查看22端口现在运行的情况</p>
<p>[root@www ~]# lsof -i :22</p>
<p>COMMAND   PID USER   FD   TYPE DEVICE SIZE&#x2F;OFF NODE NAME</p>
<p>sshd     1390 root    3u  IPv4  13050      0t0  TCP *:ssh (LISTEN)</p>
<p>sshd     1390 root    4u  IPv6  13056      0t0  TCP *:ssh (LISTEN)</p>
<p>sshd    36454 root    3r  IPv4  94352      0t0  TCP <a href="http://www.magedu.com:ssh->172.16.0.1:50018">www.magedu.com:ssh-&gt;172.16.0.1:50018</a> (ESTABLISHED)</p>
<p>上述命令中，每行显示一个打开的文件，若不指定条件默认将显示所有进程打开的所有文件。lsof输出各列信息的意义如下：</p>
<p>​	COMMAND：进程的名称</p>
<p>​	PID：进程标识符</p>
<p>​	USER：进程所有者</p>
<p>​	FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等</p>
<p>​	TYPE：文件类型，如DIR、REG等</p>
<p>​	DEVICE：指定磁盘的名称</p>
<p>​	SIZE：文件的大小</p>
<p>​	NODE：索引节点（文件在磁盘上的标识）</p>
<p>​	NAME：打开文件的确切名称</p>
]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql8.0版本升级</title>
    <url>/2024/03/06/mysql8.0%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -pcctv.com -A &gt; zabbix.sql</span><br><span class="line">tar xf mysql-8.0.22-linux-glibc2.12-x86_64.tar.xz</span><br><span class="line">mv mysql-8.0.22-linux-glibc2.12-x86_64 mysql8</span><br><span class="line">mkdir /opt/mysqlmydata</span><br><span class="line">chown -R mysql:mysql /opt/mysql8</span><br><span class="line">chown -R mysql:mysql /opt/mysqlmydata/</span><br><span class="line">./mysqld --initialize --user=mysql --datadir=/opt/mysqlmydata/ --basedir=/opt/mysql8</span><br></pre></td></tr></table></figure>

<p>修改 &#x2F;etc&#x2F;my.cnf</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp mysql.server /etc/init.d/mysqld</span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;init.d&#x2F;mysqld</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -sv /opt/mysql8/bin/mysql /usr/bin/mysqlvi /etc/profile.d/mysql.sh </span><br></pre></td></tr></table></figure>

<p>修改 &#x2F;etc&#x2F;profile.d&#x2F;mysql.sh </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile.d/mysql.sh</span><br></pre></td></tr></table></figure>

<p>登陆数据库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use mysql</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY <span class="string">&#x27;aBxOc&amp;3CmAi5F%e9&#x27;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line">CREATE USER <span class="string">&#x27;zabbix&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;cctv.com&#x27;</span>;</span><br><span class="line">create database zabbix_proxy;</span><br><span class="line">use zabbix_proxy</span><br><span class="line"><span class="built_in">source</span> /opt/proxy.sql</span><br><span class="line">grant all privileges on zabbix_proxy.* to <span class="string">&#x27;zabbix&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从复制</title>
    <url>/2024/03/06/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>1、备份数据：</p>
<p>mysqldump -u root -p wso2esbdb &gt; &#x2F;opt&#x2F;wso2eabdb.sql</p>
<p>2、将数据文件传输至备份数据库</p>
<p>scp  wso2eabdb.sql <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#64;&#49;&#55;&#x32;&#46;&#x32;&#x38;&#x2e;&#52;&#x32;&#46;&#x33;&#54;">&#x72;&#x6f;&#x6f;&#116;&#64;&#49;&#55;&#x32;&#46;&#x32;&#x38;&#x2e;&#52;&#x32;&#46;&#x33;&#54;</a>:&#x2F;opt&#x2F;</p>
<p>3、备库删除原来的数据库</p>
<p>drop database  wso2esbdb;</p>
<p>FLUSH PRIVILEGES;</p>
<p>4、重新创建数据库</p>
<p>create database  wso2esbdb;</p>
<p>show databases;</p>
<p>5、授权</p>
<p>GRANT ALL PRIVILEGES ON wso2esbdb.* to soauser@’%’ Identified by ‘ctvit.com’;</p>
<p>FLUSH PRIVILEGES;</p>
<p>6、导入备份文件</p>
<p>use wso2esbdb;</p>
<p>source &#x2F;opt&#x2F;wso2eabdb.sql</p>
<p>7、配置主从关系</p>
<p>CHANGE MASTER TO MASTER_HOST&#x3D;’172.28.42.34’, MASTER_PORT&#x3D;3306, MASTER_LOG_FILE&#x3D;’mysql-bin.000009’, MASTER_LOG_POS&#x3D;246580397, MASTER_USER&#x3D;’slave’, MASTER_PASSWORD&#x3D;’ctvit.123’;</p>
<p>8、启动主从进程</p>
<p>start slave；</p>
<p>show slave status\G</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从搭建</title>
    <url>/2024/03/06/mysql%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>环境搭好</p>
<p>182  183</p>
<p>182用户授权</p>
<p>mysql&gt;grant all on <em>.</em> to <a href="mailto:&#117;&#x73;&#101;&#x72;&#64;&#49;&#57;&#x32;&#46;&#49;&#54;&#x38;&#46;&#48;&#46;&#x31;&#56;&#51;">&#117;&#x73;&#101;&#x72;&#64;&#49;&#57;&#x32;&#46;&#49;&#54;&#x38;&#46;&#48;&#46;&#x31;&#56;&#51;</a> identified by ‘user’</p>
<p>查看bin-log</p>
<p>&#x2F;mnt&#x2F;sdb&#x2F;mysql&#x2F;bin&#x2F;mysqlbinlog mysql-bin.000001 |more;</p>
<p>flush logs;  刷新日志</p>
<p>show master  status; 查看最后一条</p>
<p>reset master; 清空</p>
<p>修改my.cnf</p>
<p>log-bin&#x3D;mysql-bin</p>
<p>server-id&#x3D;1</p>
<p>读锁定</p>
<p>flush tables with read lock</p>
<p>解锁</p>
<p>unlock tables;</p>
<p>备份数据</p>
<p>mysqldump -uroot -proot test -l -F &gt; test.sql -F 即 flush logs;</p>
<p>恢复</p>
<p>mysql -uroot -proot test -v -f &lt;test.sql -v 详细信息 -f skip错误</p>
<p>定点恢复</p>
<p>mysqlbinlog –no-defaults –start-postion&#x3D;”222” –stop-postion&#x3D;”333” mysql-bin.000004|mysql-uroot-proot test</p>
<p>在主服务器上建立账户并授权 slave;</p>
<p>mysql]# mysql -uroot -p*******</p>
<p>grant replication slave on <em>.</em> to ‘slave‘@’10.23.122.19%’ identified by ‘q123456’; </p>
<p>6.登录主服务器的mysql,查询master的状态</p>
<p>mysql&gt;show master status\G PS:这里的\G后面不加；要不会报错 </p>
<p>7.配置从服务器Slave；</p>
<p>mysql&gt; stop slave; (PS:如果不执行这句话，下面会报错的）</p>
<p>mysql&gt; Change master to master_host&#x3D;’10.23.124.68’,master_user&#x3D;’slave’,master_password&#x3D;’q123456’,</p>
<p>-&gt; master_log_file&#x3D;’mysql-bin.000001’,</p>
<p>-&gt; master_log_pos&#x3D;120;</p>
<p>(PS:这里master_log_file的值是6 查询出来的值，这里master_log_pos的值是6 查询出来的值，)</p>
<p>mysql&gt; start slave;&#x2F;&#x2F; 启动二进制复制</p>
<p>\8. 查看从服务器的状态 Slave ；</p>
<p>mysql&gt; show slave status\G </p>
<p>mysql 分区技术</p>
<p>range 分区</p>
<p>create table employees (id int not null,fname varchar(30),lname varchar(30),hired date not null default ‘1970-01-01’,separated date not null default ‘9999-12-31’,job_code int not null,store_id int not null ) partition by range (store_id)( partition p0 values less than(6), partition p1 values less than(11), partition p2 values less than(16), partition p3 values less than(21) );</p>
<p>list分区</p>
<p>partition by list(store_id)(</p>
<p>partition pN values in (3,5,7,9),</p>
<p>….</p>
<p>);</p>
<p>hast分区 </p>
<p>主要用于测试 确保数据在预先确定的数目的分区的平均分布</p>
<p>create table t2(id int) engine&#x3D;myisam partition by hash(id) partitions 5;</p>
<p>key分区</p>
<p>其中innodb </p>
<p>独立表空间和共享表空间</p>
<p>设置成独立的表空间才能创建innodb表引擎的表分区</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql双主搭建</title>
    <url>/2024/03/06/mysql%E5%8F%8C%E4%B8%BB/</url>
    <content><![CDATA[<p>———————————————–mysql双主</p>
<p><strong>共同：</strong></p>
<p>cat &#x2F;etc&#x2F;my.cnf</p>
<p>[mysqld]</p>
<p>#skip-grant-tables</p>
<p># DO NOT MODIFY, Universe will generate this part</p>
<p>port &#x3D; 3306</p>
<p>server_id &#x3D; 2</p>
<p>basedir &#x3D; &#x2F;opt&#x2F;mysql</p>
<p>datadir &#x3D; &#x2F;opt&#x2F;mysqldata</p>
<p>log_bin &#x3D; &#x2F;opt&#x2F;mysqldata&#x2F;mysql-bin</p>
<p># BINLOG</p>
<p>binlog_error_action &#x3D; ABORT_SERVER</p>
<p>binlog_format &#x3D; row</p>
<p>binlog_rows_query_log_events &#x3D; 1</p>
<p>log_slave_updates &#x3D; 1</p>
<p>master_info_repository &#x3D; TABLE</p>
<p>max_binlog_size &#x3D; 1024M</p>
<p>relay_log &#x3D; mysql-relay-bin</p>
<p>relay_log_info_repository &#x3D; TABLE</p>
<p>relay_log_recovery &#x3D; 1</p>
<p>sync_binlog &#x3D; 1</p>
<p>sync_relay_log &#x3D; 1</p>
<p># GTID #</p>
<p>gtid_mode &#x3D; ON</p>
<p>enforce_gtid_consistency &#x3D; 1</p>
<p># ENGINE</p>
<p>default_storage_engine &#x3D; InnoDB</p>
<p>innodb_buffer_pool_size &#x3D; 2048M</p>
<p>innodb_data_file_path &#x3D; ibdata1:1G:autoextend</p>
<p>innodb_file_per_table &#x3D; 1</p>
<p>innodb_flush_log_at_trx_commit&#x3D;1</p>
<p>innodb_flush_method &#x3D; O_DIRECT</p>
<p>innodb_io_capacity &#x3D; 200</p>
<p>innodb_log_buffer_size &#x3D; 64M</p>
<p>innodb_log_file_size &#x3D; 1024M</p>
<p>innodb_log_files_in_group &#x3D; 2</p>
<p>innodb_max_dirty_pages_pct &#x3D; 60</p>
<p>innodb_print_all_deadlocks&#x3D;1</p>
<p>innodb_stats_on_metadata &#x3D; 0</p>
<p>innodb_strict_mode &#x3D; 1</p>
<p># CACHE</p>
<p>key_buffer_size &#x3D; 32M</p>
<p>tmp_table_size &#x3D; 32M</p>
<p>max_heap_table_size &#x3D; 32M</p>
<p>table_open_cache &#x3D; 1024</p>
<p>query_cache_type &#x3D; 0</p>
<p>query_cache_size &#x3D; 0</p>
<p>max_connections &#x3D; 1000</p>
<p>thread_cache_size &#x3D; 1024</p>
<p>open_files_limit &#x3D; 65535</p>
<p># SLOW LOG</p>
<p>slow_query_log &#x3D; 1</p>
<p>slow_query_log_file &#x3D; mysql-slow.log</p>
<p>log_slow_admin_statements &#x3D; 1</p>
<p>log_slow_slave_statements &#x3D; 1</p>
<p>long_query_time  &#x3D; 1</p>
<p>#Rplication</p>
<p>binlog-do-db&#x3D;portal_test</p>
<p>binlog-do-db&#x3D;portal_cctv</p>
<p>binlog-ignore-db&#x3D;mysql</p>
<p>binlog-ignore-db&#x3D;test</p>
<p>binlog-ignore-db&#x3D;information-schema</p>
<p># SEMISYNC #</p>
<p>plugin_load &#x3D; “rpl_semi_sync_master&#x3D;semisync_master.so;rpl_semi_sync_slave&#x3D;semisync_slave.so”</p>
<p>rpl_semi_sync_master_enabled &#x3D; 1</p>
<p>rpl_semi_sync_slave_enabled &#x3D; 0</p>
<p>rpl_semi_sync_master_wait_for_slave_count &#x3D; 1</p>
<p>rpl_semi_sync_master_wait_no_slave &#x3D; 0</p>
<p>rpl_semi_sync_master_timeout &#x3D; 300000 # 5 minutes</p>
<p># CLIENT_DEPRECATE_EOF</p>
<p>session_track_schema &#x3D; 1</p>
<p>session_track_state_change &#x3D; 1</p>
<p>session_track_system_variables &#x3D; ‘*’</p>
<p># MISC</p>
<p>character_set_server &#x3D; utf8</p>
<p>log_timestamps&#x3D;SYSTEM</p>
<p>lower_case_table_names &#x3D; 1</p>
<p>max_allowed_packet &#x3D; 64M</p>
<p>read_only &#x3D; 0</p>
<p>skip_external_locking&#x3D;1</p>
<p>skip_name_resolve &#x3D; 1</p>
<p>skip_slave_start &#x3D; 1</p>
<p>#socket &#x3D; &#x2F;opt&#x2F;mysqldata&#x2F;mysqld.sock</p>
<p>#pid_file &#x3D; &#x2F;opt&#x2F;mysqldata&#x2F;mysqld.pid</p>
<p>cp support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld </p>
<p>.&#x2F;bin&#x2F;mysqld –defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf –user&#x3D;mysql –datadir&#x3D;&#x2F;mydata&#x2F;data –basedir&#x3D;&#x2F;opt&#x2F;mysql –initialize –lc-messages_dir&#x3D;&#x2F;opt&#x2F;mysql&#x2F;share</p>
<p><strong>node5:</strong></p>
<p>grant replication slave on <em>.</em> to ‘node5‘@’192.168.1.%’ identified by ‘node5’; </p>
<p><strong>node6:</strong></p>
<p>stop slave;</p>
<p>change master to master_host&#x3D;’192.168.1.5’,master_user&#x3D;’node5’,master_password&#x3D;’node5’,master_auto_position&#x3D;1;</p>
<p>start slave;</p>
<p><strong>node6:</strong></p>
<p>grant replication slave on <em>.</em> to ‘node6‘@’192.168.1.%’ identified by ‘node6’; </p>
<p><strong>node5:</strong></p>
<p>stop slave;</p>
<p>change master to master_host&#x3D;’192.168.1.6’,master_user&#x3D;’node6’,master_password&#x3D;’node6’,master_auto_position&#x3D;1;</p>
<p>start slave;</p>
<p>————————————————————-keepalived</p>
<p>#tar xf keepalived-1.4.4.tar.gz</p>
<p>#yum -y install openssl-devel  openssl</p>
<p>#.&#x2F;configure –prefix&#x3D;&#x2F;opt&#x2F;keepalived</p>
<p>#make &amp;&amp; make install</p>
<p>#cp sbin&#x2F;keepalived &#x2F;etc&#x2F;init.d&#x2F;</p>
<p>#cp etc&#x2F;sysconfig&#x2F;keepalived &#x2F;etc&#x2F;sysconfig&#x2F;</p>
<p>#mkdir &#x2F;etc&#x2F;keepalived</p>
<p>#cp etc&#x2F;keepalived&#x2F;keepalived.conf &#x2F;etc&#x2F;keepalived&#x2F;</p>
<p>#cp sbin&#x2F;keepalived &#x2F;usr&#x2F;sbin&#x2F;</p>
<p>#echo “&#x2F;etc&#x2F;init.d&#x2F;keepalived “ &gt;&gt;&#x2F;etc&#x2F;rc.local </p>
<p>#cat &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</p>
<p>! Configuration file for keepalived</p>
<p>vrrp_script chk_mysql {</p>
<p>   script “&#x2F;etc&#x2F;keepalived&#x2F;check_mysql.sh”</p>
<p>   interval 5</p>
<p>   fall 3</p>
<p>   rise 3</p>
<p>   }</p>
<p>vrrp_instance V_mysql_1 {</p>
<p>​    state BACKUP</p>
<p>​    interface  eno16777736</p>
<p>​    virtual_router_id 4</p>
<p>​    priority 80</p>
<p>​    advert_int 1</p>
<p>​    nopreempt</p>
<p>​    authentication {</p>
<p>​       auth_type PASS</p>
<p>​       auth_pass 1111</p>
<p>​    }</p>
<p>​    track_script {</p>
<p>​    chk_mysql</p>
<p>​    }</p>
<p>​    virtual_ipaddress {</p>
<p>​      192.168.1.100</p>
<p>​    }</p>
<p>}</p>
<p>#cat check_mysql.sh </p>
<p>counter&#x3D;$(ss -na|grep “LISTEN”|grep “3306”|wc -l)</p>
<p>if [ “${counter}” -eq 0 ]; then</p>
<p>​        pkill -9 keepalived</p>
<p>fi</p>
<p><strong>!!!注意  virtual_router_id 一样 否则可能会造成抢占VIP</strong></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用语法</title>
    <url>/2024/03/06/mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h5 id="mysql表复制"><a href="#mysql表复制" class="headerlink" title="mysql表复制"></a>mysql表复制</h5><p>mysql &gt;create table t2 like t1;</p>
<p>mysql &gt;insert into t2 select * from t1;</p>
<h5 id="mysql表索引"><a href="#mysql表索引" class="headerlink" title="mysql表索引"></a>mysql表索引</h5><p>create index index_t1 on t1(name);</p>
<p>show index from t1\G</p>
<p>drop index index_t1 on t1;</p>
<p>创建索引</p>
<p>alter table t1 add index in_name (name);</p>
<p>alter table t1 drop index in_name;</p>
<p>删除主键索引</p>
<p>alter table t1 modify id int unsigned not null;</p>
<p>alter table t1 drop primary key;</p>
<p>创建唯一索引</p>
<p>alter table t1 add unique(name);</p>
<p>alter table t1 add unique un_name(name);</p>
<p>删除唯一索引</p>
<p>alter table t1 drop index un_name;</p>
<p>alter table t1 drop index un_name;</p>
<p>创建主键索引</p>
<p>alter table t1 add primary key(id)；</p>
<p>alter table t1 modify id int unsigned not null auto_increment;</p>
<h5 id="mysql视图"><a href="#mysql视图" class="headerlink" title="mysql视图"></a>mysql视图</h5><p>创建视图</p>
<p>create view v_t1 as select * from t1 where id&gt;2 and id&lt;5;</p>
<p>删除视图</p>
<p>drop vied v_t1;</p>
<h5 id="mysql内置函数"><a href="#mysql内置函数" class="headerlink" title="mysql内置函数"></a>mysql内置函数</h5><p>字符串</p>
<p>concat(string,[]) &#x2F;&#x2F;连接自串</p>
<p>lcase(string) &#x2F;&#x2F;转换成小写</p>
<p>ucase(string) &#x2F;&#x2F;转换成大写</p>
<p>length(string)&#x2F;&#x2F;长度</p>
<p>ltrim(string)&#x2F;&#x2F;左边去空</p>
<p>rtrim(string)&#x2F;&#x2F;右去空</p>
<p>repeat(string,count) &#x2F;&#x2F;重复count次</p>
<p>replace(str,search_str,replace_str) &#x2F;&#x2F;在str中的replace_str替换成search_str</p>
<p>space(count)&#x2F;&#x2F;生成空格</p>
<p>substring(str,pos,[length])&#x2F;&#x2F;从pos开始取length 长度</p>
<p>数学函数</p>
<p>bin(decimal_number)&#x2F;&#x2F;十进制转二进制</p>
<p>ceiling(num) 向上取整</p>
<p>floor(num) 向下取整</p>
<p>max(col) &#x2F;&#x2F;聚合取大</p>
<p>min(col)&#x2F;&#x2F;聚合取小</p>
<p>sqrt(num)&#x2F;&#x2F;开平方</p>
<p>日期函数</p>
<p>curdata()&#x2F;&#x2F;目前日期</p>
<p>crutime()&#x2F;&#x2F;目前时间</p>
<p>now()&#x2F;&#x2F;目前时间日期</p>
<p>unix_timestamp(date)&#x2F;&#x2F;返回当前date的unix时间戳</p>
<p>from_unixtime()&#x2F;&#x2F;返回unix时间戳的日期</p>
<p>week(date)&#x2F;&#x2F;返回第几周</p>
<p>year(“1992-02-02”)&#x2F;&#x2F;返回年</p>
<p>datediff(expr,expr2)&#x2F;&#x2F;返回起始时间差天数</p>
<p>rand()&#x2F;&#x2F;返回0-1的随机数</p>
<h5 id="mysql预处理语句"><a href="#mysql预处理语句" class="headerlink" title="mysql预处理语句"></a>mysql预处理语句</h5><p>? prepare</p>
<p>prepare stmt1 from ‘select from t1 where id&gt;?’;</p>
<p>set @i&#x3D;5;</p>
<p>select @i;</p>
<p>execute stmt1 using @i &#x2F;&#x2F;使用</p>
<p>drop prepare stmt1 &#x2F;&#x2F;删除</p>
<h5 id="mysql事务处理"><a href="#mysql事务处理" class="headerlink" title="mysql事务处理"></a>mysql事务处理</h5><p>myISAM引擎不支持  innodb支持</p>
<p>数据回滚</p>
<p>set autocommit&#x3D;0 关闭自动提交功能</p>
<p>delete from t1 where id&#x3D;2;</p>
<p>savepoint p1;</p>
<p>delete from t1 where id&#x3D;3;</p>
<p>savepoint p2;</p>
<p>rollback to p1;还原到p1还原点</p>
<p>rollback;最初还原点</p>
<h5 id="mysql存储"><a href="#mysql存储" class="headerlink" title="mysql存储"></a>mysql存储</h5><p>? procedure;&#x2F;&#x2F;类似函数</p>
<p>\d &#x2F;&#x2F; 修改定界符</p>
<p>create procedure p2()</p>
<p>begin</p>
<p>set @i&#x3D;3;</p>
<p>where @i&lt;&#x3D;100 do</p>
<p>insert into t2(name) values(concat(“user”,@i));</p>
<p>set @i&#x3D;@i+1；</p>
<p>end while;</p>
<p>end &#x2F;&#x2F;</p>
<p>\d ;  改回定界符</p>
<p>show procedure status\G;</p>
<p>call p2; 调用存储</p>
<p>select * from t2; 查看 </p>
<h5 id="mysql触发器"><a href="#mysql触发器" class="headerlink" title="mysql触发器"></a>mysql触发器</h5><p>? trigger;</p>
<p>#制造一个同时插入 t1 t2</p>
<p>\d &#x2F;&#x2F;</p>
<p>create trigger t1 before insert on t1 for each row</p>
<p>begin</p>
<p>insert into t2(id) values(new.id);</p>
<p>end&#x2F;&#x2F;</p>
<p>\d ; 改回定界符</p>
<p>show triggers; 查看</p>
<p>insert into t1(id) values(1);</p>
<p>#删除</p>
<p>\d &#x2F;&#x2F;</p>
<p>create trigger t2 before delete on t1 for each row</p>
<p>begin</p>
<p>delete from t2 where id&#x3D;old.id;</p>
<p>end&#x2F;&#x2F;</p>
<p>\d ;</p>
<p>#修改</p>
<p>\d &#x2F;&#x2F;</p>
<p>create trigger t3 before uptate on t1 for each row</p>
<p>begin update t2 set id&#x3D;new.id where id&#x3D;old.id;</p>
<p>end&#x2F;&#x2F;</p>
<p>\d ;</p>
<h5 id="重排auto-increment值"><a href="#重排auto-increment值" class="headerlink" title="重排auto_increment值"></a>重排auto_increment值</h5><p>alter table tablename auto_increment&#x3D;1;</p>
<h5 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h5><p>group by  与with rollup一起使用</p>
<p>select cname,pname,count(cname) from t1 group by cname,pname with rollup;</p>
<h5 id="sql语句优化"><a href="#sql语句优化" class="headerlink" title="sql语句优化"></a>sql语句优化</h5><p>show status like “com%”;&#x2F;&#x2F;增删改查相关记录</p>
<p>show status like “innodb_rows%”&#x2F;&#x2F;影响行数</p>
<p>show status like “connections”&#x2F;&#x2F;连接mysql次数（无论成功与否）</p>
<p>show status like “uptime”&#x2F;&#x2F;启动时间</p>
<p>show status like “slow_qureies”;&#x2F;&#x2F;慢查询次数</p>
<p>show variables like “%slow_query%”;&#x2F;&#x2F;查询相关配置开启与否 查询慢查询是否开启</p>
<p>看慢查询日志</p>
<p>索引优化</p>
<p>check table sales;&#x2F;&#x2F;检查表错误</p>
<p>optimize table sales;&#x2F;&#x2F;优化表空间</p>
<p>数据导入导出 优化</p>
<p>mysql&gt;select name from t1 into outfile  “&#x2F;tmp&#x2F;test.txt”;</p>
<p>mysql&gt;load data infile “&#x2F;tmp&#x2F;test.txt” into table t1(name);</p>
<p>myisam引擎存储的表</p>
<p>mysql&gt;alter table t1 disable keys;</p>
<p>mysql&gt;load data infile “&#x2F;tmp&#x2F;test.txt” into table t1(name);</p>
<p>mysql&gt;alter table t1 enable keys;</p>
<p>确保数据没有重复可以关闭唯一索引 可以提高导入效率&#x2F;&#x2F;慎用</p>
<p>set unique_checks&#x3D;0  &#x2F;&#x2F;关闭</p>
<p>set unique_checks&#x3D;1   &#x2F;&#x2F;开启</p>
<p>innodb导入优化</p>
<p>按照逐渐顺序保存的 可以将导入的数据主键的顺序排列，可以有效提高导入速率</p>
<p>set autocommit&#x3D;0;关闭自动提交可以提高速率</p>
<p>insert 优化</p>
<p>数据库的连接关闭等</p>
<p>group by优化</p>
<p>避免嵌套查询</p>
<p>数据库优化</p>
<p>优化表的类型</p>
<p>通过拆分提高表的访问率 分区 分表 主从数据库</p>
<p>使用中间表提高统计查询速度  –视图</p>
<p>mysql服务器优化</p>
<p>myisam读锁定（都不能写，可以读）</p>
<p>lock table t1 read;</p>
<p>myisam写锁定(谁也写不了读不了，除了本人)</p>
<p>lock table t1 write;</p>
<p>解锁 unlock tables;</p>
<p>四种字符集</p>
<p>Server characterset utf8</p>
<p>db characterset utf8</p>
<p>client  characterset utf8</p>
<p>conn  characterset utf8</p>
<p>如何设置</p>
<p>&#x2F;etc&#x2F;my.cnf</p>
<p>default-character-set&#x3D;utf8</p>
<p>[mysqld]</p>
<p>character-set-server &#x3D; utf8</p>
<p>collation-server &#x3D; utf8_general_ci &#x2F;&#x2F;校验字符集</p>
<p>binary log 日志</p>
<p>cat &#x2F;etc&#x2F;my.cnf</p>
<p>log-bin&#x3D;mysql-bin</p>
<p>slow log 日志</p>
<p>cat &#x2F;etc&#x2F;my.cnf</p>
<p>log_slow_queries&#x3D;slow.log</p>
<p>long_query_time&#x3D;5</p>
<p>socket问题</p>
<p>没有socket 可尝试用tcp连接</p>
<p>mysql -uroot -proot –protocol tcp -hlocalhost </p>
<p>root密码丢失无法登陆</p>
<p>mysqld_safe –skip-grant-tables –user&#x3D;mysql &amp;</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库大小查看</title>
    <url>/2024/03/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E5%B0%8F%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/yuwensong/p/7729267.html">用SQL命令查看Mysql数据库大小</a></p>
<p>要想知道每个数据库的大小的话，步骤如下：</p>
<p>1、进入information_schema 数据库（存放了其他的数据库的信息）</p>
<p>use information_schema;</p>
<p>2、查询所有数据的大小：</p>
<p>select concat(round(sum(data_length&#x2F;1024&#x2F;1024),2),’MB’) as data from tables;</p>
<p>3、查看指定数据库的大小：</p>
<p>比如查看数据库home的大小</p>
<p>select concat(round(sum(data_length&#x2F;1024&#x2F;1024),2),’MB’) as data from tables where table_schema&#x3D;’home’;</p>
<p>4、查看指定数据库的某个表的大小</p>
<p>比如查看数据库home中 members 表的大小</p>
<p>select concat(round(sum(data_length&#x2F;1024&#x2F;1024),2),’MB’) as data from tables where table_schema&#x3D;’home’ and table_name&#x3D;’members’;</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>raid10制作</title>
    <url>/2024/03/06/raid10/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1[root@linuxprobe ~]<span class="comment"># mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde</span></span><br><span class="line"></span><br><span class="line">2[root@linuxprobe ~]<span class="comment"># mkfs.ext4 /dev/md0</span></span><br><span class="line"></span><br><span class="line">3[root@linuxprobe ~]<span class="comment"># mkdir /RAID</span></span><br><span class="line"> [root@linuxprobe ~]<span class="comment"># mount /dev/md0 /RAID</span></span><br><span class="line"> [root@linuxprobe ~]<span class="comment"># df -h</span></span><br><span class="line"></span><br><span class="line">4[root@linuxprobe ~]<span class="comment"># mdadm -D /dev/md0 查看</span></span><br><span class="line"></span><br><span class="line">5损坏修复</span><br><span class="line">[root@linuxprobe ~]<span class="comment"># mdadm /dev/md0 -f /dev/sdb</span></span><br><span class="line">[root@linuxprobe ~]<span class="comment"># mdadm -D /dev/md0</span></span><br><span class="line">[root@linuxprobe ~]<span class="comment"># umount /RAID</span></span><br><span class="line">[root@linuxprobe ~]<span class="comment"># mdadm /dev/md0 -a /dev/sdb</span></span><br><span class="line">[root@linuxprobe ~]<span class="comment"># mdadm -D /dev/md0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>系统</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>redis部署</title>
    <url>/2024/03/06/redis/</url>
    <content><![CDATA[<p>redis 4.0.8 cluster 安装 需要ruby2.2.2+</p>
<p>1.wget <a href="http://download.redis.io/releases/redis-4.0.10.tar.gz">http://download.redis.io/releases/redis-4.0.10.tar.gz</a></p>
<p>2.tar xf redis-4.0.8.tar.gz -C &#x2F;opt&#x2F;redis&#x2F; –strip-components&#x3D;1</p>
<p>3.yum -y install gcc make tcl</p>
<p>4.cd &#x2F;opt&#x2F;redis&#x2F;src &amp;&amp; make MALLOC&#x3D;libc （默认值为libc）&amp;&amp; make </p>
<p>5.安装ruby 2.2.2+ &amp;&amp; gem install redis</p>
<p>6.cd .. &amp;&amp; mkdir -p cluster&#x2F;{6379..6384}</p>
<p>7.cp redis.conf redis.conf.bak</p>
<p>8.vim redis.conf</p>
<p>​	bind 192.168.203.13</p>
<p>​	protected-mode yes</p>
<p>​	port 6379</p>
<p>​	tcp-backlog 511</p>
<p>​	timeout 0</p>
<p>​	tcp-keepalive 300</p>
<p>​	daemonize yes	&#x2F;&#x2F;后台运行</p>
<p>​	supervised no</p>
<p>​	pidfile &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;6379&#x2F;redis_6379.pid</p>
<p>​	loglevel notice</p>
<p>​	logfile “&#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;6379&#x2F;redis_6379.log”</p>
<p>​	databases 16</p>
<p>​	always-show-logo yes</p>
<p>​	save 900 1</p>
<p>​	save 300 10</p>
<p>​	save 60 10000</p>
<p>​	stop-writes-on-bgsave-error yes</p>
<p>​	rdbcompression yes</p>
<p>​	rdbchecksum yes</p>
<p>​	dbfilename dump.rdb</p>
<p>​	dir &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;6379&#x2F;</p>
<p>​	# slaveof 192.168.203.13 6379 &#x2F;&#x2F;cluster不允许</p>
<p>​	slave-serve-stale-data yes</p>
<p>​	slave-read-only yes</p>
<p>​	repl-diskless-sync no</p>
<p>​	repl-diskless-sync-delay 5</p>
<p>​	repl-disable-tcp-nodelay no</p>
<p>​	slave-priority 100</p>
<p>​	maxmemory 5368709120 &#x2F;&#x2F;最大使用5G内存，给系统预留3G内存</p>
<p>​	maxmemory-policy volatile-lru	&#x2F;&#x2F;只对设置了过期时间的key进行LRU（默认值）</p>
<p>​	maxmemory-samples 5	&#x2F;&#x2F;default</p>
<p>​	lazyfree-lazy-eviction no</p>
<p>​	lazyfree-lazy-expire no</p>
<p>​	lazyfree-lazy-server-del no</p>
<p>​	slave-lazy-flush no</p>
<p>​	appendonly yes	&#x2F;&#x2F;提供更好的数据持久性保障</p>
<p>​	appendfilename “appendonly.aof”</p>
<p>​	appendfsync everysec	&#x2F;&#x2F;everysec：每秒钟同步一次，折中的方案。</p>
<p>​	no-appendfsync-on-rewrite no</p>
<p>​	auto-aof-rewrite-percentage 100</p>
<p>​	auto-aof-rewrite-min-size 64mb</p>
<p>​	aof-load-truncated yes</p>
<p>​	aof-use-rdb-preamble no</p>
<p>​	lua-time-limit 5000</p>
<p>​	cluster-enabled yes</p>
<p>​	cluster-config-file nodes-6379.conf	&#x2F;&#x2F;cluster 自主管理的配置文件</p>
<p>​	cluster-node-timeout 15000</p>
<p>​	cluster-slave-validity-factor 10</p>
<p>​	slowlog-log-slower-than 10000</p>
<p>​	slowlog-max-len 128</p>
<p>​	latency-monitor-threshold 0</p>
<p>​	notify-keyspace-events “”</p>
<p>​	hash-max-ziplist-entries 512</p>
<p>​	hash-max-ziplist-value 64</p>
<p>​	list-max-ziplist-size -2</p>
<p>​	list-compress-depth 0</p>
<p>​	set-max-intset-entries 512</p>
<p>​	zset-max-ziplist-entries 128</p>
<p>​	zset-max-ziplist-value 64</p>
<p>​	hll-sparse-max-bytes 3000</p>
<p>​	activerehashing yes</p>
<p>​	client-output-buffer-limit normal 0 0 0</p>
<p>​	client-output-buffer-limit slave 256mb 64mb 60</p>
<p>​	client-output-buffer-limit pubsub 32mb 8mb 60</p>
<p>​	hz 10</p>
<p>​	aof-rewrite-incremental-fsync yes</p>
<p>9.for i in {6379..6384}; do cp redis.conf cluster&#x2F;$i&#x2F;$i.conf; done</p>
<p>10.for i in {6379..6384}; do sed -i “s&#x2F;6379&#x2F;$i&#x2F;g” cluster&#x2F;$i&#x2F;$i.conf; done	&#x2F;&#x2F;放置配置文件</p>
<p>11.vim &#x2F;etc&#x2F;security&#x2F;limits.conf &#x2F;&#x2F;追加如下行（设置ulimit）</p>
<p>​	*               soft    noproc  10240</p>
<p>​	*               hard    noproc  10240</p>
<p>​	*               soft    nofile  10240</p>
<p>​	*               hard    nofile  10240</p>
<p>12.for i in {6379..6384}; do sed -i &#x2F;opt&#x2F;redis&#x2F;src&#x2F;redis-server &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;$i&#x2F;$i.conf; done &#x2F;&#x2F;启动redis</p>
<p>13.&#x2F;opt&#x2F;redis&#x2F;src&#x2F;redis-trib.rb create –replicas 1 192.168.203.13:6379 192.168.203.13:6380 192.168.203.13:6381 192.168.203.13:6382 192.168.203.13:6383 192.168.203.13:6384  &#x2F;&#x2F;创建集群</p>
<p>14.echo for i in {6379..6384}; do &#x2F;opt&#x2F;redis&#x2F;src&#x2F;redis-server &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;$i&#x2F;$i.conf; done &gt;&gt; &#x2F;etc&#x2F;rc.local &#x2F;&#x2F;开机自启</p>
<p>参考文档：</p>
<p>​	<a href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial</a></p>
<p>​	<a href="https://blog.csdn.net/ljl890705/article/details/51039015">https://blog.csdn.net/ljl890705/article/details/51039015</a></p>
<p>&#x2F;*	初始化redis cluter *&#x2F;</p>
<p>​	for i in {6379..6384}; do &#x2F;opt&#x2F;redis&#x2F;src&#x2F;redis-cli -h 192.168.205.55 -p $i shutdown; done</p>
<p>​	for i in {6379..6384}; do rm -rf &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;*; done</p>
<p>​	mkdir -p &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;{6379..6384}</p>
<p>​	for i in {6379..6384}; do cp &#x2F;opt&#x2F;redis&#x2F;redis.conf &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;$i&#x2F;$i.conf; done</p>
<p>​	for i in {6379..6384}; do sed -i “s&#x2F;6379&#x2F;$i&#x2F;g” &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;$i&#x2F;$i.conf; done</p>
<p>&#x2F; * 启动redis cluster *&#x2F;</p>
<p>for i in {6379..6384}; do &#x2F;opt&#x2F;redis&#x2F;src&#x2F;redis-server &#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;$i&#x2F;$i.conf; done &amp;&amp; \</p>
<p>&#x2F;opt&#x2F;redis&#x2F;src&#x2F;redis-trib.rb create –replicas 1 192.168.205.55:6379 192.168.205.55:6380 192.168.205.55:6381 192.168.205.55:6382 192.168.205.55:6383 192.168.205.55:6384</p>
<p>&#x2F;&#x2F; 输入yes 默认前三个为主，后三个为从</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 单机持久化</title>
    <url>/2024/03/06/redis%E5%8D%95%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>1.安装</p>
<p>yum -y install gcc make tcl &#x2F;&#x2F;安装依赖</p>
<p>wget <a href="http://download.redis.io/releases/redis-4.0.X.tar.gz">http://download.redis.io/releases/redis-4.0.X.tar.gz</a></p>
<p>tar xf redis-4.0.8.tar.gz -C &#x2F;opt&#x2F;redis&#x2F; –strip-components&#x3D;1</p>
<p>cd &#x2F;opt&#x2F;redis&#x2F;src &amp;&amp; make MALLOC&#x3D;libc</p>
<p>2.优化系统参数</p>
<p>vim &#x2F;etc&#x2F;sysctl.d&#x2F;redis.conf</p>
<p>​	vm.overcommit_memory &#x3D; 1</p>
<p>​	net.core.somaxconn &#x3D; 1024</p>
<p>sysctl –system</p>
<p>echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</p>
<p>vim &#x2F;etc&#x2F;rc.local</p>
<p>​	echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</p>
<p>​	&#x2F;opt&#x2F;redis&#x2F;src&#x2F;redis-server &#x2F;opt&#x2F;redis&#x2F;redis.conf  &#x2F;&#x2F;开机自启</p>
<p>chmod +x &#x2F;etc&#x2F;rc.d&#x2F;rc.local</p>
<p>3.修改配置文件</p>
<p>cd &#x2F;opt&#x2F;redis</p>
<p>mv redis.conf redis.conf.bak</p>
<p>vim redis.conf</p>
<p>​	bind 192.168.203.13	&#x2F;&#x2F;修改为本机地址（ip add 查看）</p>
<p>​	protected-mode yes</p>
<p>​	port 6379</p>
<p>​	tcp-backlog 511</p>
<p>​	timeout 0</p>
<p>​	tcp-keepalive 300</p>
<p>​	daemonize yes	&#x2F;&#x2F;后台运行</p>
<p>​	supervised no</p>
<p>​	pidfile &#x2F;opt&#x2F;redis&#x2F;redis_6379.pid</p>
<p>​	loglevel notice</p>
<p>​	logfile “&#x2F;opt&#x2F;redis&#x2F;cluster&#x2F;redis_6379.log”</p>
<p>​	databases 16</p>
<p>​	always-show-logo yes</p>
<p>​	save 900 1</p>
<p>​	save 300 10</p>
<p>​	save 60 10000</p>
<p>​	stop-writes-on-bgsave-error yes</p>
<p>​	rdbcompression yes</p>
<p>​	rdbchecksum yes</p>
<p>​	dbfilename dump.rdb</p>
<p>​	dir &#x2F;opt&#x2F;redis&#x2F;</p>
<p>​	# slaveof 192.168.203.13 6379 &#x2F;&#x2F; slave 设置为 master的地址及端口</p>
<p>​	slave-serve-stale-data yes</p>
<p>​	slave-read-only yes</p>
<p>​	repl-diskless-sync no</p>
<p>​	repl-diskless-sync-delay 5</p>
<p>​	repl-disable-tcp-nodelay no</p>
<p>​	slave-priority 100</p>
<p>​	maxmemory 5368709120 &#x2F;&#x2F;最大使用5G内存，给系统预留3G内存,根据系统内存设定，一般设置为系统内存的50%</p>
<p>​	maxmemory-policy volatile-lru	&#x2F;&#x2F;只对设置了过期时间的key进行LRU（默认值）</p>
<p>​	maxmemory-samples 5	&#x2F;&#x2F;default</p>
<p>​	lazyfree-lazy-eviction no</p>
<p>​	lazyfree-lazy-expire no</p>
<p>​	lazyfree-lazy-server-del no</p>
<p>​	slave-lazy-flush no</p>
<p>​	appendonly yes	&#x2F;&#x2F;提供更好的数据持久性保障</p>
<p>​	appendfilename “appendonly.aof”</p>
<p>​	appendfsync everysec	&#x2F;&#x2F;everysec：每秒钟同步一次，折中的方案。</p>
<p>​	no-appendfsync-on-rewrite no</p>
<p>​	auto-aof-rewrite-percentage 100</p>
<p>​	auto-aof-rewrite-min-size 64mb</p>
<p>​	aof-load-truncated yes</p>
<p>​	aof-use-rdb-preamble no</p>
<p>​	lua-time-limit 5000</p>
<p>​	cluster-enabled no</p>
<p>​	slowlog-log-slower-than 10000</p>
<p>​	slowlog-max-len 128</p>
<p>​	latency-monitor-threshold 0</p>
<p>​	notify-keyspace-events “”</p>
<p>​	hash-max-ziplist-entries 512</p>
<p>​	hash-max-ziplist-value 64</p>
<p>​	list-max-ziplist-size -2</p>
<p>​	list-compress-depth 0</p>
<p>​	set-max-intset-entries 512</p>
<p>​	zset-max-ziplist-entries 128</p>
<p>​	zset-max-ziplist-value 64</p>
<p>​	hll-sparse-max-bytes 3000</p>
<p>​	activerehashing yes</p>
<p>​	client-output-buffer-limit normal 0 0 0</p>
<p>​	client-output-buffer-limit slave 256mb 64mb 60</p>
<p>​	client-output-buffer-limit pubsub 32mb 8mb 60</p>
<p>​	hz 10</p>
<p>​	aof-rewrite-incremental-fsync yes</p>
<p>&#x2F;opt&#x2F;redis&#x2F;src&#x2F;redis-server &#x2F;opt&#x2F;redis&#x2F;redis.conf	&#x2F;&#x2F;启动redis</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>redis详解</title>
    <url>/2024/03/06/redis%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>1、什么是Redis？</p>
<p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p>
<p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p>
<p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<p>2、Redis相比memcached有哪些优势？</p>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<p>3、Redis支持哪几种数据类型？</p>
<p>String、List、Set、Sorted Set、hashes</p>
<p>4、Redis主要消耗什么物理资源？</p>
<p>内存。</p>
<p>5、Redis的全称是什么？</p>
<p>Remote Dictionary Server。</p>
<p>6、Redis有哪几种数据淘汰策略？</p>
<p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</p>
<p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p>
<p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p>
<p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p>
<p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p>
<p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p>
<p>7、Redis官方为什么不提供Windows版本？</p>
<p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<p>8、一个字符串类型的值能存储最大容量是多少？</p>
<p>512M</p>
<p>9、为什么Redis需要把所有数据放到内存中？</p>
<p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I&#x2F;O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p>
<p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<p>10、Redis集群方案应该怎么做？都有哪些方案？</p>
<p>1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p>
<p>2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。</p>
<p>3.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p>
<p>4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
<p>11、Redis集群方案什么情况下会导致整个集群不可用？</p>
<p>有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p>
<p>12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</p>
<p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<p>13、Redis有哪些适合的场景？</p>
<p>（1）、会话缓存（Session Cache）</p>
<p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p>
<p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p>
<p>（2）、全页缓存（FPC）</p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p>
<p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p>
<p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>（3）、队列</p>
<p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push&#x2F;pop 操作。</p>
<p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p>
<p>（4），排行榜&#x2F;计数器	</p>
<p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p>
<p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p>
<p>ZRANGE user_scores 0 10 WITHSCORES</p>
<p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p>
<p>（5）、发布&#x2F;订阅</p>
<p>最后（但肯定不是最不重要的）是Redis的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用Redis的发布&#x2F;订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</p>
<p>14、Redis支持的Java客户端都有哪些？官方推荐用哪个？</p>
<p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<p>15、Redis和Redisson有什么关系？</p>
<p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p>
<p>16、Jedis与Redisson对比有什么优缺点？</p>
<p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p>17、Redis如何设置密码及验证密码？</p>
<p>设置密码：config set requirepass 123456</p>
<p>授权密码：auth 123456</p>
<p>18、说说Redis哈希槽的概念？</p>
<p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<p>19、Redis集群的主从复制模型是怎样的？</p>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>20、Redis集群会有写操作丢失吗？为什么？</p>
<p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<p>21、Redis集群之间是如何复制的？</p>
<p>异步复制</p>
<p>22、Redis集群最大节点个数是多少？</p>
<p>16384个。</p>
<p>23、Redis集群如何选择数据库？</p>
<p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
<p>24、怎么测试Redis的连通性？</p>
<p>ping</p>
<p>25、Redis中的管道有什么用？</p>
<p>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<p>26、怎么理解Redis事务？</p>
<p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>27、Redis事务相关的命令有哪几个？</p>
<p>MULTI、EXEC、DISCARD、WATCH</p>
<p>28、Redis key的过期时间和永久有效分别怎么设置？</p>
<p>EXPIRE和PERSIST命令。</p>
<p>29、Redis如何做内存优化？</p>
<p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</p>
<p>30、Redis回收进程如何工作的？</p>
<p>一个客户端运行了新的命令，添加了新的数据。</p>
<p>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。</p>
<p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<p>31、Redis回收使用的是什么算法？</p>
<p>LRU算法</p>
<p>32、Redis如何做大量数据插入？</p>
<p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<p>33、为什么要做Redis分区？</p>
<p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<p>34、你知道有哪些Redis分区实现方案？</p>
<p>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</p>
<p>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</p>
<p>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</p>
<p>35、Redis分区有什么缺点？</p>
<p>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</p>
<p>同时操作多个key,则不能使用Redis事务.</p>
<p>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.</p>
<p>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB &#x2F; AOF文件。</p>
<p>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</p>
<p>36、Redis持久化数据和缓存怎么做扩容？</p>
<p>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p>
<p>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</p>
<p>37、分布式Redis是前期做还是后期规模上来了再做好？为什么？</p>
<p>既然Redis是如此的轻量（单实例只使用1M内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<p>38、Twemproxy是什么？</p>
<p>Twemproxy是Twitter维护的（缓存）代理系统，代理Memcached的ASCII协议和Redis协议。它是单线程程序，使用c语言编写，运行起来非常快。它是采用Apache 2.0 license的开源软件。</p>
<p>Twemproxy支持自动分区，如果其代理的其中一个Redis节点不可用时，会自动将该节点排除（这将改变原来的keys-instances的映射关系，所以你应该仅在把Redis当缓存时使用Twemproxy)。</p>
<p>Twemproxy本身不存在单点问题，因为你可以启动多个Twemproxy实例，然后让你的客户端去连接任意一个Twemproxy实例。</p>
<p>Twemproxy是Redis客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</p>
<p>39、支持一致性哈希的客户端有哪些？</p>
<p>40、Redis与其他key-value存储有什么不同？</p>
<p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p>
<p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p>
<p>41、Redis的内存占用情况怎么样？</p>
<p>给你举个例子： 100万个键值对（键是0到999999值是字符串“hello world”）在我的32位的Mac笔记本上 用了100MB。同样的数据放到一个key里只需要16MB， 这是因为键值有一个很大的开销。 在Memcached上执行也是类似的结果，但是相对Redis的开销要小一点点，因为Redis会记录类型信息引用计数等等。</p>
<p>当然，大键值对时两者的比例要好很多。</p>
<p>64位的系统比32位的需要更多的内存开销，尤其是键值对都较小时，这是因为64位的系统里指针占用了8个字节。 但是，当然，64位系统支持更大的内存，所以为了运行大型的Redis服务器或多或少的需要使用64位的系统。</p>
<p>42、都有哪些办法可以降低Redis的内存使用情况呢？</p>
<p>如果你使用的是32位的Redis实例，可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。</p>
<p>43、查看Redis使用情况及状态信息用什么命令？</p>
<p>info</p>
<p>44、Redis的内存用完了会发生什么？</p>
<p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<p>45、Redis是单线程的，如何提高多核CPU的利用率？</p>
<p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，</p>
<p>所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<p>46、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</p>
<p>理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。</p>
<p>任何list、set、和sorted set都可以放232个元素。</p>
<p>换句话说，Redis的存储极限是系统中的可用内存值。</p>
<p>47、Redis常见性能问题和解决方案？</p>
<p>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</p>
<p>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p>
<p>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p>
<p>(4) 尽量避免在压力很大的主库上增加从库</p>
<p>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</p>
<p>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p>
<p>48、Redis提供了哪几种持久化方式？</p>
<p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p>
<p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</p>
<p>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p>
<p>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p>
<p>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始。</p>
<p>49、如何选择合适的持久化方式？</p>
<p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p>
<p>有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外， 使用RDB还可以避免之前提到的AOF程序的bug。</p>
<p>50、修改配置不重启Redis会实时生效吗？</p>
<p>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。</p>
<p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>文件同步工具rsync实战</title>
    <url>/2024/03/06/rsync/</url>
    <content><![CDATA[<h4 id="rsync服务端"><a href="#rsync服务端" class="headerlink" title="rsync服务端"></a>rsync服务端</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat /etc/rsyncd.conf</span></span><br><span class="line">motd file = /etc/rsyncd.motd</span><br><span class="line">transfer logging = yes</span><br><span class="line"><span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file =/var/run/rsyncd.lock</span><br><span class="line">port = 873</span><br><span class="line">address = 192.168.0.151</span><br><span class="line">uid = nobody</span><br><span class="line">gid = nobody</span><br><span class="line">use chroot = no</span><br><span class="line"><span class="built_in">read</span> only = yes</span><br><span class="line">max connections = 10</span><br><span class="line">[common]</span><br><span class="line">comment = web content</span><br><span class="line">path = /common</span><br><span class="line">ignore errors</span><br><span class="line">auth users =tom,jerry</span><br><span class="line">secrets file = /etc/rsyncd.secrets</span><br><span class="line">hosts allow = 192.168.0.0/255.255.255.0</span><br><span class="line">hosts deny = *</span><br><span class="line">list = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#echo &quot;tom:pass&quot; &gt;/etc/rsyncd.secrets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;jerry:111&quot;&gt;&gt;/etc/rsyncd.secrets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#chmod 600 /etc/rsyncd.secrets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;welcome to access&quot; &gt;/etc/rsyncd.motd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rsync -- dameon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;/usr/bin/rsync --daemon&quot;&gt;&gt;/etc/rc.local</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#iptables -I INPUT -p tcp --dport 873 -j ACCEPT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#service iptables save</span></span><br></pre></td></tr></table></figure>

<h4 id="客户端数据同步"><a href="#客户端数据同步" class="headerlink" title="客户端数据同步"></a>客户端数据同步</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum -y install rsync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rsync -vzrtopg --progress tom@192.168.0.151::common /test</span></span><br><span class="line"></span><br><span class="line">定期任务</span><br><span class="line"></span><br><span class="line"><span class="comment">#cat rsync.bak.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/bin:/usr/bin:/usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">SRC=common</span><br><span class="line"></span><br><span class="line">DEST=/data</span><br><span class="line"></span><br><span class="line">SERVER=192.168.0.151</span><br><span class="line"></span><br><span class="line">USER=tom</span><br><span class="line"></span><br><span class="line">PASSFILE=/root/rsync.pass</span><br><span class="line"></span><br><span class="line">[ ! -d <span class="variable">$DEST</span> ] &amp;&amp; mkdir <span class="variable">$DEST</span></span><br><span class="line"></span><br><span class="line">[ ! -e <span class="variable">$PASSFILE</span> ] &amp;&amp; <span class="built_in">exit</span> 2</span><br><span class="line"></span><br><span class="line">rsync -az --delete --password-file=<span class="variable">$PASSFILE</span> <span class="variable">$&#123;USER&#125;</span>@<span class="variable">$&#123;SERVER&#125;</span>::<span class="variable">$SRC</span> <span class="variable">$DEST</span>/$(date | %Y%m%d)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>snmp+mrtg实现服务器监控图形展示</title>
    <url>/2024/03/06/snmp+mrtg/</url>
    <content><![CDATA[<p>1.snmp调试</p>
<p>2.修改mrtg配置文件</p>
<p>3.根据配置文件生成图片</p>
<p>4.生成首页文件</p>
<p>5.cron 轮休生成监控图片</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum -y install snmp*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cat /etc/snmp/snmpd.conf</span></span><br><span class="line"></span><br><span class="line">rocommunity public</span><br><span class="line"></span><br><span class="line">service snmpd start</span><br><span class="line"></span><br><span class="line">chkconfig snmpd on</span><br><span class="line"></span><br><span class="line"><span class="comment">#yum -y install mrtg*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cat /etc/mrtg/mrtg.cfg</span></span><br><span class="line"></span><br><span class="line">HtmlDir: /var/www/mrtg</span><br><span class="line"></span><br><span class="line">ImageDir: /var/www/mrtg</span><br><span class="line"></span><br><span class="line">LogDir: /var/lib/mrtg</span><br><span class="line"></span><br><span class="line">ThreshDir: /var/lib/mrtg</span><br><span class="line"></span><br><span class="line">Target[eth3_lan]: /192.168.0.182:public@localhost</span><br><span class="line"></span><br><span class="line">Options[eth3_lan]:growright</span><br><span class="line"></span><br><span class="line">Directory[eth3_lan]:eth3</span><br><span class="line"></span><br><span class="line">MaxBytes[eth3_lan]:100000000</span><br><span class="line"></span><br><span class="line">Kmg[eth3_lan]:K,M,G</span><br><span class="line"></span><br><span class="line">YLegend[eth3_lan]:Bytes per Second</span><br><span class="line"></span><br><span class="line">ShortLegend[eth3_lan]:B/s</span><br><span class="line"></span><br><span class="line">Legend1[eth3_lan]:meimiaoliuruliang</span><br><span class="line"></span><br><span class="line">Legend2[eth3_lan]:meimiaoliuchuliang</span><br><span class="line"></span><br><span class="line">LegendI[eth3_lan]:liuru</span><br><span class="line"></span><br><span class="line">LegendO[eth3_lan]:liuchu</span><br><span class="line"></span><br><span class="line">Title[eth3_lan]:eth3wangluoliul</span><br><span class="line"></span><br><span class="line">PageTop[eth3_lan]:&lt;h1&gt;eth3wangluoliuliang&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">Target[cpuload]:.1.3.6.1.4.1.2021.11.50.0&amp;.1.3.6.1.4.1.2021.11.53.0:public@localhost</span><br><span class="line"></span><br><span class="line">Options[cpuload]:nopercent,growright</span><br><span class="line"></span><br><span class="line">Directory[cpuload]:cpu</span><br><span class="line"></span><br><span class="line">MaxBytes[cpuload]:100</span><br><span class="line"></span><br><span class="line">Unscaled[cpuload]:dwym</span><br><span class="line"></span><br><span class="line">YLegend[cpuload]:cpu Utilization</span><br><span class="line"></span><br><span class="line">ShortLegend[cpuload]:%</span><br><span class="line"></span><br><span class="line">Legend1[cpuload]:CPU yonghufuzai</span><br><span class="line"></span><br><span class="line">Legend2[cpuload]:cpu xianzhi</span><br><span class="line"></span><br><span class="line">LegendI[cpuload]:yonghu</span><br><span class="line"></span><br><span class="line">LegendO[cpuload]:xianzhi</span><br><span class="line"></span><br><span class="line">Title[cpuload]:fuzai+xianzhi</span><br><span class="line"></span><br><span class="line">PageTop[cpuload]:&lt;h1&gt;fuzai+xianzhi&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#cat /etc/cron.d/mrtg</span></span><br><span class="line"></span><br><span class="line">LANG=C LC_ALL=C /usr/bin/mrtg /etc/mrtg/mrtg.cfg --lock-file /var/lock/mrtg/mrtg_l --confcache-file /var/lib/mrtg/mrtg.ok  执行三次直到没有报错</span><br></pre></td></tr></table></figure>

<p>生成首页</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">indexmaker --output /var/www/mrtg/index.html --title=<span class="string">&quot;mrtg&quot;</span> /etc/mrtg/mrtg.cfg</span><br></pre></td></tr></table></figure>

<p>apache启动测试</p>
]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>sshpass 命令安装</title>
    <url>/2024/03/06/sshpass/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://sourceforge.net/projects/sshpass/files/latest/download -O sshpass.tar.gz </span><br><span class="line">$ tar -xvf sshpass.tar.gz </span><br><span class="line">$ <span class="built_in">cd</span> sshpass-1.06 </span><br><span class="line">$ ./configure </span><br><span class="line">$ make install </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh版本升级</title>
    <url>/2024/03/06/ssh%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>1.解压安装tar xf openssl-1.1.1h.tar.gz</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd openssl-1.1.1h</span></span><br><span class="line"><span class="comment">#./config --shared --prefix=/usr/openssl 必须加的参数，后果自负</span></span><br><span class="line"><span class="comment">#make -j 5</span></span><br><span class="line"><span class="comment">#make install</span></span><br><span class="line"><span class="comment">#mv /usr/bin/openssl /usr/bin/openssl.bak</span></span><br><span class="line"><span class="comment">#ln -s /usr/openssl/bin/openssl /usr/bin/openssl</span></span><br><span class="line"><span class="comment">#ln -sv /usr/openssl/lib/libssl.so.1.1 /lib &amp;&amp; ln -sv /usr/openssl/lib/libssl.so.1.1 /lib64</span></span><br><span class="line"><span class="comment">#ln -sv /usr/openssl/lib/libcrypto.so.1.1 /lib64 &amp;&amp; ln -sv /usr/openssl/lib/libcrypto.so.1.1 /lib</span></span><br></pre></td></tr></table></figure>

<p>2、查看是否升级成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@zj ~]<span class="comment"># openssl version </span></span><br><span class="line">OpenSSL 1.0.1g 7 Apr 2014</span><br><span class="line"><span class="comment">#yum -y install gcc* make perl pam pam-devel openssl-devel</span></span><br><span class="line"><span class="comment">#mv /etc/ssh /etc/ssh.bak</span></span><br><span class="line"><span class="comment">#openssh version -a</span></span><br></pre></td></tr></table></figure>

<p>3）编译安装新版本openssh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tar xf openssh-8.4p1.tar.gz</span></span><br><span class="line"><span class="comment">#cd openssh-8.4p1</span></span><br><span class="line"><span class="comment">#./configure --prefix=/usr/openssh --sysconfdir=/etc/ssh  --with-zlib --with-md5-passwords</span></span><br><span class="line"><span class="comment">#make</span></span><br><span class="line"><span class="comment">#yum -y remove openssh   (rpm -e `rpm -qa | grep openssh`  --nodeps ）</span></span><br><span class="line"><span class="comment">#make install</span></span><br><span class="line"><span class="comment">#find / -name ssh-keygen</span></span><br><span class="line"><span class="comment">#find / -name sshd</span></span><br><span class="line"><span class="comment">#ln -sv /usr/openssh/bin/ssh-keygen /usr/bin/ssh-keygen &amp;&amp; ln -sv /usr/openssh/sbin/sshd  /usr/sbin/sshd</span></span><br></pre></td></tr></table></figure>

<p>5）复制启动脚本到&#x2F;etc&#x2F;init.d</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cp /root/openssh-8.4p1/contrib/redhat/sshd.init /etc/init.d/sshd</span></span><br><span class="line">加入开机自启</span><br><span class="line"><span class="comment">#chkconfig --add sshd</span></span><br><span class="line"><span class="comment">#chkconfig --list | grep sshd</span></span><br><span class="line"><span class="comment">#echo &quot;PermitRootLogin yes&quot; &gt;&gt; /etc/ssh/sshd_config  （7.5版本自动禁止root登录） </span></span><br><span class="line"><span class="comment">#service sshd start</span></span><br><span class="line"><span class="comment">#netstat -anptu | grep sshd</span></span><br><span class="line"><span class="comment">#ln -sv /usr/openssh/bin/ssh /usr/bin</span></span><br><span class="line"><span class="comment">#ln -sv /usr/openssh/bin/scp /usr/bin/scp</span></span><br><span class="line"><span class="comment">#ssh -V</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>vm网络连接设置</title>
    <url>/2024/03/06/vm%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>1、自动获取IP地址</p>
<p>虚拟机使用桥接模式，相当于连接到物理机的网络里，物理机网络有DHCP服务器自动分配IP地址。</p>
<p>#dhclient 自动获取ip地址命令</p>
<p>#ifconfig 查询系统里网卡信息，ip地址、MAC地址</p>
<p>分配到ip地址后，用物理机进行ping ip地址，检测是否ping通。</p>
<p>2、手动设置ip地址</p>
<p>如果虚拟机不能自动获取IP，只能手动配置，配置方法如下：</p>
<p>输入命令</p>
<p>#vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0 [编辑网卡的配置文件]</p>
<p>输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：</p>
<p>IPADDR&#x3D;192.168.4.10</p>
<p>NETMASK&#x3D;255.255.255.0</p>
<p>GATEWAY&#x3D;192.168.4.1</p>
<p>另外光标移动到”ONBOOT&#x3D;no”这一行，更改为ONBOOT&#x3D;yes</p>
<p>“BOOTPROTO&#x3D;dhcp”，更改为BOOTPROTO&#x3D;none</p>
<p>完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。</p>
<p>之后需要重启一下网络服务，命令为</p>
<p>#servicenetwork restart</p>
<p>网络重启后，eth0的ip就生效了，使用命令#ifconfigeth0 查看</p>
<p>接下来检测配置的IP是否可以ping通，在物理机使用快捷键WINDOWS+R 打开运行框，输入命令cmd，输入ping 192.168.4.10 进行检测，ping通说明IP配置正确。</p>
<p>备注：我所在的物理机网段为192.168.4.0 网段。大家做实验的时候根据自己的环境进行设</p>
<p>定，保持虚拟机和物理机在同一网段即可。</p>
<p>网卡起不来 </p>
<p>查看  &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;70-persistent-net.rules， eth网卡的MAC 是否一致 重新启动服务</p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>添加zabbix监控windows机器</title>
    <url>/2024/03/06/windows/</url>
    <content><![CDATA[<p>修改配置文件 zabbix_agentd.win.conf，配置文件可放在任何目录下</p>
<p>LogFile&#x3D;c:\zabbix_agentd.log</p>
<p>Server&#x3D;10.110.122.9</p>
<p>ListenPort&#x3D;10050</p>
<p>ServerActive&#x3D;10.110.122.9</p>
<p>Hostname&#x3D;WQ</p>
<p># Include&#x3D;c:\zabbix\zabbix_agentd.userparams.conf</p>
<p># Include&#x3D;c:\zabbix\zabbix_agentd.conf.d\</p>
<p># Include&#x3D;c:\zabbix\zabbix_agentd.conf.d*.conf</p>
<p>安装服务</p>
<p>zabbix_agentd.exe -c c:\Users\WQ\Desktop\conf\zabbix_agentd.win.conf -i</p>
<p>启动服务</p>
<p>zabbix_agentd.exe -c c:\Users\WQ\Desktop\conf\zabbix_agentd.win.conf -s</p>
<p>zabbix_agentd.exe –start</p>
]]></content>
      <tags>
        <tag>系统</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix_agentd配置文件</title>
    <url>/2024/03/06/zabbic_proxy.conf/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat  zabbix_agentd.conf</span></span><br><span class="line">PidFile=/var/run/zabbix/zabbix_agentd.pid</span><br><span class="line">LogFile=/var/<span class="built_in">log</span>/zabbix/zabbix_agentd.log</span><br><span class="line">ListenPort=10050</span><br><span class="line">Timeout=30</span><br><span class="line">ServerActive=101.129.224.225</span><br><span class="line">Server=101.129.224.225</span><br><span class="line">Hostname=YSZQ-GS-JS01</span><br><span class="line"></span><br><span class="line"><span class="comment">#cat  zabbix_proxy.conf</span></span><br><span class="line">Server=10.110.122.9</span><br><span class="line">ProxyMode=0</span><br><span class="line">Hostname=GS_proxy</span><br><span class="line">LogFile=/tmp/zabbix_proxy.log</span><br><span class="line">PidFile=/usr/<span class="built_in">local</span>/zabbix_proxy/zabbix_proxy.pid</span><br><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbix_proxy </span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>安装zabbix proxy</title>
    <url>/2024/03/06/zabbix_proxy/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">useradd mysql</span><br><span class="line">mkdir -p /opt/mysqldata &amp;&amp; chown -R mysql.mysql /opt/mysqldata</span><br><span class="line">tar xf mysql-5.6.30-linux-glibc2.5-x86_64.tar.gz -C /opt/</span><br><span class="line"><span class="built_in">cd</span> /opt/mysql-5.6.30-linux-glibc2.5-x86_64 &amp;&amp; chown root.mysql ./*</span><br><span class="line">/bin/cp -f support-files/my-default.cnf /etc/my.cnf</span><br><span class="line">/bin/cp -f support-files/mysql.server /etc/init.d/mysqld </span><br><span class="line">chkconfig --add mysqld</span><br><span class="line">chkconfig mysqld on</span><br><span class="line">./scripts/mysql_install_db  --user=mysql --basedir=/opt/mysql --datadir=/opt/mysqldata</span><br><span class="line">sed -i <span class="string">&#x27;7 basedir = /opt/mysql&#x27;</span> /etc/my.cnf</span><br><span class="line">sed -i <span class="string">&#x27;8 datadir = /opt/mysqldata&#x27;</span> /etc/my.cnf</span><br><span class="line">sed -i <span class="string">&#x27;9 port = 3306&#x27;</span> /etc/my.cnf</span><br><span class="line">sed -i <span class="string">&#x27;10 socket = /tmp/mysql.sock&#x27;</span> /etc/my.cnf</span><br><span class="line">touch /etc/profile.d/mysql.sh &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot; PATH=<span class="variable">$PATH</span>:/opt/mysql/bin&quot;</span> &gt;&gt; /etc/profile.d/mysql.sh</span><br><span class="line">service mysqld start</span><br><span class="line">mysqladmin -uroot password <span class="string">&#x27;cctv.com&#x27;</span></span><br><span class="line">mysql -uroot -pcctv.com -e <span class="string">&#x27;create database zabbix_proxy character set utf8;&#x27;</span></span><br><span class="line">mysql -uroot -pcctv.com -e <span class="string">&quot;grant all privileges on zabbix_proxy.* to zabbix@localhost identified by &#x27;zabbix&#x27;;&quot;</span></span><br><span class="line">mysql -uroot -pcctv.com -e <span class="string">&quot;flush privileges;&quot;</span></span><br><span class="line">mysql -uzabbix -pzabbix zabbix_proxy &lt;/root/zabbix-4.0.5/database/mysql/schema.sql</span><br><span class="line">tar xf zabbix-4.0.5.tar.gz -C /opt &amp;&amp; <span class="built_in">cd</span> /opt/zaabbix-4.0.5</span><br><span class="line">yum -y install libcurl libcurl-devel net-snmp gcc net-snmp-devel pcre-devel</span><br><span class="line">./configure --prefix=/opt/zabbix_proxy --enable-proxy --enable-agent --with-mysql --with-net-snmp --with-libcurl</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">/opt/zabbix_proxy/sbin/zabbix_proxy -c /opt/zabbix_proxy/etc/conf/zabbix_proxy.conf </span><br><span class="line"><span class="comment">#cat zabbix_proxy.conf</span></span><br><span class="line">Server=10.110.122.9</span><br><span class="line">Hostname=BJ_proxy</span><br><span class="line">LogFile=/tmp/zabbix_proxy.log</span><br><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbix_proxy </span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix</span><br><span class="line">报错执行以下：</span><br><span class="line">ln -sv /opt/mysql/lib/libmysqlclient.so.18 /usr/lib64</span><br><span class="line">ln -sv /opt/mysql/lib/libmysqlclient.so.18 /usr/lib</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>安装zabbix server</title>
    <url>/2024/03/06/zabbix_server/</url>
    <content><![CDATA[<p>1.准备zabbix的源码包</p>
<p><a href="https://cdn.zabbix.com/zabbix/sources/stable/5.0/zabbix-5.0.6.tar.gz">https://cdn.zabbix.com/zabbix/sources/stable/5.0/zabbix-5.0.6.tar.gz</a></p>
<p>解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@linux1 ~]<span class="comment"># tar xf zabbix-5.0.6.tar.gz</span></span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment"># cd zabbix-5.0.6</span></span><br></pre></td></tr></table></figure>

<p>2.新建用户组</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@linux1 ~]<span class="comment"># groupadd zabbix</span></span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment"># useradd -g zabbix zabbix</span></span><br></pre></td></tr></table></figure>

<p>3.zabbix数据库创建导入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE user SET Password = PASSWORD(<span class="string">&#x27;cctv.com&#x27;</span>) WHERE user = <span class="string">&#x27;zabbix&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; create database zabbix character <span class="built_in">set</span> utf8;</span><br><span class="line"></span><br><span class="line">mysql&gt; use zabbix grant all privileges on zabbix.* to zabbix@localhost identified by <span class="string">&quot;cctv.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">source</span> /root/zabbix-3.0.10/database/mysql/schema.sql</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">source</span> /root/zabbix-3.0.10/database/mysql/images.sql</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">source</span> /root/zabbix-3.0.10/database/mysql/data.sql</span><br></pre></td></tr></table></figure>

<p>4.编译安装zabbix</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@linux1 ~]<span class="comment"># cd zabbix-3.0.10</span></span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment">#yum -y install curl-devel gcc cmake </span></span><br><span class="line"></span><br><span class="line">[root@linux1 zabbix-3.0.10]<span class="comment"># ./configure --prefix=/usr/local/zabbix --with-mysql --with-net-snmp --with-libcurl --enable-server --enable-agent --enable-proxy --with-openipmi --with-java</span></span><br></pre></td></tr></table></figure>

<p>可能会缺少一些包，查看一下报错，用yum安装即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@linux1 ~]<span class="comment">#yum -y install mysql-devel</span></span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment">#yum install net-snmp-devel</span></span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment">#yum install OpenIPMI-* -y</span></span><br><span class="line"></span><br><span class="line">[root@linux1 zabbix-3.0.10]<span class="comment"># make</span></span><br><span class="line"></span><br><span class="line">[root@linux1 zabbix-3.0.10]<span class="comment"># make install</span></span><br></pre></td></tr></table></figure>

<p>5.添加服务端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@linux1 zabbix-2.4.8]<span class="comment"># vim /etc/services</span></span><br><span class="line"></span><br><span class="line">zabbix-agent 10050/tcp    <span class="comment"># Zabbix Agent</span></span><br><span class="line"></span><br><span class="line">zabbix-agent 10050/udp   <span class="comment"># Zabbix Agent</span></span><br><span class="line"></span><br><span class="line">zabbix-trapper 10051/tcp   <span class="comment"># Zabbix Trapper</span></span><br><span class="line"></span><br><span class="line">zabbix-trapper 10051/udp  <span class="comment"># Zabbix Trapper</span></span><br></pre></td></tr></table></figure>

<p>6.修改zabbix配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@linux1 ~]<span class="comment"># cd /usr/local/zabbix/etc</span></span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment"># vim zabbix_server.conf</span></span><br><span class="line"></span><br><span class="line">ListenPort=10051</span><br><span class="line"></span><br><span class="line">DBName=zabbix  <span class="comment">#数据库名称</span></span><br><span class="line"></span><br><span class="line">DBUser=zabbix  <span class="comment">#数据库用户名</span></span><br><span class="line"></span><br><span class="line">DBPassword=zabbix <span class="comment">#数据库密码</span></span><br><span class="line"></span><br><span class="line">DBPort=3306 <span class="comment">#我机器数据库端口是3306</span></span><br><span class="line"></span><br><span class="line">DBSocket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure>

<p>7.设置启动脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zabbix默认的启动脚本在 /usr/<span class="built_in">local</span>/zabbix/sbin/ 下</span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment"># echo /usr/local/zabbix/sbin/zabbix_agentd &gt;&gt;/etc/rc.local</span></span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment"># echo /usr/local/zabbix/sbin/zabbix_server &gt;&gt;/etc/rc.local</span></span><br></pre></td></tr></table></figure>

<p>8.修改php.ini</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@linux1 ~]<span class="comment"># vi /usr/local/php/etc/php.ini</span></span><br><span class="line"></span><br><span class="line">date.timezone = Asia/Shanghai</span><br><span class="line"></span><br><span class="line">max_execution_time= 300</span><br><span class="line"></span><br><span class="line">post_max_size = 32M</span><br><span class="line"></span><br><span class="line">max_input_time = 300</span><br><span class="line"></span><br><span class="line">memory_limit = 128M</span><br><span class="line"></span><br><span class="line">mbstring.func_overload = 0</span><br><span class="line"></span><br><span class="line">always_populate_raw_post_data = -1</span><br></pre></td></tr></table></figure>

<p>9.设置zabbix的web站点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@linux1 ~]<span class="comment"># mkdir /usr/local/ngxinx/zabbix</span></span><br><span class="line"></span><br><span class="line">[root@linux1 ~]<span class="comment"># cp /root/zabbix-2.4.8/frontends/php/* /home/wwwroot/defaults/zabbix</span></span><br></pre></td></tr></table></figure>

<p>配置web界面</p>
]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix自定义键值</title>
    <url>/2024/03/06/zabbix%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E5%80%BC/</url>
    <content><![CDATA[<h4 id="1-redis-监控"><a href="#1-redis-监控" class="headerlink" title="1.redis 监控"></a><strong>1.redis 监控</strong></h4><p>实施：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /opt/zabbix_agentd/scripts/</span><br><span class="line">touch  /opt/zabbix_agentd/scripts/data_dir.sh</span><br><span class="line">chmod +x /opt/zabbix_agentd/scripts/data_dir.sh</span><br><span class="line">vi /opt/zabbix_agentd/etc/zabbix_agentd.conf</span><br><span class="line">UserParameter=redis.data,/opt/zabbix_agentd/scripts/data_dir.sh</span><br><span class="line">vi /opt/zabbix_agentd/scripts/data_dir.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">data_size=`du -s /opt/redis/data`</span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$data_size</span> |awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)<span class="string">&quot;000&quot;</span></span><br><span class="line">pkill -9 zabbix</span><br><span class="line">/opt/zabbix_agentd/sbin/zabbix_agentd -c /opt/zabbix_agentd/etc/zabbix_agentd.conf</span><br><span class="line">1.get_redis_clients.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">client_num=`<span class="built_in">echo</span> <span class="string">&#x27;info &#x27;</span>|redis-cli -a cctv.com |grep <span class="string">&#x27;connected_clients&#x27;</span> |awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$client_num</span>&quot;</span></span><br><span class="line">2.get_redis_copy_aof.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">replication_status=(<span class="string">&quot;`echo &#x27;info &#x27;|redis-cli -a cctv.com |grep &#x27;aof_enabled&#x27; |awk -F&#x27;:&#x27; &#x27;&#123;print <span class="variable">$2</span>&#125;&#x27;`&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$replication_status</span></span><br><span class="line">3.get_redis_data_mem.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;info &#x27;</span>|redis-cli -a cctv.com|grep -w <span class="string">&quot;used_memory_rss&quot;</span> |awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">4.get_redis_hisrory_max_mem.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;info &#x27;</span>|redis-cli -a cctv.com|grep -w <span class="string">&#x27;used_memory_peak&#x27;</span> |awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">5.get_redis_mem_rate.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;info &#x27;</span>|redis-cli -a cctv.com|grep mem_fragmentation_ratio |awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">6.get_redis_mem_total.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;info &#x27;</span>|redis-cli -a cctv.com|grep -w <span class="string">&#x27;used_memory_rss&#x27;</span>|awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|awk -F<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">7.get_redis_status.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">redis_status=`/bin/<span class="built_in">echo</span> <span class="string">&#x27;ping&#x27;</span>|redis-cli -a cctv.com`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$redis_status</span> == PONG ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">8.get_redis_version.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">redis_status=`/bin/<span class="built_in">echo</span> <span class="string">&#x27;ping&#x27;</span>|redis-cli -a cctv.com`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$redis_status</span> == PONG ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">9.get_set_redis_mem_total.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">total_mem=`cat /opt/redis/etc/redis.conf |grep <span class="string">&#x27;maxmemory&#x27;</span> |grep -v <span class="string">&#x27;^#&#x27;</span> |awk -F<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$total_mem</span>&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-mysql-监控"><a href="#2-mysql-监控" class="headerlink" title="2.mysql 监控"></a><strong>2.mysql 监控</strong></h4><p>实施：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install php php-mysql</span><br><span class="line">rpm -ivh percona-zabbix-templates-1.1.8-1.noarch.rpm</span><br><span class="line">cp /var/lib/zabbix/percona/templates/userparameter_percona_mysql.conf /opt/zabbix_agentd/etc/zabbix_agentd.conf.d</span><br><span class="line">cat zabbix_agentd.conf</span><br><span class="line">Include=/opt/zabbix_agentd/etc/zabbix_agentd.conf.d</span><br><span class="line"><span class="built_in">cd</span> /var/lib/zabbix/percona/scripts/</span><br><span class="line">cat ss_get_mysql_stats.php  <span class="comment">#数据库连接</span></span><br><span class="line"><span class="variable">$mysql_user</span> = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="variable">$mysql_pass</span> = <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line">cat get_mysql_stats_wrapper.sh </span><br><span class="line">HOST=101.129.224.207</span><br><span class="line">RES=`/opt/mysql/bin/mysql -e <span class="string">&#x27;SHOW SLAVE STATUS\G&#x27;</span> | egrep <span class="string">&#x27;(Slave_IO_Running|Slave_SQL_Running):&#x27;</span> | awk -F: <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | tr <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27;,&#x27;</span>`</span><br><span class="line">pkill -9 zabbix</span><br><span class="line">/opt/zabbix_agentd/sbin/zabbix_agentd -c /opt/zabbix_agentd/etc/zabbix_agentd.conf</span><br></pre></td></tr></table></figure>



<h4 id="3-keepalived-状态监控"><a href="#3-keepalived-状态监控" class="headerlink" title="3.keepalived 状态监控"></a><strong>3.keepalived 状态监控</strong></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /opt/zabbix_agentd/script</span><br><span class="line">cat chk_keepalived_status.sh </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">keep_status=$(<span class="built_in">echo</span> <span class="string">&quot;`/etc/init.d/keepalived status`&quot;</span> | awk  <span class="string">&#x27;&#123;print $5&#125;&#x27;</span>)</span><br><span class="line">result=0</span><br><span class="line"><span class="keyword">if</span> [[ `<span class="built_in">echo</span> <span class="variable">$LANG</span>` == <span class="string">&#x27;en_US.UTF-8&#x27;</span> ]];<span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$keep_status</span> == <span class="string">&#x27;running...&#x27;</span> ]];<span class="keyword">then</span></span><br><span class="line">                result=1</span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                result=0</span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> [[ `/etc/init.d/keepalived status|awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>` == <span class="string">&#x27;正在运行...&#x27;</span> ]];<span class="keyword">then</span></span><br><span class="line">                result=1</span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                result=0</span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">pkill -9 zabbix</span><br><span class="line">/opt/zabbix_agentd/sbin/zabbix_agentd -c /opt/zabbix_agentd/etc/zabbix_agentd.conf</span><br></pre></td></tr></table></figure>

<h4 id="4-LVS状态监控"><a href="#4-LVS状态监控" class="headerlink" title="4.LVS状态监控"></a><strong>4.LVS状态监控</strong></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1.get_keepalived_status.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">num=`/bin/ps -ef |grep keepalived |grep -v <span class="string">&quot;grep&quot;</span> |wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$num</span>&quot;</span> == 5 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">2.get_lvs_bit_sec.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">tail -1 /proc/net/ip_vs_stats | /usr/bin/awk <span class="string">&#x27;&#123;print strtonum(&quot;0x&quot;$1),strtonum(&quot;0x&quot;$2), strtonum(&quot;0x&quot;$3),strtonum(&quot;0x&quot;$4), strtonum(&quot;0x&quot;$5)&#125;&#x27;</span>|awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">3.get_lvs_conns_sec.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">cat /proc/net/ip_vs_conn |wc -l</span><br><span class="line">4.get_lvs_keepalived_vip_status.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">KEEPALIVE_CONF_DIR=/etc/keepalived/keepalived.conf</span><br><span class="line">IP_LIST=(<span class="string">&quot;`cat <span class="variable">$KEEPALIVE_CONF_DIR</span> |grep virtual_server |awk -F&#x27; &#x27; &#x27;&#123;print <span class="variable">$2</span>&#125;&#x27;|sort |uniq`&quot;</span>)</span><br><span class="line">n=0</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;IP_LIST[@]&#125;</span>;<span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&#x27;`/sbin/ip addr |grep &#x27;</span><span class="variable">$ip</span><span class="string">&#x27;|wc -l`&#x27;</span> == 1 ];<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">let</span> n=n+1</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                n=0 </span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">if</span> [ `cat <span class="variable">$KEEPALIVE_CONF_DIR</span> |grep virtual_server |awk -F<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|sort |uniq |wc -l` == <span class="string">&quot;<span class="variable">$n</span>&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">5.get_lvs_packets_sec.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">tail -1 /proc/net/ip_vs_stats | /usr/bin/awk <span class="string">&#x27;&#123;print strtonum(&quot;0x&quot;$1),strtonum(&quot;0x&quot;$2), strtonum(&quot;0x&quot;$3), strtonum(&quot;0x&quot;$4),strtonum(&quot;0x&quot;$5)&#125;&#x27;</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>配置ssh加速登陆</title>
    <url>/2024/03/06/%E5%8A%A0%E9%80%9Fssh%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h5 id="加速ssh登陆"><a href="#加速ssh登陆" class="headerlink" title="加速ssh登陆"></a><strong>加速ssh登陆</strong></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">修改 /etc/ssh/ssh_config</span><br><span class="line">StrictHostKeyChecking no</span><br><span class="line">替换/etc/ssh/sshd_config</span><br><span class="line">UseDNS no</span><br><span class="line">Protocol 2</span><br><span class="line">SyslogFacility AUTHPRIV</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line">GSSAPIAuthentication no</span><br><span class="line">GSSAPICleanupCredentials yes</span><br><span class="line">UsePAM yes</span><br><span class="line">AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES</span><br><span class="line">AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT</span><br><span class="line">AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE</span><br><span class="line">AcceptEnv XMODIFIERS</span><br><span class="line">X11Forwarding yes</span><br><span class="line">Subsystem       sftp    /usr/libexec/openssh/sftp-server</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ssl的主从复制</title>
    <url>/2024/03/06/%E5%9F%BA%E4%BA%8Essl%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h5 id="MASTER："><a href="#MASTER：" class="headerlink" title="MASTER："></a>MASTER：</h5><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./bin/mysqld --defaults-file=/etc/my.cnf --user=mysql --datadir=/mydata/data --basedir=/opt/mysql --initialize --lc-messages_dir=/opt/mysql/share</span><br><span class="line">cat my.cnf</span><br><span class="line">[client]</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">basedir = /opt/mysql</span><br><span class="line">datadir = /mydata/data</span><br><span class="line">user = mysql</span><br><span class="line">port = 3306</span><br><span class="line">server_id = 3</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">pid-file = /mydata/data/mysql.pid</span><br><span class="line">log-error = /mydata/data/mysql_log.err</span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">gtid_mode = ON</span><br><span class="line">enforce_gtid_consistency = 1</span><br></pre></td></tr></table></figure>

<h6 id="安装ssl-rsz"><a href="#安装ssl-rsz" class="headerlink" title="安装ssl_rsz:"></a>安装ssl_rsz:</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql_ssl_rsz_setup --user=mysql --basedir=/opt/mysql --datadir=/mydata/data</span><br><span class="line">chmod +r server-key.pem</span><br><span class="line">mysql&gt;show variables like <span class="string">&#x27;%ssl%&#x27;</span>;</span><br><span class="line">mysql&gt;grant replication slave on *.* to <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;192.168.1.%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span> require ssl;</span><br><span class="line">/etc/init.d/mysqld restart</span><br><span class="line">scp ca.pem client-cert.pem client-key.pem 192.168.1.4:/mydata/data</span><br></pre></td></tr></table></figure>

<h5 id="SLAVE"><a href="#SLAVE" class="headerlink" title="SLAVE:"></a>SLAVE:</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod +r /mydata/data/client-key.pem </span><br><span class="line">cat /etc/my.cnf</span><br><span class="line">[client]</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">basedir = /opt/mysql</span><br><span class="line">datadir = /mydata/data</span><br><span class="line">user = mysql</span><br><span class="line">port = 3306</span><br><span class="line">server_id = 4</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">pid-file = /mydata/data/mysql.pid</span><br><span class="line">log-error = /mydata/data/mysql_log.err</span><br><span class="line">relay-log = /mydata/data/relay-log-bin</span><br><span class="line">relay-log-index = /mydata/data/slave-relay-bin.index</span><br><span class="line">ssl-ca = /mydata/data/ca.pem</span><br><span class="line">ssl-cert = /mydata/data/client-cert.pem</span><br><span class="line">ssl-key = /mydata/data/client-key.pem</span><br><span class="line">gtid_mode = ON</span><br><span class="line">enforce_gtid_consistency = 1</span><br><span class="line">/etc/init.d/mysqld restart</span><br><span class="line">mysql &gt;show variables like <span class="string">&#x27;%ssl%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="测试ssl远程mysql连接"><a href="#测试ssl远程mysql连接" class="headerlink" title="测试ssl远程mysql连接"></a>测试ssl远程mysql连接</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql --ssl-ca=ca.pem --ssl-cert=client-cert.pem --ssl-key=client-key.pem -uslave -pslave -h192.168.1.3</span><br></pre></td></tr></table></figure>

<h6 id="配置change-master"><a href="#配置change-master" class="headerlink" title="配置change master"></a>配置change master</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt;change master to master_host=<span class="string">&#x27;192.168.1.3&#x27;</span>,master_user=<span class="string">&#x27;slave&#x27;</span>,master_password=<span class="string">&#x27;slave&#x27;</span>,master_auto_position=1,master_ssl=1;</span><br><span class="line">mysql &gt;start slave ;</span><br><span class="line">mysql &gt;show slave status\G</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>挂载新盘无法识别解决办法</title>
    <url>/2024/03/06/%E6%8C%82%E8%BD%BD%E6%96%B0%E7%9B%98%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd /sys/class/scsi_host</span></span><br><span class="line"><span class="comment">#ll</span></span><br><span class="line"><span class="comment">#grep mpt /sys/class/scsi_host/host2/proc_name</span></span><br><span class="line">mptspi</span><br><span class="line"><span class="comment">#echo &quot;---&quot; &gt; /sys/class/scsi_host/host2/scan</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>新的旅程</title>
    <url>/2024/03/06/%E6%96%B0%E7%9A%84%E6%97%85%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="以后将会在github平台发布我的学习技术的文章，欢迎交流QQ：1059377158。将会涉及linux运维，网络，安全方面的知识。"><a href="#以后将会在github平台发布我的学习技术的文章，欢迎交流QQ：1059377158。将会涉及linux运维，网络，安全方面的知识。" class="headerlink" title="以后将会在github平台发布我的学习技术的文章，欢迎交流QQ：1059377158。将会涉及linux运维，网络，安全方面的知识。"></a>以后将会在github平台发布我的学习技术的文章，欢迎交流QQ：1059377158。将会涉及linux运维，网络，安全方面的知识。</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
  </entry>
  <entry>
    <title>桥接网络设置</title>
    <url>/2024/03/06/%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h5 id="物理机"><a href="#物理机" class="headerlink" title="物理机"></a>物理机</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-enp0s31f6</span></span><br><span class="line">DEVICE=enp0s31f6</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">BRIDGE=br0</span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-br0 </span></span><br><span class="line">DEVICE=<span class="string">&quot;br0&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">TYPE=<span class="string">&quot;Bridge&quot;</span></span><br><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">IPADDR=10.110.2.99</span><br><span class="line">NETMASK=255.255.255.192</span><br><span class="line">GATEWAY=10.110.2.126</span><br></pre></td></tr></table></figure>



<h5 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-br0 </span></span><br><span class="line">TYPE=Bridge</span><br><span class="line">NAMR=br0</span><br><span class="line">DEVICE=br0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTE=static</span><br><span class="line">IPADDR=10.110.2.66</span><br><span class="line">NATMASK=255.255.255.192</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0 </span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BRIDGE=br0</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">NAME=eth0</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>系统管理员必知必会</title>
    <url>/2024/03/06/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><h5 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h5><p>重新创建文件系统会损坏原有文件</p>
<blockquote>
<p>mkfs: make file system</p>
<p>​	-t FSTYPE </p>
<p>mkfs -t ext2 &#x3D; mkfs.ext2</p>
<p>mkfs -t ext3 &#x3D; mkfs.ext3</p>
<p>专门管理ext系列文件：</p>
<p>mke2fs</p>
</blockquote>
<table>
<thead>
<tr>
<th>-j</th>
<th><strong>创建ext3类型文件系统</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-b BLOCK_SIZE</td>
<td><strong>指定块大小，默认为4096；可用取值为1024、2048或4096</strong></td>
</tr>
<tr>
<td>-L LABEL</td>
<td><strong>指定分区卷标</strong></td>
</tr>
<tr>
<td>-m</td>
<td><strong>指定预留给超级用户的块数百分比</strong></td>
</tr>
<tr>
<td>-i</td>
<td><strong>用于指定为多少字节的空间创建一个inode，默认为8192；这里给出的数值应该为块大小的2^n倍</strong></td>
</tr>
<tr>
<td>-N</td>
<td><strong>指定inode个数</strong></td>
</tr>
<tr>
<td>-F</td>
<td><strong>强制创建文件系统</strong></td>
</tr>
<tr>
<td>-E</td>
<td><strong>用户指定额外文件系统属性</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>blkid: 查询或查看磁盘设备的相关属性</p>
<p>​	UUID</p>
<p>​	TYPE</p>
<p>​	LABEL</p>
</blockquote>
<p>​	</p>
<blockquote>
<p>e2label: 用于查看或定义卷标</p>
<p>​	e2label 设备文件 卷标: 设定卷标</p>
</blockquote>
<p>​	</p>
<p>tune2fs: 调整文件系统的相关属性</p>
<table>
<thead>
<tr>
<th>-j</th>
<th>不损害原有数据，将ext2升级为ext3</th>
</tr>
</thead>
<tbody><tr>
<td>-L LABEL</td>
<td>设定或修改卷标</td>
</tr>
<tr>
<td>-m</td>
<td>调整预留百分比</td>
</tr>
<tr>
<td>-r</td>
<td>指定预留块数</td>
</tr>
<tr>
<td>-o</td>
<td>设定默认挂载选项</td>
</tr>
<tr>
<td>-c</td>
<td>指定挂载次数达到#次之后进行自检，0或-1表关闭此功能</td>
</tr>
<tr>
<td>-i</td>
<td>每挂载使用多少天后进行自检；0或-1表示关闭此功能</td>
</tr>
<tr>
<td>-l</td>
<td>显示超级块中的信息</td>
</tr>
</tbody></table>
<blockquote>
<p>dumpe2fs: 显示文件属性信息</p>
<p>​	-h: 只显示超级块中的信息</p>
<p>​	</p>
<p>fsck: 检查并修复Linux文件系统</p>
<p>​	-t FSTYPE: 指定文件系统类型</p>
<p>​	-a: 自动修复</p>
<p>​	</p>
<p>e2fsck: 专用于修复ext2&#x2F;ext3文件系统</p>
<p>​	-f: 强制检查；</p>
<p>​	-p: 自动修复；</p>
</blockquote>
<p>​	</p>
<blockquote>
<p>挂载：将新的文件系统关联至当前根文件系统</p>
<p>卸载：将某文件系统与当前根文件系统的关联关系预以移除；</p>
<p>mount：挂载</p>
<p>mount 设备 挂载点</p>
<p>​	设备：</p>
<p>​		设备文件：&#x2F;dev&#x2F;sda5</p>
<p>​		卷标：LABEL&#x3D;“”</p>
<p>​		UUID： UUID&#x3D;“”</p>
<p>​	挂载点：目录</p>
<p>​		要求：</p>
<p>​			1、此目录没有被其它进程使用；</p>
<p>​			2、目录得事先存在；</p>
<p>​			3、目录中的原有的文件将会暂时隐藏；</p>
<p>mount: 显示当前系统已经挂载的设备及挂载点</p>
<p>mount [options] [-o options] DEVICE MOUNT_POINT</p>
<p>​	-a: 表示挂载&#x2F;etc&#x2F;fstab文件中定义的所有文件系统</p>
<p>​	-n: 默认情况下，mount命令每挂载一个设备，都会把挂载的设备信息保存至&#x2F;etc&#x2F;mtab文件；使用—n选项意味着挂载设备时，不把信息写入此文件；</p>
<p>​	-t FSTYPE: 指定正在挂载设备上的文件系统的类型；不使用此选项时，mount会调用blkid命令获取对应文件系统的类型；</p>
<p>​	-r: 只读挂载，挂载光盘时常用此选项</p>
<p>​	-w: 读写挂载</p>
<p>​	</p>
<p>​	-o: 指定额外的挂载选项，也即指定文件系统启用的属性；</p>
<p>​		remount: 重新挂载当前文件系统</p>
<p>​		ro: 挂载为只读</p>
<p>​		rw: 读写挂载</p>
<p>​			</p>
<p>挂载完成后，要通过挂载点访问对应文件系统上的文件；</p>
<p>umount: 卸载某文件系统</p>
<p>​	umount 设备</p>
<p>​	umount 挂载点	</p>
<p>​	卸载注意事项：</p>
<p>​		挂载的设备没有进程使用；</p>
</blockquote>
<p>​		</p>
<h6 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h6><p>1、创建一个2G的分区，文件系统为ext2，卷标为DATA，块大小为1024，预留管理空间为磁盘分区的8%；挂载至&#x2F;backup目录，要求使用卷标进行挂载，且在挂载时启动此文件系统上的acl功能；</p>
<p># mke2fs -L DATA -b 1024 -m 8  &#x2F;dev&#x2F;sda7</p>
<p># mount -o acl LABEL&#x3D;DATA &#x2F;backup</p>
<p># tune2fs -o acl &#x2F;dev&#x2F;sda7</p>
<p># mount LABEL&#x3D;DATA &#x2F;backup</p>
<p>2、将此文件系统的超级块中的信息中包含了block和inode的行保存至&#x2F;tmp&#x2F;partition.txt中；</p>
<p># tune2fs -l | egrep -i  “block|inode” &gt;&gt; &#x2F;tmp&#x2F;partition.txt  </p>
<p># dumpe2fs -h |</p>
<p>3、复制&#x2F;etc目录中的所有文件至此文件系统；而后调整此文件系统类型为ext3，要求不能损坏已经复制而来的文件；</p>
<p># cp -r &#x2F;etc&#x2F;*  &#x2F;backup</p>
<p># tune2	-j &#x2F;dev&#x2F;sda7</p>
<p>4、调整其预留百分比为3%；</p>
<p># tune2fs -m 3 -L DATA &#x2F;dev&#x2F;sda7</p>
<p>5、以重新挂载的方式挂载此文件系统为不更新访问时间戳，并验正其效果；</p>
<p># stat &#x2F;backup&#x2F;inittab</p>
<p># cat &#x2F;backup&#x2F;inittab</p>
<p># stat</p>
<p># mount -o remount,noatime &#x2F;backup</p>
<p># cat </p>
<p># stat</p>
<p>6、对此文件系统强行做一次检测；</p>
<p>e2fsck -f &#x2F;dev&#x2F;sda7</p>
<p>7、删除复制而来的所有文件，并将此文件系统重新挂载为同步(sync)；而后再次复制&#x2F;etc目录中的所有文件至此挂载点，体验其性能变化；</p>
<p># rm -rf &#x2F;backup&#x2F;*</p>
<p># mount -o remount,sync &#x2F;backup</p>
<p># cp -r &#x2F;etc&#x2F;* &#x2F;backup</p>
<p>swap分区：</p>
<p>free </p>
<p>​	-m</p>
<p>fdisk命令中，调整分区类型为82；</p>
<p>​	</p>
<p>创建交换分区：</p>
<p>mkswap &#x2F;dev&#x2F;sda8</p>
<p>​	-L LABEL</p>
<p>swapon &#x2F;dev&#x2F;sda8</p>
<p>​	-a:启用所有的定义在&#x2F;etc&#x2F;fstab文件中的交换设备</p>
<p>swapoff &#x2F;dev&#x2F;sda8</p>
<p>回环设备</p>
<p>loopback, 使用软件来模拟实现硬件</p>
<p>创建一个镜像文件，120G</p>
<p>dd命令：</p>
<p>​	if&#x3D;数据来源</p>
<p>​	of&#x3D;数据存储目标</p>
<p>​	bs&#x3D;1</p>
<p>​	count&#x3D;2</p>
<p>​	seek&#x3D;#: 创建数据文件时，跳过的空间大小；</p>
<p>​	</p>
<p>dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;mnt&#x2F;usb&#x2F;mbr.backup bs&#x3D;512 count&#x3D;1</p>
<p>dd if&#x3D;&#x2F;mnt&#x2F;usb&#x2F;mbr.backup of&#x3D;&#x2F;dev&#x2F;sda bs&#x3D;512 count&#x3D;1</p>
<p>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;var&#x2F;swapfile bs&#x3D;1M count&#x3D;1024</p>
<p>&#x2F;dev&#x2F;null</p>
<p>​	</p>
<p>mount命令，可以挂载iso镜像；</p>
<p>mount DEVICE MOUNT_POINT</p>
<p>​	-o loop: 挂载本地回环设备</p>
<p>wget <a href="ftp://172.16.0.1/pub/isos/rhci-5.8-1.iso">ftp://172.16.0.1/pub/isos/rhci-5.8-1.iso</a></p>
<p>mount &#x2F;dev&#x2F;sda5 &#x2F;mnt&#x2F;test</p>
<p>文件系统的配置文件&#x2F;etc&#x2F;fstab</p>
<p>​	OS在初始时，会自动挂载此文件中定义的每个文件系统</p>
<p>​	</p>
<p>要挂载的设备	挂载点		文件系统类型		挂载选项		转储频率(每多少天做一次完全备份)		文件系统检测次序(只有根可以为1)		</p>
<p>&#x2F;dev&#x2F;sda5		&#x2F;mnt&#x2F;test		ext3		defaults		0 0</p>
<p>mount -a：挂载&#x2F;etc&#x2F;fstab文件中定义的所有文件系统</p>
<p>fuser: 验正进程正在使用的文件或套接字文件</p>
<p>​	-v: 查看某文件上正在运行的进程</p>
<p>​	-k:</p>
<p>​	-m</p>
<p>​	</p>
<p>​	fuser -km MOUNT_POINT：终止正在访问此挂载点的所有进程</p>
<p>​	</p>
<h6 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h6><p>1、创建一个5G的分区，文件系统为ext3，卷标为MYDATA，块大小为1024，预留管理空间为磁盘分区的3%，要求开机后可以自动挂载至&#x2F;data目录，并且自动挂载的设备要使用卷标进行引用；</p>
<p>2、创建一个本地回环文件&#x2F;var&#x2F;swaptemp&#x2F;swapfile来用于swap，要求大小为512MB，卷标为SWAP-FILE，且开机自动启用此交换设备；</p>
<p># mkdir &#x2F;var&#x2F;swaptemp</p>
<p># dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;var&#x2F;swaptemp&#x2F;swapfile bs&#x3D;1M count&#x3D;512</p>
<p># mkswap LABLE&#x3D;SWAP-FILE &#x2F;var&#x2F;swaptemp&#x2F;swapfile</p>
<p>&#x2F;etc&#x2F;fstab</p>
<p>&#x2F;var&#x2F;swaptemp&#x2F;swapfile  	swap		swap		defaults		0 0</p>
<p>3、上述第一问，如何让其自动挂载的同时启用ACL功能；</p>
<p>&#x2F;etc&#x2F;fstab</p>
<p>LABEL&#x3D;’MYDATA’		&#x2F;data		ext3		defaults,acl	0 0</p>
<p>压缩、解压缩命令</p>
<p>压缩格式：gz, bz2, xz, zip, Z</p>
<p>压缩算法：算法不同，压缩比也会不同；</p>
<p>compress: FILENAME.Z</p>
<p>uncompress</p>
<p>gzip: .gz</p>
<p>​	gzip &#x2F;PATH&#x2F;TO&#x2F;SOMEFILE：压缩完成后会删除原文件</p>
<p>​		-d： </p>
<p>​		-#：1-9，指定压缩比，默认是6；</p>
<p>​	</p>
<p>gunzip: </p>
<p>​	gunzip &#x2F;PATH&#x2F;TO&#x2F;SOMEFILE.gz: 解压完成后会删除原文件</p>
<p>zcat &#x2F;PATH&#x2F;TO&#x2F;SOMEFILE.gz： 不解压的情况，查看文本文件的内容</p>
<p>​	</p>
<p>bzip2: .bz2</p>
<p>比gzip有着更大压缩比的压缩工具，使用格式近似</p>
<p>​	bzip2 &#x2F;PATH&#x2F;TO&#x2F;SOMEFILE</p>
<p>​		-d</p>
<p>​		-#: 1-9,默认是6</p>
<p>​		-k: 压缩时保留原文件</p>
<p>​		</p>
<p>​	bunzip2 &#x2F;PATH&#x2F;TO&#x2F;SOMEFILE.bz2</p>
<p>​	bzcat</p>
<p>xz: .xz</p>
<p>​	xz &#x2F;PATH&#x2F;TO&#x2F;SOMEFILE</p>
<p>​		-d</p>
<p>​		-#: 1-9, 默认是6</p>
<p>​		-k: 压缩时保留原文件</p>
<p>​		</p>
<p>​	unxz</p>
<p>​	xzdec</p>
<p>​	xzcat </p>
<p>zip: 既归档又压缩的工具</p>
<p>​	zip FILENAME.zip FILE1 FILE2 …: 压缩后不删除原文件</p>
<p>​	unzip FILENAME.zip</p>
<p>​	</p>
<p>archive: 归档，归档本身并不意味着压缩</p>
<p>xz, bz2, gz</p>
<p>tar: 归档工具, .tar</p>
<p>​	-c: 创建归档文件</p>
<p>​	-f FILE.tar: 操作的归档文件</p>
<p>​	-x: 展开归档</p>
<p>​	–xattrs: 归档时，保留文件的扩展属性信息</p>
<p>​	-t: 不展开归档，直接查看归档了哪些文件</p>
<p>​	-zcf: 归档并调用gzip压缩</p>
<p>​	-zxf: 调用gzip解压缩并展开归档，-z选项可省略</p>
<p>​	</p>
<p>​	-jcf: bzip2</p>
<p>​	-jxf:</p>
<p>​	</p>
<p>​	-Jcf: xz</p>
<p>​	-Jxf:</p>
<p>cpio: 归档工具</p>
<p>​	</p>
<p>​	</p>
<h6 id="练习：写一个脚本"><a href="#练习：写一个脚本" class="headerlink" title="练习：写一个脚本"></a>练习：写一个脚本</h6><p>从键盘让用户输入几个文件，脚本能够将此几个文件归档压缩成一个文件；</p>
<p>read:</p>
<p>​	-p “PROMPT”: 给出提示</p>
<p>​	</p>
<p>脚本编程：</p>
<p>​	顺序结构</p>
<p>​	选择结构</p>
<p>​		if</p>
<p>​		case</p>
<p>​	循环结构</p>
<p>​		for</p>
<p>​		while</p>
<p>​		until</p>
<p>​		</p>
<p>while循环：适用于循环次数未知的场景，要有退出条件</p>
<p>语法：</p>
<p>​	while CONDITION; do</p>
<p>​	  statement</p>
<p>​	  …</p>
<p>​	done</p>
<p>​	</p>
<p>计算100以内所有正整数的和</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>declare -i I&#x3D;1</p>
<p>declare -i SUM&#x3D;0</p>
<p>while [ $I -le 100 ]; do</p>
<p>  let SUM+&#x3D;$I</p>
<p>  let I++</p>
<p>done</p>
<p>echo $SUM</p>
<p>练习：转换用户输入的字符为大写，除了quit:</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>read -p “Input something: “ STRING</p>
<p>while [ $STRING !&#x3D; ‘quit’ ]; do</p>
<p>  echo $STRING | tr ‘a-z’ ‘A-Z’</p>
<p>  read -p “Input something: “ STRING</p>
<p>done</p>
<h6 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h6><p>每隔5秒查看hadoop用户是否登录，如果登录，显示其登录并退出；否则，显示当前时间，并说明hadoop尚未登录：</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>who | grep “hadoop” &amp;&gt; &#x2F;dev&#x2F;null</p>
<p>RETVAL&#x3D;$?</p>
<p>while [ $RETVAL -ne 0 ]; do</p>
<p>  echo “<code>date</code>, hadoop is not log.” </p>
<p>  sleep 5</p>
<p>  who | grep “hadoop” &amp;&gt; &#x2F;dev&#x2F;null</p>
<p>  RETVAL&#x3D;$?</p>
<p>done</p>
<p>echo “hadoop is logged in.”</p>
<p>写一个脚本：</p>
<ol>
<li>显示一个菜单给用户：</li>
</ol>
<p>d|D) show disk usages.</p>
<p>m|M) show memory usages.</p>
<p>s|S) show swap usages.</p>
<p>*) quit.</p>
<ol start="2">
<li>当用户给定选项后显示相应的内容；</li>
</ol>
<p>扩展：</p>
<p>​	当用户选择完成，显示相应信息后，不退出；而让用户再一次选择，再次显示相应内容；除了用户使用quit；</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>cat &lt;&lt; EOF</p>
<p>d|D) show disk usages.</p>
<p>m|M) show memory usages.</p>
<p>s|S) show swap usages.</p>
<p>*) quit.</p>
<p>EOF</p>
<p>read -p “Your choice: “ CHOICE</p>
<p>while [ $CHOICE !&#x3D; ‘quit’ ];do</p>
<p>  case $CHOICE in</p>
<p>  d|D)</p>
<p>​    echo “Disk usage: “</p>
<p>​    df -Ph ;;</p>
<p>  m|M)</p>
<p>​    echo “Memory usage: “</p>
<p>​    free -m | grep “Mem” ;;</p>
<p>  s|S)</p>
<p>​    echo “Swap usage: “</p>
<p>​    free -m | grep “Swap” ;;</p>
<p>  *)</p>
<p>​    echo “Unknown..” ;;</p>
<p>  esac</p>
<p>read -p “Again, your choice: “ CHOICE</p>
<p>done	</p>
<p>ext2: 文件系统块组组成：</p>
<p>超级块、GDT、block bitmap、inode bitmap、data blocks</p>
<p>文件系统挂载时的注意事项：</p>
<p>1、挂载点事先存在；</p>
<p>2、目录是否已经被其它进程使用；</p>
<p>3、目录中的原有文件会被暂时隐藏；</p>
<p>mount DEVICE MOUNT_POINT</p>
<p>1、设备文件；</p>
<p>2、LABEL</p>
<p>3、UUID</p>
<p>&#x2F;etc&#x2F;fstab文件格式：</p>
<p>设备		挂载点		文件系统类型		挂载选项		转储频率  检测次序</p>
<p>tune2fs</p>
<p>​	-l</p>
<p>​	-L</p>
<p>​	-o</p>
<p>dumpe2fs -h</p>
<p>安装RHEL6.3 x86_64的方法（前提：请确保你的CPU支持硬件虚拟化技术）：</p>
<p>1、创建虚拟机；</p>
<p>2、下载isos目录中的rhci-rhel-6.3-1.iso，并导入虚拟机的虚拟光驱；</p>
<p>3、在boot提示符输入：linux ip&#x3D;172.16.x.1 netmask&#x3D;255.255.0.0 gateway&#x3D;172.16.0.1 dns&#x3D;172.16.0.1 ks&#x3D;<a href="http://172.16.0.1/rhel6.cfg">http://172.16.0.1/rhel6.cfg</a></p>
<p>​	</p>
<p>64, 32</p>
<p>&#x2F;lib</p>
<p>&#x2F;lib64</p>
<p>RAID: </p>
<p>级别：仅代表磁盘组织方式不同，没有上下之分；</p>
<p>0： 条带</p>
<p>​	性能提升: 读，写</p>
<p>​	冗余能力（容错能力）: 无</p>
<p>​	空间利用率：nS</p>
<p>​	至少2块盘</p>
<p>1： 镜像</p>
<p>​	性能表现：写性能下降，读性能提升</p>
<p>​	冗余能力：有</p>
<p>​	空间利用率：1&#x2F;2</p>
<p>​	至少2块盘</p>
<p>2</p>
<p>3</p>
<p>4: </p>
<p>5: </p>
<p>​	性能表现：读，写提升</p>
<p>​	冗余能力：有</p>
<p>​	空间利用率：(n-1)&#x2F;n</p>
<p>​	至少需要3块</p>
<p>10:</p>
<p>​	性能表现：读、写提升</p>
<p>​	冗余能力：有</p>
<p>​	空间利用率：1&#x2F;2</p>
<p>​	至少需要4块</p>
<p>01:</p>
<p>​	性能表现：读、写提升</p>
<p>​	冗余能力：有</p>
<p>​	空间利用率：1&#x2F;2</p>
<p>​	至少需要4块</p>
<p>50:</p>
<p>​	性能表现：读、写提升</p>
<p>​	冗余能力：有</p>
<p>​	空间利用率：(n-2)&#x2F;n</p>
<p>​    至少需要6块</p>
<p>jbod:</p>
<p>​	性能表现：无提升</p>
<p>​	冗余能力：无</p>
<p>​	空间利用率：100%</p>
<p>​	至少需要2块</p>
<p>逻辑RIAD：</p>
<p>&#x2F;dev&#x2F;md0</p>
<p>&#x2F;dev&#x2F;md1</p>
<p>md: </p>
<p>mdadm: 将任何块设备做成RAID</p>
<p>模式化的命令：</p>
<p>​	创建模式</p>
<p>​		-C </p>
<p>​			专用选项：</p>
<p>​				-l: 级别</p>
<p>​				-n #: 设备个数</p>
<p>​				-a {yes|no}: 是否自动为其创建设备文件</p>
<p>​				-c: CHUNK大小, 2^n，默认为64K</p>
<p>​				-x #: 指定空闲盘个数</p>
<p>​	管理模式</p>
<p>​		–add, –remove, –fail</p>
<p>​		mdadm &#x2F;dev&#x2F;md# –fail &#x2F;dev&#x2F;sda7</p>
<p>​	监控模式</p>
<p>​		-F</p>
<p>​	增长模式</p>
<p>​		-G</p>
<p>​	装配模式</p>
<p>​		-A</p>
<p>查看RAID阵列的详细信息</p>
<p>mdadm -D &#x2F;dev&#x2F;md#</p>
<p>​	–detail</p>
<p>​	</p>
<p>停止阵列：</p>
<p>​	mdadm -S &#x2F;dev&#x2F;md#</p>
<p>​		–stop</p>
<p>创建一个空间大小为10G的RAID5设备；其chuck大小为32k；要求此设备开机时可以自动挂载至&#x2F;backup目录；</p>
<p>RAID0</p>
<p>​	2G:</p>
<p>​		4: 512MB</p>
<p>​		2: 1G</p>
<p>RAID1</p>
<p>​	2G</p>
<p>​		2：2G</p>
<p>​		</p>
<p>​		</p>
<p>watch: 周期性地执行指定命令，并以全屏方式显示结果</p>
<p>​	-n #：指定周期长度，单位为秒，默认为2</p>
<p>格式： watch -n # ‘COMMAND’</p>
<p>​	</p>
<p>将当前RAID信息保存至配置文件，以便以后进行装配：</p>
<p>mdamd -D –scan &gt; &#x2F;etc&#x2F;mdadm.conf</p>
<p>RAID5: </p>
<p>​	2G: 3, 1G</p>
<p>​	</p>
<p>归档</p>
<p>–xattrs</p>
<p>文件系统类型：</p>
<p>​	ext2</p>
<p>​	ext3</p>
<p>​	</p>
<p>cat &#x2F;proc&#x2F;filesystems : 查看当前内核所支持文件系统类型</p>
<p>RAID: 独立冗余磁盘阵列</p>
<p>Linux：硬件，软件</p>
<p>​	&#x2F;dev&#x2F;md#</p>
<p>​	</p>
<p>MD: Multi Device, 多设备</p>
<p>mdadm：用户空间工具，管理工具</p>
<p>​	创建</p>
<p>​		-C</p>
<p>​	管理</p>
<p>​		–add, –remove, –fail</p>
<p>​		-a, -r, -f</p>
<p>​	监控</p>
<p>​	增长</p>
<p>​	装配</p>
<p>​		-A</p>
<p>​	-S</p>
<p>​	-D</p>
<p>​	</p>
<p>RAID0, RAID1</p>
<p>RAID01, RAID10</p>
<p>RAID0+1: </p>
<p>MD, DM</p>
<p>​	&#x2F;dev&#x2F;md#</p>
<p>​	meta device</p>
<p>DM: Device Mapper</p>
<p>​	逻辑设备</p>
<p>​		RAID, LVM2</p>
<p>​		</p>
<p>DM: LVM2</p>
<p>​	快照</p>
<p>​	多路径</p>
<p>任务计划</p>
<p>10G, VG</p>
<p>vgcreate VG_NAME &#x2F;PATH&#x2F;TO&#x2F;PV</p>
<p>​	-s #: PE大小，默认为4MB</p>
<p>​	</p>
<p>lvcreate -n LV_NAME -L #G VG_NAME</p>
<p>练习：创建一个由两个物理卷组成的大小为20G的卷组myvg，要求其PE大小为16M；而后在此卷组中创建一个大小为5G的逻辑卷lv1，此逻辑卷要能在开机后自动挂载至&#x2F;users目录，且支持ACL功能；</p>
<p>缩减前面创建的逻辑卷lv1的大小至2G；</p>
<p>一、扩展逻辑卷；</p>
<p>lvextend</p>
<p>​	-L [+]# &#x2F;PATH&#x2F;TO&#x2F;LV</p>
<p>2G, +3G</p>
<p>5G	</p>
<p>​	</p>
<p>resize2fs</p>
<p>​	resize2fs -p &#x2F;PATH&#x2F;TO&#x2F;LV</p>
<h5 id="二、缩减逻辑卷；"><a href="#二、缩减逻辑卷；" class="headerlink" title="二、缩减逻辑卷；"></a>二、缩减逻辑卷；</h5><p>注意：1、不能在线缩减，得先卸载；</p>
<p>​	  2、确保缩减后的空间大小依然能存储原有的所有数据；</p>
<p>​	  3、在缩减之前应该先强行检查文件，以确保文件系统处于一至性状态；</p>
<p>df -lh</p>
<p>umount </p>
<p>e2fsck -f</p>
<p>​	  	  </p>
<p>resize2fs </p>
<p>​	resize2fs &#x2F;PATH&#x2F;TO&#x2F;PV 3G</p>
<p>lvreduce -L [-]# &#x2F;PATH&#x2F;TO&#x2F;LV</p>
<p>重新挂载</p>
<h5 id="三、快照卷"><a href="#三、快照卷" class="headerlink" title="三、快照卷"></a>三、快照卷</h5><p>1、生命周期为整个数据时长；在这段时长内，数据的增长量不能超出快照卷大小；</p>
<p>2、快照卷应该是只读的；</p>
<p>3、跟原卷在同一卷组内；</p>
<p>lvcreate </p>
<p>​	-s</p>
<p>​	-p r|w</p>
<p>​	</p>
<p>lvcreate -L # -n SLV_NAME -p r &#x2F;PATH&#x2F;TO&#x2F;LV</p>
<p>脚本编程控制结构：</p>
<p>​	顺序</p>
<p>​	选择</p>
<p>​		if</p>
<p>​		case</p>
<p>​	循环</p>
<p>​		for </p>
<p>​		while</p>
<p>​		until</p>
<p>while CONDITION; do</p>
<p>  statment</p>
<p>done</p>
<p>进入循环：条件满足</p>
<p>退出循环：条件不满足</p>
<p>​		</p>
<p>until CONDITION; do</p>
<p>  statement</p>
<p>  …</p>
<p>done</p>
<p>进入循环：条件不满足</p>
<p>退出循环：条件满足</p>
<p>for 变量 in 列表; do </p>
<p>​	循环体</p>
<p>done</p>
<p>​		</p>
<p>for (( expr1 ; expr2 ; expr3 )); do </p>
<p>  循环体</p>
<p>done</p>
<p>写一个脚本：</p>
<p>1、通过ping命令测试192.168.0.151到192.168.0.254之间的所有主机是否在线，</p>
<p>​	如果在线，就显示”ip is up.”，其中的IP要换为真正的IP地址，且以绿色显示；</p>
<p>​	如果不在线，就显示”ip is down.”，其中的IP要换为真正的IP地址，且以红色显示；</p>
<p>要求：分别使用while，until和for(两种形式)循环实现。</p>
<p>ping</p>
<p>​	-c</p>
<p>​	-W</p>
<p>awk ‘PATTERN{ACTION}’ file</p>
<p>​	print $1</p>
<p>写一个脚本(前提：请为虚拟机新增一块硬盘，假设它为&#x2F;dev&#x2F;sdb)，为指定的硬盘创建分区：</p>
<p>1、列出当前系统上所有的磁盘，让用户选择，如果选择quit则退出脚本；如果用户选择错误，就让用户重新选择；</p>
<p>2、当用户选择后，提醒用户确认接下来的操作可能会损坏数据，并请用户确认；如果用户选择y就继续，n就退出；否则，让用户重新选择；</p>
<p>3、抹除那块硬盘上的所有分区(提示，抹除所有分区后执行sync命令，并让脚本睡眠3秒钟后再分区)；并为其创建三个主分区，第一个为20M，第二个为512M, 第三个为128M，且第三个为swap分区类型；(提示：将分区命令通过echo传送给fdisk即可实现)</p>
<p>fdisk -l |grep “</p>
<p>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512 count&#x3D;1</p>
<p>sync</p>
<p>sleep 3</p>
<p>RAID</p>
<p>LVM：</p>
<p>​	逻辑卷的缩减</p>
<p>​	扩展</p>
<p>​	快照卷</p>
<p>while CONDITION; do</p>
<p>  循环体</p>
<p>done</p>
<p>while [ $VAR !&#x3D; ‘quit’ ];do  </p>
<p>​	</p>
<p>done</p>
<p>​	</p>
<p>网络及网络配置</p>
<p>0000 0001 . 0000 0001</p>
<p>1111 1111 . 0000 0000</p>
<p>0000 0001 . 0000 0010</p>
<p>0000 0001 . 0000 0000</p>
<p>1.0</p>
<p>1.1 –&gt; 2.1</p>
<p>1.0 </p>
<p>1.1 –&gt; 1.2</p>
<p>1.0  1.0</p>
<p>IPv4点分十进制：</p>
<p>0000 0000 - 1111 1111</p>
<p>0-255</p>
<p>221.34.23.12</p>
<p>网络地址：</p>
<p>主机地址：</p>
<p>32位二进制</p>
<p>A类: 255.0.0.0， 8：</p>
<p>​	0 000 0001 - 0 111 1111 </p>
<p>​	127个A类，127用于回环，1-126</p>
<p>​	2^7-1个A类</p>
<p>​	容纳多少个主机：2^24-2</p>
<p>​	主机位全0：网络地址</p>
<p>​	主机位全1：广播地址</p>
<p>B类：255.255.0.0， 16</p>
<p>​	10 00 0000- 10 11 1111</p>
<p>​	128-191</p>
<p>​	129.1.0.0.</p>
<p>​	130.1.0.0</p>
<p>​	64个B类，2^14个B类网</p>
<p>​	容纳多少个主机:2^16-2</p>
<p>C类：255.255.255.0， 24</p>
<p>​	110 0 0000 - 110 1 1111</p>
<p>​	192-223</p>
<p>​	32个C类, 2^21个C类网</p>
<p>​	容纳多个少个主机：2^8-2</p>
<p>私有地址：</p>
<p>​	A类：10.0.0.0&#x2F;8</p>
<p>​	B类：172.16.0.0&#x2F;16-172.31.0.0&#x2F;16</p>
<p>​	C类：192.168.0.0&#x2F;24-192.168.255.0&#x2F;24</p>
<p>​	</p>
<p>路由：选路</p>
<p>​	</p>
<p>​	</p>
<p>ICANN, IANA</p>
<p>​	</p>
<p>D类：</p>
<p>​	1110 0000 - 1110 1111</p>
<p>​	224-239</p>
<p>E类：</p>
<p>主机接入网络：</p>
<p>IP</p>
<p>NETMASK</p>
<p>GATEWAY</p>
<p>HOSTNAME</p>
<p>DNS1</p>
<p>DNS2</p>
<p>DNS3</p>
<p>​	手动指定</p>
<p>​	DHCP：Dynamic Host Configuration Protocol</p>
<p>​		169.254.</p>
<p>路由</p>
<p>Linux: 网络属于内核的功能</p>
<p>RHEL5: &#x2F;etc&#x2F;modprobe.conf</p>
<p>alias</p>
<p>RHEL6: &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;70-persistent-net.rules</p>
<p>以太网：ethX</p>
<p>ifconfig [ethX] </p>
<p>​	-a: 显示所有接口的配置住处</p>
<p>​	</p>
<p>ifconfig ethX IP&#x2F;MASK [up|down] </p>
<p>​	配置的地址立即生效，但重启网络服务或主机，都会失效；</p>
<p>​	</p>
<p>网络服务：</p>
<p>RHEL5:	&#x2F;etc&#x2F;init.d&#x2F;network {start|stop|restart|status}</p>
<p>RHEL6: &#x2F;etc&#x2F;init.d&#x2F;NetworkManager {start|stop|restart|status}</p>
<p>网关：</p>
<p>route </p>
<p>​	add: 添加</p>
<p>​		-host: 主机路由</p>
<p>​		-net：网络路由</p>
<p>​			-net 0.0.0.0</p>
<p>​	route add -net|-host DEST gw NEXTHOP</p>
<p>​	route add default gw NEXTHOP</p>
<p>del：删除</p>
<p>​	-host</p>
<p>​	-net </p>
<p>​	</p>
<p>​	route del -net 10.0.0.0&#x2F;8 </p>
<p>​	route del -net 0.0.0.0</p>
<p>​	route del default</p>
<p>​	所做出的改动重启网络服务或主机后失效；</p>
<p>查看：</p>
<p>​	route -n: 以数字方式显示各主机或端口等相关信息</p>
<p>​	</p>
<p>网络配置文件：</p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;network</p>
<p>网络接口配置文件：</p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-INTERFACE_NAME</p>
<p>DEVICE&#x3D;: 关联的设备名称，要与文件名的后半部“INTERFACE_NAME”保持一致; </p>
<p>BOOTPROTO&#x3D;{static|none|dhcp|bootp}: 引导协议；要使用静态地址，使用static或none；dhcp表示使用DHCP服务器获取地址；</p>
<p>IPADDR&#x3D;: IP地址</p>
<p>NETMASK&#x3D;：子网掩码</p>
<p>GATEWAY&#x3D;：设定默认网关；</p>
<p>ONBOOT&#x3D;：开机时是否自动激活此网络接口；</p>
<p>HWADDR&#x3D;： 硬件地址，要与硬件中的地址保持一致；可省；</p>
<p>USERCTL&#x3D;{yes|no}: 是否允许普通用户控制此接口；</p>
<p>PEERDNS&#x3D;{yes|no}: 是否在BOOTPROTO为dhcp时接受由DHCP服务器指定的DNS地址；</p>
<p>不会立即生效，但重启网络服务或主机都会生效；</p>
<p>路由：</p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;route-ethX</p>
<p>添加格式一：</p>
<p>DEST	via 	NEXTHOP</p>
<p>添加格式二：</p>
<p>ADDRESS0&#x3D;</p>
<p>NETMASK0&#x3D;</p>
<p>GATEWAY0&#x3D;</p>
<p>DNS服务器指定方法只有一种：</p>
<p>&#x2F;etc&#x2F;resolv.conf</p>
<p>nameserver DNS_IP_1</p>
<p>nameserver DNS_IP_2</p>
<p>指定本地解析：</p>
<p>&#x2F;etc&#x2F;hosts</p>
<p>主机IP	主机名	主机别名</p>
<p>172.16.0.1		<a href="http://www.magedu.com/">www.magedu.com</a>		www</p>
<p>DNS–&gt;&#x2F;etc&#x2F;hosts–&gt;DNS</p>
<p>配置主机名：</p>
<p>hostname HOSTNAME</p>
<p>立即生效，但不是永久有效；</p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;network</p>
<p>HOSTNAME&#x3D;</p>
<p>RHEL5：</p>
<p>​	setup: system-config-network-tui</p>
<p>​	system-config-network-gui</p>
<p>​	</p>
<p>ifconfig, 老旧</p>
<p>iproute2</p>
<p>​	ip</p>
<p>​		link: 网络接口属性</p>
<p>​		addr: 协议地址</p>
<p>​		route: 路由</p>
<p>​	link</p>
<p>​		show</p>
<p>​			ip -s link show</p>
<p>​		set</p>
<p>​			ip link set DEV {up|down}</p>
<p>​			</p>
<p>​	addr</p>
<p>​		add</p>
<p>​			ip addr add ADDRESS dev DEV</p>
<p>​		del</p>
<p>​			ip addr del ADDRESS dev DEV</p>
<p>​		show</p>
<p>​			ip addr show dev DEV to PREFIX</p>
<p>​		flush</p>
<p>​			ip addr flush dev DEV to PREFIX</p>
<p>​		</p>
<p>​		</p>
<p>一块网卡可以使用多个地址：</p>
<p>网络设备可以别名：</p>
<p>eth0</p>
<p>​	ethX:X, eth0:0, eth0:1, …</p>
<p>​	</p>
<p>配置方法：</p>
<p>​	ifconfig ethX:X IP&#x2F;NETMASK</p>
<p>​	</p>
<p>​	&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ethX:X</p>
<p>​	DEVICE&#x3D;ethX:X</p>
<p>​	非主要地址不能使用DHCP动态获取; </p>
<p>ip</p>
<p>​	eth1, 添加个地址192.168.100.1</p>
<p>​	</p>
<p>ip addr add 192.168.100.1&#x2F;24 dev eth1 label eth1:0</p>
<p>primary address</p>
<p>secondary adress</p>
<p>192.168.100.6</p>
<p>10.0.1.0&#x2F;24, 192.168.100.6</p>
<p>路由:</p>
<p>route add -net 10.0.1.0&#x2F;24 gw 192.168.100.6</p>
<p>ip route add to 10.0.1.0&#x2F;24 dev eth1 via 192.168.100.6</p>
<p>​	add, change, show, flush, replace</p>
<p>​	</p>
<p>ifconfig eth0, 172.16.200.33&#x2F;16</p>
<p>ifconfig eth0:0 172.16.200.33&#x2F;16</p>
<p>TCP:</p>
<p>​	URG </p>
<p>​	SYN</p>
<p>​	ACK</p>
<p>​	PSH</p>
<p>​	RST</p>
<p>​	FIN</p>
<p>​	</p>
<p>软件包管理</p>
<p>应用程序：</p>
<p>​	程序，Architecture</p>
<p>​	</p>
<p>C语言：源代码–&gt;（编译）二进制格式</p>
<p>脚本：解释器（二进制程序）</p>
<p>源代码–&gt;编译–&gt;链接–&gt;运行</p>
<p>​	程序：</p>
<p>​		库</p>
<p>​			静态</p>
<p>​			动态</p>
<p>​			静态链接</p>
<p>​			动态链接</p>
<p>​				共享库</p>
<p>​				</p>
<p>配置文件：</p>
<p>dir&#x3D;&#x2F;path&#x2F;to&#x2F;somewhere</p>
<p>程序组成部分：</p>
<p>​	二进制程序</p>
<p>​	库</p>
<p>​	配置文件</p>
<p>​	帮助文件</p>
<p>​	</p>
<p>&#x2F;boot</p>
<p>&#x2F;etc</p>
<p>&#x2F;usr</p>
<p>&#x2F;var</p>
<p>&#x2F;dev</p>
<p>&#x2F;lib</p>
<p>&#x2F;tmp</p>
<p>&#x2F;bin</p>
<p>&#x2F;sbin</p>
<p>&#x2F;proc</p>
<p>&#x2F;sys</p>
<p>&#x2F;mnt</p>
<p>&#x2F;media</p>
<p>&#x2F;home</p>
<p>&#x2F;root</p>
<p>&#x2F;misc</p>
<p>&#x2F;opt</p>
<p>&#x2F;srv</p>
<p>&#x2F;usr&#x2F;share&#x2F;man</p>
<p>&#x2F;etc, &#x2F;bin, &#x2F;sbin, &#x2F;lib</p>
<p>​	系统启动就需要用到的程序，这些目录不能挂载额外的分区，必须在根文件系统的分区上</p>
<p>​	</p>
<p>&#x2F;usr&#x2F;</p>
<p>​	bin</p>
<p>​	sbin</p>
<p>​	lib</p>
<p>​	</p>
<p>​	操作系统核心功能，可以单独分区</p>
<p>​	</p>
<p>&#x2F;usr&#x2F;local</p>
<p>​	bin</p>
<p>​	sbin</p>
<p>​	lib</p>
<p>​	etc</p>
<p>​	man</p>
<p>&#x2F;opt</p>
<p>&#x2F;proc</p>
<p>&#x2F;sys</p>
<p>​	不能单独分区，默认为空；</p>
<p>​	</p>
<p>&#x2F;dev: 设备，不能单独分区；</p>
<p>​	udev</p>
<p>​	</p>
<p>&#x2F;root: 不能单独分区</p>
<p>&#x2F;var：建议单独分区</p>
<p>&#x2F;boot：内核，initrd(initramfs)</p>
<p>​	内核：</p>
<p>​	</p>
<p>POST–&gt;BIOS(HD)–&gt;(MBR)bootloader(文件系统结构，ext2, ext3, xfs)–&gt;内核</p>
<p>程序：指令+数据</p>
<p>​	指令：芯片</p>
<p>​		CPU: 普通指令，特权指令</p>
<p>​		指令集</p>
<p>​		</p>
<p>C语言：</p>
<p>​	Powerpc: 二进制格式 </p>
<p>​	x86：</p>
<p>x86: 汇编</p>
<p>powerpc: 汇编</p>
<p>高级语言：</p>
<p>C:</p>
<p>软件包管理器的核心功能：</p>
<p>1、制作软件包；</p>
<p>2、安装、卸载、升级、查询、校验；</p>
<p>Redhat, SUSE, Debian</p>
<p>Redhat, SUSE: RPM</p>
<p>​	Redhat Package Manager</p>
<p>​	PRM is Package Manager</p>
<p>Debian: dpt</p>
<p>依赖关系：</p>
<p>​	X–&gt;Y–&gt;Z</p>
<p>​	</p>
<p>​	X–&gt;Y–&gt;Z</p>
<p>​	</p>
<p>前端工具：yum, apt-get</p>
<p>后端工具：RPM, dpt</p>
<p>yum: Yellowdog Update Modifier</p>
<p>​	yum</p>
<p>rpm命令：</p>
<p>​	rpm:</p>
<p>​		数据库:&#x2F;var&#x2F;lib&#x2F;rpm</p>
<p>​	rpmbuild:</p>
<p>​	</p>
<p>安装、查询、卸载、升级、校验、数据库的重建、验正数据包等工作；</p>
<p>rpm命名：</p>
<p>包：组成部分</p>
<p>​	主包：</p>
<p>​		bind-9.7.1-1.el5.i586.rpm</p>
<p>​	子包：</p>
<p>​		bind-libs-9.7.1-1.el5.i586.rpm</p>
<p>​		bind-utils-9.7.1-1.el5.i586.rpm</p>
<p>包名格式：</p>
<p>​	name-version-release.arch.rpm</p>
<p>​	bind-major.minor.release-release.arch.rpm</p>
<p>主版本号：重大改进</p>
<p>次版本号：某个子功能发生重大变化</p>
<p>发行号：修正了部分bug，调整了一点功能</p>
<p>bind-9.7.1.tar.gz	</p>
<p>rpm包：</p>
<p>​	二进制格式</p>
<p>​		rpm包作者下载源程序，编译配置完成后，制作成rpm包</p>
<p>​		bind-9.7.1-1.noarch.rpm</p>
<p>​		bind-9.7.1-1.ppc.rpm</p>
<p>rpm:</p>
<p>1、安装</p>
<p>rpm -i &#x2F;PATH&#x2F;TO&#x2F;PACKAGE_FILE</p>
<p>​	-h: 以#显示进度；每个#表示2%; </p>
<p>​	-v: 显示详细过程</p>
<p>​	-vv: 更详细的过程</p>
<p>​	</p>
<p>rpm -ivh &#x2F;PATH&#x2F;TO&#x2F;PACKAGE_FILE</p>
<p>​	–nodeps: 忽略依赖关系；</p>
<p>​	–replacepkgs: 重新安装，替换原有安装；</p>
<p>​	–force: 强行安装，可以实现重装或降级；</p>
<p>​	</p>
<p>2、查询</p>
<p>rpm -q PACKAGE_NAME： 查询指定的包是否已经安装</p>
<p>rpm -qa : 查询已经安装的所有包</p>
<p>rpm -qi PACKAGE_NAME: 查询指定包的说明信息；</p>
<p>rpm -ql PACKAGE_NAME: 查询指定包安装后生成的文件列表；</p>
<p>rpm -qc PACEAGE_NEME：查询指定包安装的配置文件；</p>
<p>rpm -qd PACKAGE_NAME: 查询指定包安装的帮助文件；</p>
<p>rpm -q –scripts PACKAGE_NAME: 查询指定包中包含的脚本</p>
<p>​	</p>
<p>rpm -qf &#x2F;path&#x2F;to&#x2F;somefile: 查询指定的文件是由哪个rpm包安装生成的；</p>
<p>​	</p>
<p>如果某rpm包尚未安装，我们需查询其说明信息、安装以后会生成的文件；</p>
<p>rpm -qpi &#x2F;PATH&#x2F;TO&#x2F;PACKAGE_FILE</p>
<p>rpm -qpl </p>
<p>3、升级</p>
<p>rpm -Uvh &#x2F;PATH&#x2F;TO&#x2F;NEW_PACKAGE_FILE: 如果装有老版本的，则升级；否则，则安装；</p>
<p>rpm -Fvh &#x2F;PATH&#x2F;TO&#x2F;NEW_PACKAGE_FILE：如果装有老版本的，则升级；否则，退出；</p>
<p>​	–oldpackage: 降级</p>
<p>​	</p>
<p>4、卸载</p>
<p>rpm -e PACKAGE_NAME</p>
<p>​	–nodeps</p>
<p>​	</p>
<p>5、校验</p>
<p>​	rpm -V PACKAGE_NAME</p>
<p>​	</p>
<p>6、重建数据库</p>
<p>​	rpm </p>
<p>​		–rebuilddb: 重建数据库，一定会重新建立；</p>
<p>​		–initdb：初始化数据库，没有才建立，有就不用建立；</p>
<p>7、检验来源合法性，及软件包完整性；</p>
<p>加密类型：</p>
<p>​	对称：加密解密使用同一个密钥</p>
<p>​	公钥：一对儿密钥，公钥，私钥；公钥隐含于私钥中，可以提取出来，并公开出去；</p>
<p>​		</p>
<p>​	单向：</p>
<p># ls &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;</p>
<p>​	RPM-GPG-KEY-redhat-release</p>
<p>​	</p>
<p>rpm -K &#x2F;PAPT&#x2F;TO&#x2F;PACKAGE_FILE</p>
<p>​	dsa, gpg: 验正来源合法性，也即验正签名；可以使用–nosignature，略过此项</p>
<p>​	sha1, md5: 验正软件包完整性；可以使用–nodigest，略过此项</p>
<p>​	</p>
<p>​	</p>
<p>rpm –import &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-redhat-release: 导入密钥文件</p>
<p>1、rpm -qf </p>
<p>2、rpm -qpl</p>
<p>​	l: List</p>
<p>​	i: 软件包的信息；</p>
<p>3、–import &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;</p>
<p>4、–rebuilddb</p>
<p>rpm –&gt; yum</p>
<p>HTML: HyperText Mark Language</p>
<p>XML: eXtended Mark Language</p>
<p>XML, JSON: 半结构化的数据</p>
<p>yum仓库中的元数据文件：</p>
<p>primary.xml.gz</p>
<p>​	所有RPM包的列表；</p>
<p>​	依赖关系；</p>
<p>​	每个RPM安装生成的文件列表；</p>
<p>filelists.xml.gz</p>
<p>​	当前仓库中所有RPM包的所有文件列表；</p>
<p>other.xml.gz</p>
<p>​	额外信息，RPM包的修改日志；</p>
<p>repomd.xml</p>
<p>​	记录的是上面三个文件的时间戳和校验和；</p>
<p>​	</p>
<p>yum install zsh</p>
<p>comps*.xml: RPM包分组信息</p>
<p>​	</p>
<p><a href="ftp://172.16.0.1/pub/%7BServer,VT,Cluster,ClusterStorage%7D">ftp://172.16.0.1/pub/{Server,VT,Cluster,ClusterStorage}</a></p>
<p>如何为yum定义repo文件</p>
<p>[Repo_ID]</p>
<p>name&#x3D;Description</p>
<p>baseurl&#x3D;</p>
<p>​	ftp:&#x2F;&#x2F;</p>
<p>​	http:&#x2F;&#x2F;</p>
<p>​	file:&#x2F;&#x2F;&#x2F;</p>
<p>enabled&#x3D;{1|0}</p>
<p>gpgcheck&#x3D;{1|0}</p>
<p>gpgkey&#x3D;</p>
<p>yum [options] [command] [package …]</p>
<p>-y: 自动回答为yes</p>
<p>–nogpgcheck</p>
<p>list: 列表 </p>
<p>​	支持glob</p>
<p>​	all</p>
<p>​	available：可用的，仓库中有但尚未安装的</p>
<p>​	installed: 已经安装的</p>
<p>​	updates: 可用的升级</p>
<p>clean: 清理缓存</p>
<p>​	[ packages | headers | metadata | dbcache | all ]</p>
<p>​	</p>
<p>repolist: 显示repo列表及其简要信息</p>
<p>​	all</p>
<p>​	enabled： 默认</p>
<p>​	disabled</p>
<p>install: 安装</p>
<p>yum install PACKAGE_NAME</p>
<p>update: 升级</p>
<p>update_to: 升级为指定版本</p>
<p>remove|erase：卸载</p>
<p>info: </p>
<p>provides| whatprovides: 查看指定的文件或特性是由哪个包安装生成的; </p>
<p>​	</p>
<p>groupinfo</p>
<p>grouplist</p>
<p>groupinstall</p>
<p>groupremove</p>
<p>groupupdate</p>
<p>&#x2F;media&#x2F;cdrom&#x2F;{Server,VT,Cluster,ClusterStorage}</p>
<p>如何创建yum仓库：</p>
<p>createrepo</p>
<p><a href="http://172.16.0.1/yum/%7BServer,VT%7D">http://172.16.0.1/yum/{Server,VT}</a></p>
<p>练习：</p>
<p>1、将系统安装光盘挂载至&#x2F;media&#x2F;yum目录，用其实现yum仓库；</p>
<p>2、配置使用<a href="http://172.16.0.1/yum/%7BServer,VT,Cluster,ClusterStorage%7D%E4%B8%BA%E5%8F%AF%E7%94%A8yum%E4%BB%93%E5%BA%93%EF%BC%9B">http://172.16.0.1/yum/{Server,VT,Cluster,ClusterStorage}为可用yum仓库；</a></p>
<p>写一个脚本，完成以下功能：</p>
<p>说明：此脚本能于同一个repo文件中创建多个Yum源的指向；</p>
<p>1、接受一个文件名做为参数，此文件存放至&#x2F;etc&#x2F;yum.repos.d目录中，且文件名以.repo为后缀；要求，此文件不能事先存，否则，报错；</p>
<p>2、在脚本中，提醒用户输入repo id；如果为quit，则退出脚本；否则，继续完成下面的步骤；</p>
<p>3、repo name以及baseurl的路径，而后以repo文件的格式将其保存至指定的文件中；</p>
<p>4、enabled默认为1，而gpgcheck默认设定为0；</p>
<p>5、此脚本会循环执行多次，除非用户为repo id指定为quit；</p>
<p>if [ -e $1 ]; then</p>
<p>  echo “$1 exist.”</p>
<p>  exit 5</p>
<p>fi</p>
<p>[repo id]</p>
<p>name&#x3D;</p>
<p>baseurl&#x3D;</p>
<p>enabled&#x3D;</p>
<p>gpgcheck&#x3D;</p>
<p>while, until, for</p>
<p>break: 提前退出循环</p>
<p>continue：提前结束本轮循环，而进入下一轮循环；</p>
<p>1000， SUM&gt;5000</p>
<p>while的特殊用法一：</p>
<p>while :;do</p>
<p>done</p>
<p>while的特殊用法二：</p>
<p>while read LINE; do</p>
<p>done &lt; &#x2F;PATH&#x2F;TO&#x2F;SOMEFILE</p>
<p>&#x2F;etc&#x2F;passwd</p>
<p>写一个脚本，完成如下功能：</p>
<p>说明：此脚本能够为指定网卡创建别名，则指定地址；使用格式如：mkethalias.sh -v|–verbose -i ethX</p>
<p>1、-i选项用于指定网卡；指定完成后，要判断其是否存在，如果不存在，就退出；</p>
<p>2、如果用户指定的网卡存在，则让用户为其指定一个别名，此别名可以为空；如果不空，请确保其事先不存在，否则，要报错，并让用户重新输入；</p>
<p>3、在用户输入了一个正确的别名后，请用户输入地址和掩码；并将其配置在指定的别名上；</p>
<p>4、如果用户使用了-v选项，则在配置完成后，显示其配置结果信息；否则，将不显示；</p>
<p>RPM安装：</p>
<p>​	二进制格式：</p>
<p>​	源程序–&gt;编译–&gt;二进制格式</p>
<p>​		有些特性是编译选定的，如果编译未选定此特性，将无法使用；</p>
<p>​		rpm包的版本会落后于源码包，甚至落后很多；bind-9.8.7, bind-9.7.2</p>
<p>​		</p>
<p>定制：手动编译安装</p>
<p>编译环境，开发环境</p>
<p>开发库，开发工具</p>
<p>Linux: C,</p>
<p>GNU: C</p>
<p>C，C++:</p>
<p>gcc: GNU C Complier, C</p>
<p>g++: </p>
<p>make: 项目管理工具，</p>
<p>​	makefile: 定义了make（gcc,g++）按何种次序去编译这些源程序文件中的源程序</p>
<p>automake, –&gt; makefile.in –&gt; makefile</p>
<p>autoconf, –&gt; configure</p>
<p>100个可选择特性，</p>
<p>make install</p>
<p>编译安装的三步骤：</p>
<p>前提：准备开发环境(编译环境)</p>
<p>安装”Development Tools”和”Development Libraries” </p>
<p># tar </p>
<p># cd</p>
<p># .&#x2F;configure  </p>
<p>​	–help </p>
<p>​	–prefix&#x3D;&#x2F;path&#x2F;to&#x2F;somewhere</p>
<p>​	–sysconfdir&#x3D;&#x2F;PATH&#x2F;TO&#x2F;CONFFILE_PATH</p>
<p>​	功能：1、让用户选定编译特性；2、检查编译环境；</p>
<p># make</p>
<p># make install</p>
<p># tar xf tengine-1.4.2.tar.gz</p>
<p># cd tegnine-1.4.2</p>
<p># .&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;tengine –conf-path&#x3D;&#x2F;etc&#x2F;tengine&#x2F;tengine.conf</p>
<p># make</p>
<p># make install</p>
<p># &#x2F;usr&#x2F;local&#x2F;tengine&#x2F;sbin&#x2F;nginx</p>
<p>1、修改PATH环境变量，以能够识别此程序的二进制文件路径；</p>
<p>​	修改&#x2F;etc&#x2F;profile文件</p>
<p>​	在&#x2F;etc&#x2F;profile.d&#x2F;目录建立一个以.sh为名称后缀的文件，在里面定义export PATH&#x3D;$PATH:&#x2F;path&#x2F;to&#x2F;somewhere</p>
<p>2、默认情况下，系统搜索库文件的路径&#x2F;lib, &#x2F;usr&#x2F;lib; 要增添额外搜寻路径：</p>
<p>​	在&#x2F;etc&#x2F;ld.so.conf.d&#x2F;中创建以.conf为后缀名的文件，而后把要增添的路径直接写至此文件中；</p>
<p>​	# ldconfig 通知系统重新搜寻库文件</p>
<p>​		-v: 显示重新搜寻库的过程</p>
<p>3、头文件：输出给系统</p>
<p>​	默认：&#x2F;usr&#x2F;include</p>
<p>​	增添头文件搜寻路径，使用链接进行：</p>
<p>​		&#x2F;usr&#x2F;local&#x2F;tengine&#x2F;include&#x2F;   &#x2F;usr&#x2F;include&#x2F;</p>
<p>​		两种方式：</p>
<p>​		ln -s &#x2F;usr&#x2F;local&#x2F;tengine&#x2F;include&#x2F;* &#x2F;usr&#x2F;include&#x2F; 或</p>
<p>​		ln -s &#x2F;usr&#x2F;local&#x2F;tengine&#x2F;include  &#x2F;usr&#x2F;include&#x2F;tengine</p>
<p>4、man文件路径：安装在–prefix指定的目录下的man目录；&#x2F;usr&#x2F;share&#x2F;man	</p>
<p>​		1、man -M &#x2F;PATH&#x2F;TO&#x2F;MAN_DIR COMMAND</p>
<p>​		2、在&#x2F;etc&#x2F;man.config中添加一条MANPATH</p>
<p>​		</p>
<p>​		</p>
<p>netstat命令：</p>
<p>​	-r: 显示路由表</p>
<p>​	-n: 以数字方式显示</p>
<p>​	</p>
<p>​	-t: 建立的tcp连接</p>
<p>​	-u: 显示udp连接</p>
<p>​	-l: 显示监听状态的连接</p>
<p>​	-p: 显示监听指定的套接字的进程的进程号及进程名</p>
<p>​	</p>
<p>​	</p>
<p>循环控制：</p>
<p>break</p>
<p>中断循环，而后执行循环后面的语句；</p>
<p>continue</p>
<p>中断当前这一次循环，提前进入下一软循环</p>
<p>写一个脚本，完成以下功能：</p>
<p>1、提示用户输入一个用户名；</p>
<p>2、显示一个菜单给用户，形如：</p>
<p>U|u  show UID</p>
<p>G|g  show GID</p>
<p>S|s  show SHELL</p>
<p>Q|q  quit</p>
<p>3、提醒用户选择一个选项，并显示其所选择的内容；</p>
<p>如果用户给的是一个非上述所提示的选项，则提醒用户给出的选项错误，并请其重新选择后执行；</p>
<p>写一个脚本：</p>
<p>1、判断一个指定的bash脚本是否有语法错误；如果有错误，则提醒用户键入Q或者q无视错误并退出，其它任何键可以通过vim打开这个指定的脚本；</p>
<p>2、如果用户通过vim打开编辑后保存退出时仍然有错误，则重复第1步中的内容；否则，就正常关闭退出。</p>
<p>.&#x2F;syntax.sh a.sh</p>
<p>until bash -n $1 &amp;&gt; &#x2F;dev&#x2F;null; do</p>
<p>​	read -p “Syntax error, [Qq] to quit, others for editing: “  CHOICE</p>
<p>​	case $CHOICE in</p>
<p>​	q|Q)</p>
<p>​	    echo “Something wrong, quiting.”</p>
<p>​	    exit 5</p>
<p>​	    ;;</p>
<p>​	*)</p>
<p>​		vim + $1</p>
<p>​		;;</p>
<p>​	esac</p>
<p>done</p>
<p>echo “0K”</p>
<p>函数：功能, function</p>
<p>代码重用：</p>
<p>库：so</p>
<p>脚本编程之函数：</p>
<p>function: 功能</p>
<p>结构化编程，不能独立运行，需要调用时执行，可以被多次调用</p>
<p>定义一个函数：</p>
<p>function FUNCNAME {</p>
<p>  command</p>
<p>}</p>
<p>FUNCNAME() {</p>
<p>  command</p>
<p>}</p>
<p>自定义执行状态返回值：</p>
<p>return #</p>
<p>0-255</p>
<p>接受参数的函数：</p>
<p>.&#x2F;a.sh m n </p>
<p>$1: m</p>
<p>$2: n</p>
<p>TWOINT 5 6</p>
<p>$1: 5</p>
<p>$2: 6</p>
<p>练习：写一个脚本，判定192.168.0.200-192.168.0.254之间的主机哪些在线。要求：</p>
<p>1、使用函数来实现一台主机的判定过程；</p>
<p>2、在主程序中来调用此函数判定指定范围内的所有主机的在线情况。</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>PING() {</p>
<p>  for I in {200..254};do</p>
<p>​    if ping -c 1 -W 1 192.168.0.$I &amp;&gt; &#x2F;dev&#x2F;null; then</p>
<p>​      echo “192.168.0.$I is up.”</p>
<p>​    else</p>
<p>​      echo “192.168.0.$I is down.”</p>
<p>​    fi</p>
<p>  done</p>
<p>}</p>
<p>PING</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>PING() {</p>
<p>​    if ping -c 1 -W 1 $1 &amp;&gt; &#x2F;dev&#x2F;null; then</p>
<p>​      echo “$1 is up.”</p>
<p>​    else</p>
<p>​      echo “$1 is down.”</p>
<p>​    fi</p>
<p>}</p>
<p>for I in {200..254}; do</p>
<p>  PING 192.168.0.$I</p>
<p>done</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>PING() {</p>
<p>​    if ping -c 1 -W 1 $1 &amp;&gt; &#x2F;dev&#x2F;null; then</p>
<p>​      return 0</p>
<p>​    else</p>
<p>​      return 1</p>
<p>​    fi</p>
<p>}</p>
<p>for I in {200..254}; do</p>
<p>  PING 192.168.0.$I</p>
<p>  if [ $? -eq 0 ]; then</p>
<p>​    echo “192.168.0.$I is up.”</p>
<p>  else</p>
<p>​    echo “192.168.0.$I is down.”</p>
<p>  fi</p>
<p>done</p>
<p>写一个脚本：使用函数完成</p>
<p>1、函数能够接受一个参数，参数为用户名；</p>
<p>   判断一个用户是否存在</p>
<p>   如果存在，就返回此用户的shell和UID；并返回正常状态值；</p>
<p>   如果不存在，就说此用户不存在；并返回错误状态值；</p>
<p>2、在主程序中调用函数；</p>
<p>扩展1：在主程序中，让用户自己输入用户名后，传递给函数来进行判断；</p>
<p>扩展2：在主程序中，输入用户名判断后不退出脚本，而是提示用户继续输入下一个用户名；如果用户输入的用户不存在，请用户重新输入；但如果用户输入的是q或Q就退出；</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>user () {</p>
<p>if id $1 &amp;&gt; &#x2F;dev&#x2F;null ;then</p>
<p>echo “<code>grep ^$1  /etc/passwd | cut -d: -f3,7</code>“</p>
<p>   return 0</p>
<p>else</p>
<p>   echo “no $1”</p>
<p>​    return 1</p>
<p>fi</p>
<p>}</p>
<p>read -p “please input username:” username</p>
<p>until [ $username &#x3D;&#x3D; q -o $username &#x3D;&#x3D; Q ]; do</p>
<p>​	user $username</p>
<p>​	if [ $? &#x3D;&#x3D; 0 ];then</p>
<p>​		read -p “please input again:” username</p>
<p>​	else</p>
<p>​		read -p “no $username,please input again:” username</p>
<p>​	fi</p>
<p>done</p>
<p>函数也可以接受参数, 即可以向函数传递参数</p>
<p>函数接受一个用户名参数，显示此用户的shell和UID；</p>
<p>写一个函数：接受一命令参数ls</p>
<p>&#x2F;bin&#x2F;ls, &#x2F;mnt&#x2F;sysroot&#x2F;bin&#x2F;ls</p>
<p>&#x2F;sbin&#x2F;ifconfig, &#x2F;mnt&#x2F;sysroot&#x2F;sbin&#x2F;ifconfig</p>
<p>进程及作业管理</p>
<p>Uninterruptible sleep: 不可中断的睡眠</p>
<p>Interruptible sleep：可中断睡眠</p>
<p>kernel:</p>
<p>init: </p>
<p>COW: Copy On Write, 写时复制</p>
<p>100-139：用户可控制</p>
<p>0-99：内核调整的</p>
<p>O：</p>
<p>​	O(1)</p>
<p>​	O(n)</p>
<p>​	O(logn)</p>
<p>​	O(n^2)</p>
<p>​	O(2^n)</p>
<p>​	</p>
<p>init: 进程号为1</p>
<p>ps: Process State</p>
<p>​	SysV风格：-</p>
<p>​	BSD风格:</p>
<p>​	</p>
<p>​	a: 所有与终端有关的进程 </p>
<p>​	u:</p>
<p>​	x: 所有与终端无关的进程</p>
<p>​	</p>
<p>进程的分类：</p>
<p>​	跟终端相关的进程</p>
<p>​	跟终端无关的进程</p>
<p>进程状态：</p>
<p>​	D：不可中断的睡眠</p>
<p>​	R：运行或就绪</p>
<p>​	S：可中断的睡眠</p>
<p>​	T：停止</p>
<p>​	Z：僵死</p>
<p>​	</p>
<p>​	&lt;：高优先级进程</p>
<p>​	N： 低优先级进程</p>
<p>​	+：前台进程组中的进程</p>
<p>​	l: 多线程进程</p>
<p>​	s: 会话进程首进程</p>
<p>ps	</p>
<p>​	-elF</p>
<p>​	-ef</p>
<p>​	-eF</p>
<p>ps -o PROPERTY1,PROPERTY2</p>
<p>ps -o pid,comm,ni</p>
<p>​	</p>
<p>​	</p>
<p>pstree: 显示当前系统上的进程树</p>
<p>pgrep：</p>
<p>pidof: 根据程序名称，查找其相关进程的ID号；</p>
<p>top：</p>
<p>vmstat</p>
<p>free</p>
<p>kill</p>
<p>pkill</p>
<p>bg</p>
<p>fg</p>
<p>&lt;：高优先级的进程</p>
<p>N：低优先级的进程</p>
<p>l: 多线程进程</p>
<p>+：前台进程组中的进程</p>
<p>s: 会话进程的领导者</p>
<p>top:</p>
<p>​	M: 根据驻留内存大小进行排序</p>
<p>​	P：根据CPU使用百分比进行排序</p>
<p>​	T: 根据累计时间进行排序</p>
<p>​	</p>
<p>​	l: 是否显示平均负载和启动时间</p>
<p>​	t: 是否显示进程和CPU状态相关信息</p>
<p>​	m: 是否显示内存相关信息</p>
<p>​	</p>
<p>​	c: 是否显示完整的命令行信息</p>
<p>​	q: 退出top</p>
<p>​	k: 终止某个进程</p>
<p>top </p>
<p>​	-d: 指定延迟时长，单位是秒</p>
<p>​	-b: 批模式</p>
<p>​	-n #：在批模式下，共显示多少批</p>
<p>​	</p>
<p>进程间通信（IPC: Inter Process Communication）</p>
<p>​	共享内存</p>
<p>​	信号: Signal</p>
<p>​	Semaphore</p>
<p>​	</p>
<p>重要的信号：</p>
<p>1：SIGHUP: 让一个进程不用重启，就可以重读其配置文件，并让新的配置信息生效；</p>
<p>2: SIGINT：Ctrl+c: 中断一个进程</p>
<p>9: SIGKILL：杀死一个进程</p>
<p>15: SIGTERM：终止一个进程, 默认信号</p>
<p>​	</p>
<p>指定一个信号：</p>
<p>​	信号号码：kill -1</p>
<p>​	信号名称：kill -SIGKILL</p>
<p>​	信号名称简写：kill -KILL</p>
<p>kill PID</p>
<p>killall COMMAND</p>
<p>调整nice值：</p>
<p>调整已经启动的进程的nice值：</p>
<p>renice NI PID</p>
<p>在启动时指定nice值：</p>
<p>nice -n NI COMMAND</p>
<p>前台作业：占据了命令提示符</p>
<p>后台作业：启动之后，释放命令提示符，后续的操作在后台完成</p>
<p>前台–&gt;后台：</p>
<p>​	Ctrl+z: 把正在前台的作业送往后台</p>
<p>​	COMMAND &amp;：让命令在后台执行</p>
<p>​	</p>
<p>bg: 让后台的停止作业继续运行</p>
<p>​	bg [[%]JOBID]</p>
<p>jobs: 查看后台的所有作业</p>
<p>​	作业号，不同于进程号</p>
<p>​		+：命令将默认操作的作业</p>
<p>​		-：命令将第二个默认操作的作业</p>
<p>​		</p>
<p>fg: 将后台的作业调回前台</p>
<p>​	fg [[%]JOBID]</p>
<p>​	</p>
<p>kill %JOBID: 终止某作业</p>
<p>vmstat：系统状态查看命令</p>
<p>uptime:</p>
<p>&#x2F;proc&#x2F;meminfo</p>
<p>.&#x2F;configure: </p>
<p>​	检查编译环境：编译工具、库、头文件</p>
<p>​	设定编译安装选项</p>
<p>​	结果：结果Makefile.in生成makefile</p>
<p>make</p>
<p>make install</p>
<p>日志系统</p>
<p>Linux系统启动流程</p>
<p>PC: OS(Linux)</p>
<p>POST–&gt;BIOS(Boot Sequence)–&gt;MBR(bootloader,446)–&gt;Kernel–&gt;initrd–&gt;(ROOTFS)&#x2F;sbin&#x2F;init(&#x2F;etc&#x2F;inittab)</p>
<p>启动的服务不同：</p>
<p>​	运行级别：0-6</p>
<p>​		0：halt</p>
<p>​		1: single user mode, 直接以管理员身份切入， s,S,single</p>
<p>​		2：multi user mode, no NFS</p>
<p>​		3: multi user mode, text mode</p>
<p>​		4：reserved</p>
<p>​		5: multi user mode, graphic mode</p>
<p>​		6: reboot</p>
<p>详解启动过程</p>
<p>​	bootloader(MBR)</p>
<p>​		LILO: LInux LOader</p>
<p>​		GRUB: GRand Unified Bootloader</p>
<p>​			Stage1: MBR</p>
<p>​			Stage1_5: </p>
<p>​			Stage2: &#x2F;boot&#x2F;grub&#x2F;</p>
<p>grub.conf			</p>
<p>default&#x3D;0  # 设定默认启动的title的编号，从0开始</p>
<p>timeout&#x3D;5  # 等待用户选择的超时时长，单位是秒</p>
<p>splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz  # grub的背景图片</p>
<p>hiddenmenu # 隐藏菜单</p>
<p>password redhat</p>
<p>password –md5 $1$HKXJ51$B9Z8A.X&#x2F;&#x2F;XA.AtzU1.KuG.</p>
<p>title Red Hat Enterprise Linux Server (2.6.18-308.el5)  # 内核标题，或操作系统名称，字符串，可自由修改</p>
<p>​	root (hd0,0)  # 内核文件所在的设备；对grub而言，所有类型硬盘一律hd，格式为(hd#,N)；hd#, #表示第几个磁盘；最后的N表示对应磁盘的分区；</p>
<p>​	kernel &#x2F;vmlinuz-2.6.18-308.el5 ro root&#x3D;&#x2F;dev&#x2F;vol0&#x2F;root rhgb quiet   # 内核文件路径，及传递给内核的参数</p>
<p>​	initrd &#x2F;initrd-2.6.18-308.el5.img # ramdisk文件路径</p>
<p>​	password –md5 $1$HKXJ51$B9Z8A.X&#x2F;&#x2F;XA.AtzU1.KuG.</p>
<p>title Install Red Hat Enterprise Linux 5</p>
<p>​	root (hd0,0)</p>
<p>​	kernel &#x2F;vmlinuz-5 ks&#x3D;<a href="http://172.16.0.1/workstation.cfg">http://172.16.0.1/workstation.cfg</a> ksdevice&#x3D;eth0 noipv6</p>
<p>​	initrd &#x2F;initrd-5</p>
<p>​	password –md5 $1$FSUEU&#x2F;$uhUUc8USBK5QAXc.BfW4m.</p>
<p>查看运行级别：</p>
<p>runlevel: </p>
<p>who -r</p>
<p>查看内核release号：</p>
<p>​	uname -r</p>
<p>安装grub stage1:</p>
<p># grub</p>
<p>grub&gt; root (hd0,0)</p>
<p>grub&gt; set (hd0)</p>
<p>安装grub第二种方式：</p>
<p># grub-install –root-directory&#x3D;&#x2F;path&#x2F;to&#x2F;boot’s_parent_dir  &#x2F;PATH&#x2F;TO&#x2F;DEVICE</p>
<p>grub&gt; find </p>
<p>grub&gt; root (hd#,N)</p>
<p>grub&gt; kernel &#x2F;PATH&#x2F;TO&#x2F;KERNEL_FILE</p>
<p>grub&gt; initrd &#x2F;PATH&#x2F;TO&#x2F;INITRD_FILE</p>
<p>grub&gt; boot</p>
<p>Kernel初始化的过程：</p>
<p>1、设备探测</p>
<p>2、驱动初始化（可能会从initrd（initramfs）文件中装载驱动模块）</p>
<p>3、以只读挂载根文件系统；</p>
<p>4、装载第一个进程init（PID：1）</p>
<p>&#x2F;sbin&#x2F;init：（&#x2F;etc&#x2F;inittab）</p>
<p>​	upstart: ubuntu, d-bus, event-driven</p>
<p>​	systemd: </p>
<p>id:runlevels:action:process</p>
<p>id: 标识符</p>
<p>runlevels: 在哪个级别运行此行；</p>
<p>action: 在什么情况下执行此行；</p>
<p>process: 要运行程序; </p>
<p>id:3:initdefault:</p>
<p>si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit	</p>
<p>ACTION:</p>
<p>initdefault: 设定默认运行级别</p>
<p>sysinit: 系统初始化</p>
<p>wait: 等待级别切换至此级别时执行</p>
<p>respawn: 一旦程序终止，会重新启动</p>
<p>&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit完成的任务：</p>
<p>1、激活udev和selinux；</p>
<p>2、根据&#x2F;etc&#x2F;sysctl.conf文件，来设定内核参数；</p>
<p>3、设定时钟时钟；</p>
<p>4、装载键盘映射；</p>
<p>5、启用交换分区；</p>
<p>6、设置主机名；</p>
<p>7、根文件系统检测，并以读写方式重新挂载；</p>
<p>8、激活RAID和LVM设备；</p>
<p>9、启用磁盘配额；</p>
<p>10、根据&#x2F;etc&#x2F;fstab，检查并挂载其它文件系统；</p>
<p>11、清理过期的锁和PID文件；</p>
<p>for I in &#x2F;etc&#x2F;rc3.d&#x2F;K*; do</p>
<p>  $I stop</p>
<p>done</p>
<p>for I in &#x2F;etc&#x2F;rc3.d&#x2F;S*; do</p>
<p>  $I start</p>
<p>done</p>
]]></content>
      <tags>
        <tag>网络</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>linux服务器双网卡绑定</title>
    <url>/2024/03/06/%E7%BD%91%E5%8D%A1%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">[root@linuxprobe ~]<span class="comment"># vim /etc/sysconfig/network-scripts/ifcfg-eno16777736</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">USERCTL=no</span><br><span class="line">DEVICE=eno16777736</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br><span class="line"></span><br><span class="line">[root@linuxprobe ~]<span class="comment"># vim /etc/sysconfig/network-scripts/ifcfg-eno33554968</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">USERCTL=no</span><br><span class="line">DEVICE=eno33554968</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">[root@linuxprobe ~]<span class="comment"># vim /etc/sysconfig/network-scripts/ifcfg-bond0</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">USERCTL=no</span><br><span class="line">DEVICE=bond0</span><br><span class="line">IPADDR=192.168.10.10</span><br><span class="line">PREFIX=24</span><br><span class="line">DNS=192.168.10.1</span><br><span class="line">NM_CONTROLLED=no</span><br><span class="line"></span><br><span class="line">3    </span><br><span class="line"></span><br><span class="line">mode0（平衡负载模式）：平时两块网卡均工作，且自动备援，但需要在与服务器本地网卡相连的交换机设备上进行端口聚合来支持绑定技术。</span><br><span class="line">mode1（自动备援模式）：平时只有一块网卡工作，在它故障后自动替换为另外的网卡。</span><br><span class="line">[root@linuxprobe ~]<span class="comment"># vim /etc/modprobe.d/bond.conf</span></span><br><span class="line"><span class="built_in">alias</span> bond0 bonding</span><br><span class="line">options bond0 miimon=100 mode=6</span><br><span class="line">mode6（平衡负载模式）：平时两块网卡均工作，且自动备援，无须交换机设备提供辅助支持。</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>apache虚拟主机</title>
    <url>/2024/03/06/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">ServerName fdipzone.demo.com</span><br><span class="line">DocumentRoot <span class="string">&quot;/home/fdipzone/sites/www&quot;</span></span><br><span class="line">DirectoryIndex index.html index.php</span><br><span class="line"> &lt;Directory <span class="string">&quot;/home/fdipzone/sites/www&quot;</span>&gt;</span><br><span class="line"> 	 Options -Indexes +FollowSymlinks</span><br><span class="line"> 	 AllowOverride All</span><br><span class="line">  	Require all granted</span><br><span class="line"> &lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title>linux释放swap内存</title>
    <url>/2024/03/06/%E9%87%8A%E6%94%BEswap%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h4 id="一：如何释放swap内存"><a href="#一：如何释放swap内存" class="headerlink" title="一：如何释放swap内存"></a>一：如何释放swap内存</h4><ol>
<li>重启占用swap的进程</li>
<li>关闭swap分区(有的时候无法查到占用swap的进程)</li>
</ol>
<h4 id="二：关闭swap分区需要注意的事项和步骤"><a href="#二：关闭swap分区需要注意的事项和步骤" class="headerlink" title="二：关闭swap分区需要注意的事项和步骤"></a>二：关闭swap分区需要注意的事项和步骤</h4><ol>
<li>确保系统空闲内存大于Swap已用内存</li>
<li>可以先清理内存cache，空出足够内存（echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches）</li>
<li>关闭Swap分区(swapoff -a)，这个过程需要时间等待</li>
<li>swap分区释放后，恢复Swap分区(swapon -a)</li>
<li>恢复内存cache的设置(ehco “0” &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches)</li>
</ol>
<h4 id="三：释放swap"><a href="#三：释放swap" class="headerlink" title="三：释放swap"></a>三：释放swap</h4><ol>
<li><p>查看当前swap分区挂载位置</p>
<p>swapon -s </p>
</li>
<li><p>关停这个分区</p>
<p>swapoff &#x2F;dev&#x2F;sda5</p>
</li>
<li><p>再次查看状态</p>
<p>swapon -s</p>
</li>
<li><p>查看内存情况</p>
<p>free -m</p>
</li>
<li><p>将swap挂载在原分区</p>
<p>swapon &#x2F;dev&#x2F;sda5</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 添加静态路由</title>
    <url>/2024/03/06/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h5 id="route命令行添加"><a href="#route命令行添加" class="headerlink" title="route命令行添加"></a>route命令行添加</h5><h6 id="添加到主机的路由"><a href="#添加到主机的路由" class="headerlink" title="添加到主机的路由"></a>添加到主机的路由</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route add -host 192.168.1.50 dev eth0</span><br><span class="line">route add -host 192.168.1.52 gw 192.168.1.1</span><br></pre></td></tr></table></figure>

<h6 id="添加到网络的路由"><a href="#添加到网络的路由" class="headerlink" title="添加到网络的路由"></a>添加到网络的路由</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route add -net 192.168.1.0 netmask 255.255.255.0 dev eth0</span><br><span class="line">route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1</span><br></pre></td></tr></table></figure>

<h6 id="添加默认网关"><a href="#添加默认网关" class="headerlink" title="添加默认网关"></a>添加默认网关</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route add default gw 192.168.1.1</span><br></pre></td></tr></table></figure>

<h6 id="删除路由"><a href="#删除路由" class="headerlink" title="删除路由"></a>删除路由</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route del -host 192.168.1.50 dev eth0</span><br></pre></td></tr></table></figure>

<h5 id="永久设置路由"><a href="#永久设置路由" class="headerlink" title="永久设置路由"></a>永久设置路由</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;1&gt;在rc.local里写命令</span><br><span class="line">&lt;2&gt;/etc/sysconfig/network</span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line">&lt;3&gt;/etc/sysconfig/static-routes</span><br><span class="line">any net 192.168.2.0/24 gw 192.168.2.1</span><br><span class="line">ant net 10.250.228.128 netmask 255.255.255.192 gw 10.250.228.129</span><br></pre></td></tr></table></figure>

<h5 id="开启ip转发"><a href="#开启ip转发" class="headerlink" title="开启ip转发"></a>开启ip转发</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf --&gt; net.ipv4.ip_forward=1 </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
</search>
